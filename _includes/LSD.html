<pre>
<code><span class="hljs-keyword">from</span> collections <span class="hljs-keyword">import</span> defaultdict
<span class="hljs-keyword">from</span> contextlib <span class="hljs-keyword">import</span> ExitStack, contextmanager
<span class="hljs-keyword">from</span> datetime <span class="hljs-keyword">import</span> date, timedelta
<span class="hljs-keyword">from</span> dateutil.relativedelta <span class="hljs-keyword">import</span> relativedelta
<span class="hljs-keyword">from</span> hashlib <span class="hljs-keyword">import</span> sha256
<span class="hljs-keyword">from</span> json <span class="hljs-keyword">import</span> dumps
<span class="hljs-keyword">import</span> logging
<span class="hljs-keyword">from</span> markupsafe <span class="hljs-keyword">import</span> Markup
<span class="hljs-keyword">from</span> psycopg2 <span class="hljs-keyword">import</span> OperationalError
<span class="hljs-keyword">import</span> math
<span class="hljs-keyword">import</span> re
<span class="hljs-keyword">from</span> textwrap <span class="hljs-keyword">import</span> shorten
</code></pre>

<div id="strings"><span>##CONTENT##</span></div>
<div id="typed"></div>

<pre><code>
_logger = logging.getLogger(<span class="hljs-string">"##TITLE##"</span>)


MAX_HASH_VERSION = <span class="hljs-number">3</span>

PAYMENT_STATE_SELECTION = [
        (<span class="hljs-string">'not_paid'</span>, <span class="hljs-string">'Not Paid'</span>),
        (<span class="hljs-string">'in_payment'</span>, <span class="hljs-string">'In Payment'</span>),
        (<span class="hljs-string">'paid'</span>, <span class="hljs-string">'Paid'</span>),
        (<span class="hljs-string">'partial'</span>, <span class="hljs-string">'Partially Paid'</span>),
        (<span class="hljs-string">'reversed'</span>, <span class="hljs-string">'Reversed'</span>),
        (<span class="hljs-string">'invoicing_legacy'</span>, <span class="hljs-string">'Invoicing App Legacy'</span>),
]

TYPE_REVERSE_MAP = {
    <span class="hljs-string">'entry'</span>: <span class="hljs-string">'entry'</span>,
    <span class="hljs-string">'out_invoice'</span>: <span class="hljs-string">'out_refund'</span>,
    <span class="hljs-string">'out_refund'</span>: <span class="hljs-string">'entry'</span>,
    <span class="hljs-string">'in_invoice'</span>: <span class="hljs-string">'in_refund'</span>,
    <span class="hljs-string">'in_refund'</span>: <span class="hljs-string">'entry'</span>,
    <span class="hljs-string">'out_receipt'</span>: <span class="hljs-string">'out_refund'</span>,
    <span class="hljs-string">'in_receipt'</span>: <span class="hljs-string">'in_refund'</span>,
}

EMPTY = <span class="hljs-built_in">object</span>()


<span class="hljs-keyword">class</span> <span class="hljs-title class_">AccountMove</span>(models.Model):
    _name = <span class="hljs-string">"account.move"</span>
    _inherit = [<span class="hljs-string">'portal.mixin'</span>, <span class="hljs-string">'mail.thread.main.attachment'</span>, <span class="hljs-string">'mail.activity.mixin'</span>, <span class="hljs-string">'sequence.mixin'</span>]
    _description = <span class="hljs-string">"Journal Entry"</span>
    _order = <span class="hljs-string">'date desc, name desc, invoice_date desc, id desc'</span>
    _mail_post_access = <span class="hljs-string">'read'</span>
    _check_company_auto = <span class="hljs-literal">True</span>
    _sequence_index = <span class="hljs-string">"journal_id"</span>
    _rec_names_search = [<span class="hljs-string">'name'</span>, <span class="hljs-string">'partner_id.name'</span>, <span class="hljs-string">'ref'</span>]
    _systray_view = <span class="hljs-string">'activity'</span>

<span class="hljs-meta">    @property</span>
    <span class="hljs-keyword">def</span> <span class="hljs-title function_">_sequence_monthly_regex</span>(<span class="hljs-params">self</span>):
        <span class="hljs-keyword">return</span> self.journal_id.sequence_override_regex <span class="hljs-keyword">or</span> <span class="hljs-built_in">super</span>()._sequence_monthly_regex

<span class="hljs-meta">    @property</span>
    <span class="hljs-keyword">def</span> <span class="hljs-title function_">_sequence_yearly_regex</span>(<span class="hljs-params">self</span>):
        <span class="hljs-keyword">return</span> self.journal_id.sequence_override_regex <span class="hljs-keyword">or</span> <span class="hljs-built_in">super</span>()._sequence_yearly_regex

<span class="hljs-meta">    @property</span>
    <span class="hljs-keyword">def</span> <span class="hljs-title function_">_sequence_fixed_regex</span>(<span class="hljs-params">self</span>):
        <span class="hljs-keyword">return</span> self.journal_id.sequence_override_regex <span class="hljs-keyword">or</span> <span class="hljs-built_in">super</span>()._sequence_fixed_regex


    <span class="hljs-comment"># ==============================================================================================</span>
    <span class="hljs-comment">#                                          JOURNAL ENTRY</span>
    <span class="hljs-comment"># ==============================================================================================</span>

    <span class="hljs-comment"># === Accounting fields === #</span>
    name = fields.Char(
        string=<span class="hljs-string">'Number'</span>,
        compute=<span class="hljs-string">'_compute_name'</span>, inverse=<span class="hljs-string">'_inverse_name'</span>, readonly=<span class="hljs-literal">False</span>, store=<span class="hljs-literal">True</span>,
        copy=<span class="hljs-literal">False</span>,
        tracking=<span class="hljs-literal">True</span>,
        index=<span class="hljs-string">'trigram'</span>,
    )
    ref = fields.Char(
        string=<span class="hljs-string">'Reference'</span>,
        copy=<span class="hljs-literal">False</span>,
        tracking=<span class="hljs-literal">True</span>,
        index=<span class="hljs-string">'trigram'</span>,
    )
    date = fields.Date(
        string=<span class="hljs-string">'Date'</span>,
        index=<span class="hljs-literal">True</span>,
        compute=<span class="hljs-string">'_compute_date'</span>, store=<span class="hljs-literal">True</span>, required=<span class="hljs-literal">True</span>, readonly=<span class="hljs-literal">False</span>, precompute=<span class="hljs-literal">True</span>,
        copy=<span class="hljs-literal">False</span>,
        tracking=<span class="hljs-literal">True</span>,
    )
    state = fields.Selection(
        selection=[
            (<span class="hljs-string">'draft'</span>, <span class="hljs-string">'Draft'</span>),
            (<span class="hljs-string">'posted'</span>, <span class="hljs-string">'Posted'</span>),
            (<span class="hljs-string">'cancel'</span>, <span class="hljs-string">'Cancelled'</span>),
        ],
        string=<span class="hljs-string">'Status'</span>,
        required=<span class="hljs-literal">True</span>,
        readonly=<span class="hljs-literal">True</span>,
        copy=<span class="hljs-literal">False</span>,
        tracking=<span class="hljs-literal">True</span>,
        default=<span class="hljs-string">'draft'</span>,
    )
    move_type = fields.Selection(
        selection=[
            (<span class="hljs-string">'entry'</span>, <span class="hljs-string">'Journal Entry'</span>),
            (<span class="hljs-string">'out_invoice'</span>, <span class="hljs-string">'Customer Invoice'</span>),
            (<span class="hljs-string">'out_refund'</span>, <span class="hljs-string">'Customer Credit Note'</span>),
            (<span class="hljs-string">'in_invoice'</span>, <span class="hljs-string">'Vendor Bill'</span>),
            (<span class="hljs-string">'in_refund'</span>, <span class="hljs-string">'Vendor Credit Note'</span>),
            (<span class="hljs-string">'out_receipt'</span>, <span class="hljs-string">'Sales Receipt'</span>),
            (<span class="hljs-string">'in_receipt'</span>, <span class="hljs-string">'Purchase Receipt'</span>),
        ],
        string=<span class="hljs-string">'Type'</span>,
        required=<span class="hljs-literal">True</span>,
        readonly=<span class="hljs-literal">True</span>,
        tracking=<span class="hljs-literal">True</span>,
        change_default=<span class="hljs-literal">True</span>,
        index=<span class="hljs-literal">True</span>,
        default=<span class="hljs-string">"entry"</span>,
    )
    is_storno = fields.Boolean(
        compute=<span class="hljs-string">'_compute_is_storno'</span>, store=<span class="hljs-literal">True</span>, readonly=<span class="hljs-literal">False</span>,
        copy=<span class="hljs-literal">False</span>,
    )
    journal_id = fields.Many2one(
        <span class="hljs-string">'account.journal'</span>,
        string=<span class="hljs-string">'Journal'</span>,
        compute=<span class="hljs-string">'_compute_journal_id'</span>, inverse=<span class="hljs-string">'_inverse_journal_id'</span>, store=<span class="hljs-literal">True</span>, readonly=<span class="hljs-literal">False</span>, precompute=<span class="hljs-literal">True</span>,
        required=<span class="hljs-literal">True</span>,
        check_company=<span class="hljs-literal">True</span>,
        domain=<span class="hljs-string">"[('id', 'in', suitable_journal_ids)]"</span>,
    )
    company_id = fields.Many2one(
        comodel_name=<span class="hljs-string">'res.company'</span>,
        string=<span class="hljs-string">'Company'</span>,
        compute=<span class="hljs-string">'_compute_company_id'</span>, inverse=<span class="hljs-string">'_inverse_company_id'</span>, store=<span class="hljs-literal">True</span>, readonly=<span class="hljs-literal">False</span>, precompute=<span class="hljs-literal">True</span>,
        index=<span class="hljs-literal">True</span>,
    )
    line_ids = fields.One2many(
        <span class="hljs-string">'account.move.line'</span>,
        <span class="hljs-string">'move_id'</span>,
        string=<span class="hljs-string">'Journal Items'</span>,
        copy=<span class="hljs-literal">True</span>,
    )

    <span class="hljs-comment"># === Payment fields === #</span>
    payment_id = fields.Many2one(
        comodel_name=<span class="hljs-string">'account.payment'</span>,
        string=<span class="hljs-string">"Payment"</span>,
        index=<span class="hljs-string">'btree_not_null'</span>,
        copy=<span class="hljs-literal">False</span>,
        check_company=<span class="hljs-literal">True</span>,
    )

    <span class="hljs-comment"># === Statement fields === #</span>
    statement_line_id = fields.Many2one(
        comodel_name=<span class="hljs-string">'account.bank.statement.line'</span>,
        string=<span class="hljs-string">"Statement Line"</span>,
        copy=<span class="hljs-literal">False</span>,
        check_company=<span class="hljs-literal">True</span>,
        index=<span class="hljs-string">'btree_not_null'</span>,
    )
    statement_id = fields.Many2one(
        related=<span class="hljs-string">"statement_line_id.statement_id"</span>
    )

    <span class="hljs-comment"># === Cash basis feature fields === #</span>
    <span class="hljs-comment"># used to keep track of the tax cash basis reconciliation. This is needed</span>
    <span class="hljs-comment"># when cancelling the source: it will post the inverse journal entry to</span>
    <span class="hljs-comment"># cancel that part too.</span>
    tax_cash_basis_rec_id = fields.Many2one(
        comodel_name=<span class="hljs-string">'account.partial.reconcile'</span>,
        string=<span class="hljs-string">'Tax Cash Basis Entry of'</span>,
    )
    tax_cash_basis_origin_move_id = fields.Many2one(
        comodel_name=<span class="hljs-string">'account.move'</span>,
        index=<span class="hljs-string">'btree_not_null'</span>,
        string=<span class="hljs-string">"Cash Basis Origin"</span>,
        readonly=<span class="hljs-literal">True</span>,
        <span class="hljs-built_in">help</span>=<span class="hljs-string">"The journal entry from which this tax cash basis journal entry has been created."</span>,
    )
    tax_cash_basis_created_move_ids = fields.One2many(
        string=<span class="hljs-string">"Cash Basis Entries"</span>,
        comodel_name=<span class="hljs-string">'account.move'</span>,
        inverse_name=<span class="hljs-string">'tax_cash_basis_origin_move_id'</span>,
        <span class="hljs-built_in">help</span>=<span class="hljs-string">"The cash basis entries created from the taxes on this entry, when reconciling its lines."</span>,
    )

    <span class="hljs-comment"># used by cash basis taxes, telling the lines of the move are always</span>
    <span class="hljs-comment"># exigible. This happens if the move contains no payable or receivable line.</span>
    always_tax_exigible = fields.Boolean(compute=<span class="hljs-string">'_compute_always_tax_exigible'</span>, store=<span class="hljs-literal">True</span>, readonly=<span class="hljs-literal">False</span>)

    <span class="hljs-comment"># === Misc fields === #</span>
    auto_post = fields.Selection(
        string=<span class="hljs-string">'Auto-post'</span>,
        selection=[
            (<span class="hljs-string">'no'</span>, <span class="hljs-string">'No'</span>),
            (<span class="hljs-string">'at_date'</span>, <span class="hljs-string">'At Date'</span>),
            (<span class="hljs-string">'monthly'</span>, <span class="hljs-string">'Monthly'</span>),
            (<span class="hljs-string">'quarterly'</span>, <span class="hljs-string">'Quarterly'</span>),
            (<span class="hljs-string">'yearly'</span>, <span class="hljs-string">'Yearly'</span>),
        ],
        default=<span class="hljs-string">'no'</span>, required=<span class="hljs-literal">True</span>, copy=<span class="hljs-literal">False</span>,
        <span class="hljs-built_in">help</span>=<span class="hljs-string">'Specify whether this entry is posted automatically on its accounting date, and any similar recurring invoices.'</span>)
    auto_post_until = fields.Date(
        string=<span class="hljs-string">'Auto-post until'</span>,
        copy=<span class="hljs-literal">False</span>,
        compute=<span class="hljs-string">'_compute_auto_post_until'</span>, store=<span class="hljs-literal">True</span>, readonly=<span class="hljs-literal">False</span>,
        <span class="hljs-built_in">help</span>=<span class="hljs-string">'This recurring move will be posted up to and including this date.'</span>)
    auto_post_origin_id = fields.Many2one(
        comodel_name=<span class="hljs-string">'account.move'</span>,
        string=<span class="hljs-string">'First recurring entry'</span>,
        readonly=<span class="hljs-literal">True</span>, copy=<span class="hljs-literal">False</span>,
        index=<span class="hljs-string">'btree_not_null'</span>,
    )
    hide_post_button = fields.Boolean(compute=<span class="hljs-string">'_compute_hide_post_button'</span>, readonly=<span class="hljs-literal">True</span>)
    to_check = fields.Boolean(
        string=<span class="hljs-string">'To Check'</span>,
        tracking=<span class="hljs-literal">True</span>,
        <span class="hljs-built_in">help</span>=<span class="hljs-string">"If this checkbox is ticked, it means that the user was not sure of all the related "</span>
             <span class="hljs-string">"information at the time of the creation of the move and that the move needs to be "</span>
             <span class="hljs-string">"checked again."</span>,
    )
    posted_before = fields.Boolean(copy=<span class="hljs-literal">False</span>)
    suitable_journal_ids = fields.Many2many(
        <span class="hljs-string">'account.journal'</span>,
        compute=<span class="hljs-string">'_compute_suitable_journal_ids'</span>,
    )
    highest_name = fields.Char(compute=<span class="hljs-string">'_compute_highest_name'</span>)
    made_sequence_hole = fields.Boolean(compute=<span class="hljs-string">'_compute_made_sequence_hole'</span>)
    show_name_warning = fields.Boolean(store=<span class="hljs-literal">False</span>)
    type_name = fields.Char(<span class="hljs-string">'Type Name'</span>, compute=<span class="hljs-string">'_compute_type_name'</span>)
    country_code = fields.Char(related=<span class="hljs-string">'company_id.account_fiscal_country_id.code'</span>, readonly=<span class="hljs-literal">True</span>)
    attachment_ids = fields.One2many(<span class="hljs-string">'ir.attachment'</span>, <span class="hljs-string">'res_id'</span>, domain=[(<span class="hljs-string">'res_model'</span>, <span class="hljs-string">'='</span>, <span class="hljs-string">'account.move'</span>)], string=<span class="hljs-string">'Attachments'</span>)

    <span class="hljs-comment"># === Hash Fields === #</span>
    restrict_mode_hash_table = fields.Boolean(related=<span class="hljs-string">'journal_id.restrict_mode_hash_table'</span>)
    secure_sequence_number = fields.Integer(string=<span class="hljs-string">"Inalteralbility No Gap Sequence #"</span>, readonly=<span class="hljs-literal">True</span>, copy=<span class="hljs-literal">False</span>, index=<span class="hljs-literal">True</span>)
    inalterable_hash = fields.Char(string=<span class="hljs-string">"Inalterability Hash"</span>, readonly=<span class="hljs-literal">True</span>, copy=<span class="hljs-literal">False</span>)
    string_to_hash = fields.Char(compute=<span class="hljs-string">'_compute_string_to_hash'</span>, readonly=<span class="hljs-literal">True</span>)

    <span class="hljs-comment"># ==============================================================================================</span>
    <span class="hljs-comment">#                                          INVOICE</span>
    <span class="hljs-comment"># ==============================================================================================</span>

    invoice_line_ids = fields.One2many(  <span class="hljs-comment"># /!\ invoice_line_ids is just a subset of line_ids.</span>
        <span class="hljs-string">'account.move.line'</span>,
        <span class="hljs-string">'move_id'</span>,
        string=<span class="hljs-string">'Invoice lines'</span>,
        copy=<span class="hljs-literal">False</span>,
        domain=[(<span class="hljs-string">'display_type'</span>, <span class="hljs-string">'in'</span>, (<span class="hljs-string">'product'</span>, <span class="hljs-string">'line_section'</span>, <span class="hljs-string">'line_note'</span>))],
    )

    <span class="hljs-comment"># === Date fields === #</span>
    invoice_date = fields.Date(
        string=<span class="hljs-string">'Invoice/Bill Date'</span>,
        index=<span class="hljs-literal">True</span>,
        copy=<span class="hljs-literal">False</span>,
    )
    invoice_date_due = fields.Date(
        string=<span class="hljs-string">'Due Date'</span>,
        compute=<span class="hljs-string">'_compute_invoice_date_due'</span>, store=<span class="hljs-literal">True</span>, readonly=<span class="hljs-literal">False</span>,
        index=<span class="hljs-literal">True</span>,
        copy=<span class="hljs-literal">False</span>,
    )
    delivery_date = fields.Date(
        string=<span class="hljs-string">'Delivery Date'</span>,
        copy=<span class="hljs-literal">False</span>,
        store=<span class="hljs-literal">True</span>,
        compute=<span class="hljs-string">'_compute_delivery_date'</span>,
    )
    show_delivery_date = fields.Boolean(compute=<span class="hljs-string">'_compute_show_delivery_date'</span>)
    invoice_payment_term_id = fields.Many2one(
        comodel_name=<span class="hljs-string">'account.payment.term'</span>,
        string=<span class="hljs-string">'Payment Terms'</span>,
        compute=<span class="hljs-string">'_compute_invoice_payment_term_id'</span>, store=<span class="hljs-literal">True</span>, readonly=<span class="hljs-literal">False</span>, precompute=<span class="hljs-literal">True</span>,
        inverse=<span class="hljs-string">'_inverse_invoice_payment_term_id'</span>,
        check_company=<span class="hljs-literal">True</span>,
    )
    needed_terms = fields.Binary(compute=<span class="hljs-string">'_compute_needed_terms'</span>, exportable=<span class="hljs-literal">False</span>)
    needed_terms_dirty = fields.Boolean(compute=<span class="hljs-string">'_compute_needed_terms'</span>)
    tax_calculation_rounding_method = fields.Selection(
        related=<span class="hljs-string">'company_id.tax_calculation_rounding_method'</span>,
        string=<span class="hljs-string">'Tax calculation rounding method'</span>, readonly=<span class="hljs-literal">True</span>)
    <span class="hljs-comment"># === Partner fields === #</span>
    partner_id = fields.Many2one(
        <span class="hljs-string">'res.partner'</span>,
        string=<span class="hljs-string">'Partner'</span>,
        readonly=<span class="hljs-literal">False</span>,
        tracking=<span class="hljs-literal">True</span>,
        inverse=<span class="hljs-string">'_inverse_partner_id'</span>,
        check_company=<span class="hljs-literal">True</span>,
        change_default=<span class="hljs-literal">True</span>,
        index=<span class="hljs-literal">True</span>,
        ondelete=<span class="hljs-string">'restrict'</span>,
    )
    commercial_partner_id = fields.Many2one(
        <span class="hljs-string">'res.partner'</span>,
        string=<span class="hljs-string">'Commercial Entity'</span>,
        compute=<span class="hljs-string">'_compute_commercial_partner_id'</span>, store=<span class="hljs-literal">True</span>, readonly=<span class="hljs-literal">True</span>,
        ondelete=<span class="hljs-string">'restrict'</span>,
    )
    partner_shipping_id = fields.Many2one(
        comodel_name=<span class="hljs-string">'res.partner'</span>,
        string=<span class="hljs-string">'Delivery Address'</span>,
        compute=<span class="hljs-string">'_compute_partner_shipping_id'</span>, store=<span class="hljs-literal">True</span>, readonly=<span class="hljs-literal">False</span>, precompute=<span class="hljs-literal">True</span>,
        check_company=<span class="hljs-literal">True</span>,
        <span class="hljs-built_in">help</span>=<span class="hljs-string">"The delivery address will be used in the computation of the fiscal position."</span>,
    )
    partner_bank_id = fields.Many2one(
        <span class="hljs-string">'res.partner.bank'</span>,
        string=<span class="hljs-string">'Recipient Bank'</span>,
        compute=<span class="hljs-string">'_compute_partner_bank_id'</span>, store=<span class="hljs-literal">True</span>, readonly=<span class="hljs-literal">False</span>,
        <span class="hljs-built_in">help</span>=<span class="hljs-string">"Bank Account Number to which the invoice will be paid. "</span>
             <span class="hljs-string">"A Company bank account if this is a Customer Invoice or Vendor Credit Note, "</span>
             <span class="hljs-string">"otherwise a Partner bank account number."</span>,
        check_company=<span class="hljs-literal">True</span>,
        tracking=<span class="hljs-literal">True</span>,
        ondelete=<span class="hljs-string">'restrict'</span>,
    )
    fiscal_position_id = fields.Many2one(
        <span class="hljs-string">'account.fiscal.position'</span>,
        string=<span class="hljs-string">'Fiscal Position'</span>,
        check_company=<span class="hljs-literal">True</span>,
        compute=<span class="hljs-string">'_compute_fiscal_position_id'</span>, store=<span class="hljs-literal">True</span>, readonly=<span class="hljs-literal">False</span>, precompute=<span class="hljs-literal">True</span>,
        ondelete=<span class="hljs-string">"restrict"</span>,
        <span class="hljs-built_in">help</span>=<span class="hljs-string">"Fiscal positions are used to adapt taxes and accounts for particular "</span>
             <span class="hljs-string">"customers or sales orders/invoices. The default value comes from the customer."</span>,
    )

    <span class="hljs-comment"># === Payment fields === #</span>
    payment_reference = fields.Char(
        string=<span class="hljs-string">'Payment Reference'</span>,
        index=<span class="hljs-string">'trigram'</span>,
        copy=<span class="hljs-literal">False</span>,
        <span class="hljs-built_in">help</span>=<span class="hljs-string">"The payment reference to set on journal items."</span>,
        tracking=<span class="hljs-literal">True</span>,
        compute=<span class="hljs-string">'_compute_payment_reference'</span>, inverse=<span class="hljs-string">'_inverse_payment_reference'</span>, store=<span class="hljs-literal">True</span>, readonly=<span class="hljs-literal">False</span>,
    )
    display_qr_code = fields.Boolean(
        string=<span class="hljs-string">"Display QR-code"</span>,
        compute=<span class="hljs-string">'_compute_display_qr_code'</span>,
    )
    qr_code_method = fields.Selection(
        string=<span class="hljs-string">"Payment QR-code"</span>, copy=<span class="hljs-literal">False</span>,
        selection=<span class="hljs-keyword">lambda</span> self: self.env[<span class="hljs-string">'res.partner.bank'</span>].get_available_qr_methods_in_sequence(),
        <span class="hljs-built_in">help</span>=<span class="hljs-string">"Type of QR-code to be generated for the payment of this invoice, "</span>
             <span class="hljs-string">"when printing it. If left blank, the first available and usable method "</span>
             <span class="hljs-string">"will be used."</span>,
    )

    <span class="hljs-comment"># === Payment widget fields === #</span>
    invoice_outstanding_credits_debits_widget = fields.Binary(
        groups=<span class="hljs-string">"account.group_account_invoice,account.group_account_readonly"</span>,
        compute=<span class="hljs-string">'_compute_payments_widget_to_reconcile_info'</span>,
        exportable=<span class="hljs-literal">False</span>,
    )
    invoice_has_outstanding = fields.Boolean(
        groups=<span class="hljs-string">"account.group_account_invoice,account.group_account_readonly"</span>,
        compute=<span class="hljs-string">'_compute_payments_widget_to_reconcile_info'</span>,
    )
    invoice_payments_widget = fields.Binary(
        groups=<span class="hljs-string">"account.group_account_invoice,account.group_account_readonly"</span>,
        compute=<span class="hljs-string">'_compute_payments_widget_reconciled_info'</span>,
        exportable=<span class="hljs-literal">False</span>,
    )

    <span class="hljs-comment"># === Currency fields === #</span>
    company_currency_id = fields.Many2one(
        string=<span class="hljs-string">'Company Currency'</span>,
        related=<span class="hljs-string">'company_id.currency_id'</span>, readonly=<span class="hljs-literal">True</span>,
    )
    currency_id = fields.Many2one(
        <span class="hljs-string">'res.currency'</span>,
        string=<span class="hljs-string">'Currency'</span>,
        tracking=<span class="hljs-literal">True</span>,
        required=<span class="hljs-literal">True</span>,
        compute=<span class="hljs-string">'_compute_currency_id'</span>, inverse=<span class="hljs-string">'_inverse_currency_id'</span>, store=<span class="hljs-literal">True</span>, readonly=<span class="hljs-literal">False</span>, precompute=<span class="hljs-literal">True</span>,
    )

    <span class="hljs-comment"># === Amount fields === #</span>
    direction_sign = fields.Integer(
        compute=<span class="hljs-string">'_compute_direction_sign'</span>,
        <span class="hljs-built_in">help</span>=<span class="hljs-string">"Multiplicator depending on the document type, to convert a price into a balance"</span>,
    )
    amount_untaxed = fields.Monetary(
        string=<span class="hljs-string">'Untaxed Amount'</span>,
        compute=<span class="hljs-string">'_compute_amount'</span>, store=<span class="hljs-literal">True</span>, readonly=<span class="hljs-literal">True</span>,
        tracking=<span class="hljs-literal">True</span>,
    )
    amount_tax = fields.Monetary(
        string=<span class="hljs-string">'Tax'</span>,
        compute=<span class="hljs-string">'_compute_amount'</span>, store=<span class="hljs-literal">True</span>, readonly=<span class="hljs-literal">True</span>,
    )
    amount_total = fields.Monetary(
        string=<span class="hljs-string">'Total'</span>,
        compute=<span class="hljs-string">'_compute_amount'</span>, store=<span class="hljs-literal">True</span>, readonly=<span class="hljs-literal">True</span>,
        inverse=<span class="hljs-string">'_inverse_amount_total'</span>,
    )
    amount_residual = fields.Monetary(
        string=<span class="hljs-string">'Amount Due'</span>,
        compute=<span class="hljs-string">'_compute_amount'</span>, store=<span class="hljs-literal">True</span>,
    )
    amount_untaxed_signed = fields.Monetary(
        string=<span class="hljs-string">'Untaxed Amount Signed'</span>,
        compute=<span class="hljs-string">'_compute_amount'</span>, store=<span class="hljs-literal">True</span>, readonly=<span class="hljs-literal">True</span>,
        currency_field=<span class="hljs-string">'company_currency_id'</span>,
    )
    amount_tax_signed = fields.Monetary(
        string=<span class="hljs-string">'Tax Signed'</span>,
        compute=<span class="hljs-string">'_compute_amount'</span>, store=<span class="hljs-literal">True</span>, readonly=<span class="hljs-literal">True</span>,
        currency_field=<span class="hljs-string">'company_currency_id'</span>,
    )
    amount_total_signed = fields.Monetary(
        string=<span class="hljs-string">'Total Signed'</span>,
        compute=<span class="hljs-string">'_compute_amount'</span>, store=<span class="hljs-literal">True</span>, readonly=<span class="hljs-literal">True</span>,
        currency_field=<span class="hljs-string">'company_currency_id'</span>,
    )
    amount_total_in_currency_signed = fields.Monetary(
        string=<span class="hljs-string">'Total in Currency Signed'</span>,
        compute=<span class="hljs-string">'_compute_amount'</span>, store=<span class="hljs-literal">True</span>, readonly=<span class="hljs-literal">True</span>,
        currency_field=<span class="hljs-string">'currency_id'</span>,
    )
    amount_residual_signed = fields.Monetary(
        string=<span class="hljs-string">'Amount Due Signed'</span>,
        compute=<span class="hljs-string">'_compute_amount'</span>, store=<span class="hljs-literal">True</span>,
        currency_field=<span class="hljs-string">'company_currency_id'</span>,
    )
    tax_totals = fields.Binary(
        string=<span class="hljs-string">"Invoice Totals"</span>,
        compute=<span class="hljs-string">'_compute_tax_totals'</span>,
        inverse=<span class="hljs-string">'_inverse_tax_totals'</span>,
        <span class="hljs-built_in">help</span>=<span class="hljs-string">'Edit Tax amounts if you encounter rounding issues.'</span>,
        exportable=<span class="hljs-literal">False</span>,
    )
    payment_state = fields.Selection(
        selection=PAYMENT_STATE_SELECTION,
        string=<span class="hljs-string">"Payment Status"</span>,
        compute=<span class="hljs-string">'_compute_payment_state'</span>, store=<span class="hljs-literal">True</span>, readonly=<span class="hljs-literal">True</span>,
        copy=<span class="hljs-literal">False</span>,
        tracking=<span class="hljs-literal">True</span>,
    )
    amount_total_words = fields.Char(
        string=<span class="hljs-string">"Amount total in words"</span>,
        compute=<span class="hljs-string">"_compute_amount_total_words"</span>,
    )

    <span class="hljs-comment"># === Reverse feature fields === #</span>
    reversed_entry_id = fields.Many2one(
        comodel_name=<span class="hljs-string">'account.move'</span>,
        string=<span class="hljs-string">"Reversal of"</span>,
        index=<span class="hljs-string">'btree_not_null'</span>,
        readonly=<span class="hljs-literal">True</span>,
        copy=<span class="hljs-literal">False</span>,
        check_company=<span class="hljs-literal">True</span>,
    )
    reversal_move_id = fields.One2many(<span class="hljs-string">'account.move'</span>, <span class="hljs-string">'reversed_entry_id'</span>)

    <span class="hljs-comment"># === Vendor bill fields === #</span>
    invoice_vendor_bill_id = fields.Many2one(
        <span class="hljs-string">'account.move'</span>,
        store=<span class="hljs-literal">False</span>,
        check_company=<span class="hljs-literal">True</span>,
        string=<span class="hljs-string">'Vendor Bill'</span>,
        <span class="hljs-built_in">help</span>=<span class="hljs-string">"Auto-complete from a past bill."</span>,
    )
    invoice_source_email = fields.Char(string=<span class="hljs-string">'Source Email'</span>, tracking=<span class="hljs-literal">True</span>)
    invoice_partner_display_name = fields.Char(compute=<span class="hljs-string">'_compute_invoice_partner_display_info'</span>, store=<span class="hljs-literal">True</span>)

    <span class="hljs-comment"># === Fiduciary mode fields === #</span>
    quick_edit_mode = fields.Boolean(compute=<span class="hljs-string">'_compute_quick_edit_mode'</span>)
    quick_edit_total_amount = fields.Monetary(
        string=<span class="hljs-string">'Total (Tax inc.)'</span>,
        <span class="hljs-built_in">help</span>=<span class="hljs-string">'Use this field to encode the total amount of the invoice.\n'</span>
             <span class="hljs-string">'Odoo will automatically create one invoice line with default values to match it.'</span>,
    )
    quick_encoding_vals = fields.Binary(compute=<span class="hljs-string">'_compute_quick_encoding_vals'</span>, exportable=<span class="hljs-literal">False</span>)

    <span class="hljs-comment"># === Misc Information === #</span>
    narration = fields.Html(
        string=<span class="hljs-string">'Terms and Conditions'</span>,
        compute=<span class="hljs-string">'_compute_narration'</span>, store=<span class="hljs-literal">True</span>, readonly=<span class="hljs-literal">False</span>,
    )
    is_move_sent = fields.Boolean(
        readonly=<span class="hljs-literal">True</span>,
        copy=<span class="hljs-literal">False</span>,
        tracking=<span class="hljs-literal">True</span>,
        <span class="hljs-built_in">help</span>=<span class="hljs-string">"It indicates that the invoice/payment has been sent or the PDF has been generated."</span>,
    )
    is_being_sent = fields.Boolean(
        <span class="hljs-built_in">help</span>=<span class="hljs-string">"Is the move being sent asynchronously"</span>,
        compute=<span class="hljs-string">'_compute_is_being_sent'</span>
    )

    invoice_user_id = fields.Many2one(
        string=<span class="hljs-string">'Salesperson'</span>,
        comodel_name=<span class="hljs-string">'res.users'</span>,
        copy=<span class="hljs-literal">False</span>,
        tracking=<span class="hljs-literal">True</span>,
        compute=<span class="hljs-string">'_compute_invoice_default_sale_person'</span>,
        store=<span class="hljs-literal">True</span>,
        readonly=<span class="hljs-literal">False</span>,
    )
    <span class="hljs-comment"># Technical field used to fit the generic behavior in mail templates.</span>
    user_id = fields.Many2one(string=<span class="hljs-string">'User'</span>, related=<span class="hljs-string">'invoice_user_id'</span>)
    invoice_origin = fields.Char(
        string=<span class="hljs-string">'Origin'</span>,
        readonly=<span class="hljs-literal">True</span>,
        tracking=<span class="hljs-literal">True</span>,
        <span class="hljs-built_in">help</span>=<span class="hljs-string">"The document(s) that generated the invoice."</span>,
    )
    invoice_incoterm_id = fields.Many2one(
        comodel_name=<span class="hljs-string">'account.incoterms'</span>,
        string=<span class="hljs-string">'Incoterm'</span>,
        default=<span class="hljs-keyword">lambda</span> self: self.env.company.incoterm_id,
        <span class="hljs-built_in">help</span>=<span class="hljs-string">'International Commercial Terms are a series of predefined commercial '</span>
             <span class="hljs-string">'terms used in international transactions.'</span>,
    )
    incoterm_location = fields.Char(
        string=<span class="hljs-string">'Incoterm Location'</span>,
        compute=<span class="hljs-string">'_compute_incoterm_location'</span>,
        readonly=<span class="hljs-literal">False</span>,
        store=<span class="hljs-literal">True</span>,
    )
    invoice_cash_rounding_id = fields.Many2one(
        comodel_name=<span class="hljs-string">'account.cash.rounding'</span>,
        string=<span class="hljs-string">'Cash Rounding Method'</span>,
        <span class="hljs-built_in">help</span>=<span class="hljs-string">'Defines the smallest coinage of the currency that can be used to pay by cash.'</span>,
    )
    send_and_print_values = fields.Json(copy=<span class="hljs-literal">False</span>)
    invoice_pdf_report_id = fields.Many2one(
        comodel_name=<span class="hljs-string">'ir.attachment'</span>,
        string=<span class="hljs-string">"PDF Attachment"</span>,
        compute=<span class="hljs-keyword">lambda</span> self: self._compute_linked_attachment_id(<span class="hljs-string">'invoice_pdf_report_id'</span>, <span class="hljs-string">'invoice_pdf_report_file'</span>),
        depends=[<span class="hljs-string">'invoice_pdf_report_file'</span>]
    )
    invoice_pdf_report_file = fields.Binary(
        attachment=<span class="hljs-literal">True</span>,
        string=<span class="hljs-string">"PDF File"</span>,
        copy=<span class="hljs-literal">False</span>,
    )

    <span class="hljs-comment"># === Display purpose fields === #</span>
    <span class="hljs-comment"># used to have a dynamic domain on journal / taxes in the form view.</span>
    invoice_filter_type_domain = fields.Char(compute=<span class="hljs-string">'_compute_invoice_filter_type_domain'</span>)
    bank_partner_id = fields.Many2one(
        comodel_name=<span class="hljs-string">'res.partner'</span>,
        compute=<span class="hljs-string">'_compute_bank_partner_id'</span>,
        <span class="hljs-built_in">help</span>=<span class="hljs-string">'Technical field to get the domain on the bank'</span>,
    )
    <span class="hljs-comment"># used to display a message when the invoice's accounting date is prior of the tax lock date</span>
    tax_lock_date_message = fields.Char(compute=<span class="hljs-string">'_compute_tax_lock_date_message'</span>)
    <span class="hljs-comment"># used for tracking the status of the currency</span>
    display_inactive_currency_warning = fields.Boolean(compute=<span class="hljs-string">"_compute_display_inactive_currency_warning"</span>)
    tax_country_id = fields.Many2one(  <span class="hljs-comment"># used to filter the available taxes depending on the fiscal country and fiscal position.</span>
        comodel_name=<span class="hljs-string">'res.country'</span>,
        compute=<span class="hljs-string">'_compute_tax_country_id'</span>,
    )
    tax_country_code = fields.Char(compute=<span class="hljs-string">"_compute_tax_country_code"</span>)
    has_reconciled_entries = fields.Boolean(compute=<span class="hljs-string">"_compute_has_reconciled_entries"</span>)
    show_reset_to_draft_button = fields.Boolean(compute=<span class="hljs-string">'_compute_show_reset_to_draft_button'</span>)
    partner_credit_warning = fields.Text(
        compute=<span class="hljs-string">'_compute_partner_credit_warning'</span>,
        groups=<span class="hljs-string">"account.group_account_invoice,account.group_account_readonly"</span>,
    )
    partner_credit = fields.Monetary(compute=<span class="hljs-string">'_compute_partner_credit'</span>)
    duplicated_ref_ids = fields.Many2many(comodel_name=<span class="hljs-string">'account.move'</span>, compute=<span class="hljs-string">'_compute_duplicated_ref_ids'</span>)
    need_cancel_request = fields.Boolean(compute=<span class="hljs-string">'_compute_need_cancel_request'</span>)

    <span class="hljs-comment"># used to display the various dates and amount dues on the invoice's PDF</span>
    payment_term_details = fields.Binary(compute=<span class="hljs-string">"_compute_payment_term_details"</span>, exportable=<span class="hljs-literal">False</span>)
    show_payment_term_details = fields.Boolean(compute=<span class="hljs-string">"_compute_show_payment_term_details"</span>)
    show_discount_details = fields.Boolean(compute=<span class="hljs-string">"_compute_show_payment_term_details"</span>)

    _sql_constraints = [(
        <span class="hljs-string">'unique_name'</span>, <span class="hljs-string">""</span>, <span class="hljs-string">"Another entry with the same name already exists."</span>,
    )]

    <span class="hljs-keyword">def</span> <span class="hljs-title function_">_auto_init</span>(<span class="hljs-params">self</span>):
        <span class="hljs-built_in">super</span>()._auto_init()
        <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> index_exists(self.env.cr, <span class="hljs-string">'account_move_to_check_idx'</span>):
            self.env.cr.execute(<span class="hljs-string">"""
                CREATE INDEX account_move_to_check_idx
                          ON account_move(journal_id)
                       WHERE to_check = true
            """</span>)
        <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> index_exists(self.env.cr, <span class="hljs-string">'account_move_payment_idx'</span>):
            self.env.cr.execute(<span class="hljs-string">"""
                CREATE INDEX account_move_payment_idx
                          ON account_move(journal_id, state, payment_state, move_type, date)
            """</span>)
        <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> index_exists(self.env.cr, <span class="hljs-string">'account_move_unique_name'</span>):
            self.env.cr.execute(<span class="hljs-string">"""
                CREATE UNIQUE INDEX account_move_unique_name
                                 ON account_move(name, journal_id)
                              WHERE (state = 'posted' AND name != '/')
            """</span>)
        <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> index_exists(self.env.cr, <span class="hljs-string">'account_move_sequence_index3'</span>):
            <span class="hljs-comment"># Used for gap detection in list views</span>
            self.env.cr.execute(<span class="hljs-string">"""
                CREATE INDEX account_move_sequence_index3
                          ON account_move (journal_id, sequence_prefix desc, (sequence_number+1) desc)
            """</span>)

    <span class="hljs-comment"># -------------------------------------------------------------------------</span>
    <span class="hljs-comment"># COMPUTE METHODS</span>
    <span class="hljs-comment"># -------------------------------------------------------------------------</span>

<span class="hljs-meta">    @api.depends(<span class="hljs-params"><span class="hljs-string">'move_type'</span></span>)</span>
    <span class="hljs-keyword">def</span> <span class="hljs-title function_">_compute_invoice_default_sale_person</span>(<span class="hljs-params">self</span>):
        <span class="hljs-comment"># We want to modify the sale person only when we don't have one and if the move type corresponds to this condition</span>
        <span class="hljs-comment"># If the move doesn't correspond, we remove the sale person</span>
        <span class="hljs-keyword">for</span> move <span class="hljs-keyword">in</span> self:
            <span class="hljs-keyword">if</span> move.is_sale_document(include_receipts=<span class="hljs-literal">True</span>):
                move.invoice_user_id = move.invoice_user_id <span class="hljs-keyword">or</span> self.env.user
            <span class="hljs-keyword">else</span>:
                move.invoice_user_id = <span class="hljs-literal">False</span>

    <span class="hljs-keyword">def</span> <span class="hljs-title function_">_compute_is_being_sent</span>(<span class="hljs-params">self</span>):
        <span class="hljs-keyword">for</span> move <span class="hljs-keyword">in</span> self:
            move.is_being_sent = <span class="hljs-built_in">bool</span>(move.send_and_print_values)

    <span class="hljs-keyword">def</span> <span class="hljs-title function_">_compute_payment_reference</span>(<span class="hljs-params">self</span>):
        <span class="hljs-keyword">for</span> move <span class="hljs-keyword">in</span> self.filtered(<span class="hljs-keyword">lambda</span> m: (
            m.state == <span class="hljs-string">'posted'</span>
            <span class="hljs-keyword">and</span> m.move_type == <span class="hljs-string">'out_invoice'</span>
            <span class="hljs-keyword">and</span> <span class="hljs-keyword">not</span> m.payment_reference
        )):
            move.payment_reference = move._get_invoice_computed_reference()
        self._inverse_payment_reference()

<span class="hljs-meta">    @api.depends(<span class="hljs-params"><span class="hljs-string">'invoice_date'</span>, <span class="hljs-string">'company_id'</span></span>)</span>
    <span class="hljs-keyword">def</span> <span class="hljs-title function_">_compute_date</span>(<span class="hljs-params">self</span>):
        <span class="hljs-keyword">for</span> move <span class="hljs-keyword">in</span> self:
            <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> move.invoice_date:
                <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> move.date:
                    move.date = fields.Date.context_today(self)
                <span class="hljs-keyword">continue</span>
            accounting_date = move.invoice_date
            <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> move.is_sale_document(include_receipts=<span class="hljs-literal">True</span>):
                accounting_date = move._get_accounting_date(move.invoice_date, move._affect_tax_report())
            <span class="hljs-keyword">if</span> accounting_date <span class="hljs-keyword">and</span> accounting_date != move.date:
                move.date = accounting_date
                <span class="hljs-comment"># might be protected because `_get_accounting_date` requires the `name`</span>
                self.env.add_to_compute(self._fields[<span class="hljs-string">'name'</span>], move)

<span class="hljs-meta">    @api.depends(<span class="hljs-params"><span class="hljs-string">'auto_post'</span></span>)</span>
    <span class="hljs-keyword">def</span> <span class="hljs-title function_">_compute_auto_post_until</span>(<span class="hljs-params">self</span>):
        <span class="hljs-keyword">for</span> record <span class="hljs-keyword">in</span> self:
            <span class="hljs-keyword">if</span> record.auto_post <span class="hljs-keyword">in</span> (<span class="hljs-string">'no'</span>, <span class="hljs-string">'at_date'</span>):
                record.auto_post_until = <span class="hljs-literal">False</span>

<span class="hljs-meta">    @api.depends(<span class="hljs-params"><span class="hljs-string">'date'</span>, <span class="hljs-string">'auto_post'</span></span>)</span>
    <span class="hljs-keyword">def</span> <span class="hljs-title function_">_compute_hide_post_button</span>(<span class="hljs-params">self</span>):
        <span class="hljs-keyword">for</span> record <span class="hljs-keyword">in</span> self:
            record.hide_post_button = record.state != <span class="hljs-string">'draft'</span> \
                <span class="hljs-keyword">or</span> record.auto_post != <span class="hljs-string">'no'</span> <span class="hljs-keyword">and</span> record.date &gt; fields.Date.context_today(record)

<span class="hljs-meta">    @api.depends(<span class="hljs-params"><span class="hljs-string">'journal_id'</span></span>)</span>
    <span class="hljs-keyword">def</span> <span class="hljs-title function_">_compute_company_id</span>(<span class="hljs-params">self</span>):
        <span class="hljs-keyword">for</span> move <span class="hljs-keyword">in</span> self:
            <span class="hljs-keyword">if</span> move.journal_id.company_id <span class="hljs-keyword">not</span> <span class="hljs-keyword">in</span> move.company_id.parent_ids:
                move.company_id = (move.journal_id.company_id <span class="hljs-keyword">or</span> self.env.company)._accessible_branches()[:<span class="hljs-number">1</span>]

<span class="hljs-meta">    @api.depends(<span class="hljs-params"><span class="hljs-string">'move_type'</span></span>)</span>
    <span class="hljs-keyword">def</span> <span class="hljs-title function_">_compute_journal_id</span>(<span class="hljs-params">self</span>):
        <span class="hljs-keyword">for</span> record <span class="hljs-keyword">in</span> self.filtered(<span class="hljs-keyword">lambda</span> r: r.journal_id.<span class="hljs-built_in">type</span> <span class="hljs-keyword">not</span> <span class="hljs-keyword">in</span> r._get_valid_journal_types()):
            record.journal_id = record._search_default_journal()

    <span class="hljs-keyword">def</span> <span class="hljs-title function_">_get_valid_journal_types</span>(<span class="hljs-params">self</span>):
        <span class="hljs-keyword">if</span> self.is_sale_document(include_receipts=<span class="hljs-literal">True</span>):
            <span class="hljs-keyword">return</span> [<span class="hljs-string">'sale'</span>]
        <span class="hljs-keyword">elif</span> self.is_purchase_document(include_receipts=<span class="hljs-literal">True</span>):
            <span class="hljs-keyword">return</span> [<span class="hljs-string">'purchase'</span>]
        <span class="hljs-keyword">elif</span> self.payment_id <span class="hljs-keyword">or</span> self.env.context.get(<span class="hljs-string">'is_payment'</span>):
            <span class="hljs-keyword">return</span> [<span class="hljs-string">'bank'</span>, <span class="hljs-string">'cash'</span>]
        <span class="hljs-keyword">return</span> [<span class="hljs-string">'general'</span>]

    <span class="hljs-keyword">def</span> <span class="hljs-title function_">_search_default_journal</span>(<span class="hljs-params">self</span>):
        <span class="hljs-keyword">if</span> self.payment_id <span class="hljs-keyword">and</span> self.payment_id.journal_id:
            <span class="hljs-keyword">return</span> self.payment_id.journal_id
        <span class="hljs-keyword">if</span> self.statement_line_id <span class="hljs-keyword">and</span> self.statement_line_id.journal_id:
            <span class="hljs-keyword">return</span> self.statement_line_id.journal_id
        <span class="hljs-keyword">if</span> self.statement_line_ids.statement_id.journal_id:
            <span class="hljs-keyword">return</span> self.statement_line_ids.statement_id.journal_id[:<span class="hljs-number">1</span>]

        journal_types = self._get_valid_journal_types()
        company = self.company_id <span class="hljs-keyword">or</span> self.env.company
        domain = [
            *self.env[<span class="hljs-string">'account.journal'</span>]._check_company_domain(company),
            (<span class="hljs-string">'type'</span>, <span class="hljs-string">'in'</span>, journal_types),
        ]

        journal = <span class="hljs-literal">None</span>
        <span class="hljs-comment"># the currency is not a hard dependence, it triggers via manual add_to_compute</span>
        <span class="hljs-comment"># avoid computing the currency before all it's dependences are set (like the journal...)</span>
        <span class="hljs-keyword">if</span> self.env.cache.contains(self, self._fields[<span class="hljs-string">'currency_id'</span>]):
            currency_id = self.currency_id.<span class="hljs-built_in">id</span> <span class="hljs-keyword">or</span> self._context.get(<span class="hljs-string">'default_currency_id'</span>)
            <span class="hljs-keyword">if</span> currency_id <span class="hljs-keyword">and</span> currency_id != company.currency_id.<span class="hljs-built_in">id</span>:
                currency_domain = domain + [(<span class="hljs-string">'currency_id'</span>, <span class="hljs-string">'='</span>, currency_id)]
                journal = self.env[<span class="hljs-string">'account.journal'</span>].search(currency_domain, limit=<span class="hljs-number">1</span>)

        <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> journal:
            journal = self.env[<span class="hljs-string">'account.journal'</span>].search(domain, limit=<span class="hljs-number">1</span>)

        <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> journal:
            error_msg = _(
                <span class="hljs-string">"No journal could be found in company %(company_name)s for any of those types: %(journal_types)s"</span>,
                company_name=company.display_name,
                journal_types=<span class="hljs-string">', '</span>.join(journal_types),
            )
            <span class="hljs-keyword">raise</span> UserError(error_msg)

        <span class="hljs-keyword">return</span> journal

<span class="hljs-meta">    @api.depends(<span class="hljs-params"><span class="hljs-string">'move_type'</span></span>)</span>
    <span class="hljs-keyword">def</span> <span class="hljs-title function_">_compute_is_storno</span>(<span class="hljs-params">self</span>):
        <span class="hljs-keyword">for</span> move <span class="hljs-keyword">in</span> self:
            move.is_storno = move.is_storno <span class="hljs-keyword">or</span> (move.move_type <span class="hljs-keyword">in</span> (<span class="hljs-string">'out_refund'</span>, <span class="hljs-string">'in_refund'</span>) <span class="hljs-keyword">and</span> move.company_id.account_storno)

<span class="hljs-meta">    @api.depends(<span class="hljs-params"><span class="hljs-string">'company_id'</span>, <span class="hljs-string">'invoice_filter_type_domain'</span></span>)</span>
    <span class="hljs-keyword">def</span> <span class="hljs-title function_">_compute_suitable_journal_ids</span>(<span class="hljs-params">self</span>):
        <span class="hljs-keyword">for</span> m <span class="hljs-keyword">in</span> self:
            journal_type = m.invoice_filter_type_domain <span class="hljs-keyword">or</span> <span class="hljs-string">'general'</span>
            company = m.company_id <span class="hljs-keyword">or</span> self.env.company
            m.suitable_journal_ids = self.env[<span class="hljs-string">'account.journal'</span>].search([
                *self.env[<span class="hljs-string">'account.journal'</span>]._check_company_domain(company),
                (<span class="hljs-string">'type'</span>, <span class="hljs-string">'='</span>, journal_type),
            ])

<span class="hljs-meta">    @api.depends(<span class="hljs-params"><span class="hljs-string">'posted_before'</span>, <span class="hljs-string">'state'</span>, <span class="hljs-string">'journal_id'</span>, <span class="hljs-string">'date'</span>, <span class="hljs-string">'move_type'</span>, <span class="hljs-string">'payment_id'</span></span>)</span>
    <span class="hljs-keyword">def</span> <span class="hljs-title function_">_compute_name</span>(<span class="hljs-params">self</span>):
        self = self.<span class="hljs-built_in">sorted</span>(<span class="hljs-keyword">lambda</span> m: (m.date, m.ref <span class="hljs-keyword">or</span> <span class="hljs-string">''</span>, m.<span class="hljs-built_in">id</span>))

        <span class="hljs-keyword">for</span> move <span class="hljs-keyword">in</span> self:
            move_has_name = move.name <span class="hljs-keyword">and</span> move.name != <span class="hljs-string">'/'</span>
            <span class="hljs-keyword">if</span> move_has_name <span class="hljs-keyword">or</span> move.state != <span class="hljs-string">'posted'</span>:
                <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> move.posted_before <span class="hljs-keyword">and</span> <span class="hljs-keyword">not</span> move._sequence_matches_date():
                    <span class="hljs-keyword">if</span> move._get_last_sequence():
                        <span class="hljs-comment"># The name does not match the date and the move is not the first in the period:</span>
                        <span class="hljs-comment"># Reset to draft</span>
                        move.name = <span class="hljs-literal">False</span>
                        <span class="hljs-keyword">continue</span>
                <span class="hljs-keyword">else</span>:
                    <span class="hljs-keyword">if</span> move_has_name <span class="hljs-keyword">and</span> move.posted_before <span class="hljs-keyword">or</span> <span class="hljs-keyword">not</span> move_has_name <span class="hljs-keyword">and</span> move._get_last_sequence():
                        <span class="hljs-comment"># The move either</span>
                        <span class="hljs-comment"># - has a name and was posted before, or</span>
                        <span class="hljs-comment"># - doesn't have a name, but is not the first in the period</span>
                        <span class="hljs-comment"># so we don't recompute the name</span>
                        <span class="hljs-keyword">continue</span>
            <span class="hljs-keyword">if</span> move.date <span class="hljs-keyword">and</span> (<span class="hljs-keyword">not</span> move_has_name <span class="hljs-keyword">or</span> <span class="hljs-keyword">not</span> move._sequence_matches_date()):
                move._set_next_sequence()

        self.filtered(<span class="hljs-keyword">lambda</span> m: <span class="hljs-keyword">not</span> m.name <span class="hljs-keyword">and</span> <span class="hljs-keyword">not</span> move.quick_edit_mode).name = <span class="hljs-string">'/'</span>
        self._inverse_name()


<span class="hljs-meta">    @api.depends(<span class="hljs-params"><span class="hljs-string">'journal_id'</span>, <span class="hljs-string">'date'</span></span>)</span>
    <span class="hljs-keyword">def</span> <span class="hljs-title function_">_compute_highest_name</span>(<span class="hljs-params">self</span>):
        <span class="hljs-keyword">for</span> record <span class="hljs-keyword">in</span> self:
            record.highest_name = record._get_last_sequence()

<span class="hljs-meta">    @api.depends(<span class="hljs-params"><span class="hljs-string">'name'</span>, <span class="hljs-string">'journal_id'</span></span>)</span>
    <span class="hljs-keyword">def</span> <span class="hljs-title function_">_compute_made_sequence_hole</span>(<span class="hljs-params">self</span>):
        self.env.cr.execute(<span class="hljs-string">"""
            SELECT this.id
              FROM account_move this
              JOIN res_company company ON company.id = this.company_id
         LEFT JOIN account_move other ON this.journal_id = other.journal_id
                                     AND this.sequence_prefix = other.sequence_prefix
                                     AND this.sequence_number = other.sequence_number + 1
             WHERE other.id IS NULL
               AND this.sequence_number != 1
               AND this.name != '/'
               AND this.id = ANY(%(move_ids)s)
        """</span>, {
            <span class="hljs-string">'move_ids'</span>: self.ids,
        })
        made_sequence_hole = <span class="hljs-built_in">set</span>(r[<span class="hljs-number">0</span>] <span class="hljs-keyword">for</span> r <span class="hljs-keyword">in</span> self.env.cr.fetchall())
        <span class="hljs-keyword">for</span> move <span class="hljs-keyword">in</span> self:
            move.made_sequence_hole = move.<span class="hljs-built_in">id</span> <span class="hljs-keyword">in</span> made_sequence_hole

<span class="hljs-meta">    @api.depends(<span class="hljs-params"><span class="hljs-string">'move_type'</span></span>)</span>
    <span class="hljs-keyword">def</span> <span class="hljs-title function_">_compute_type_name</span>(<span class="hljs-params">self</span>):
        type_name_mapping = <span class="hljs-built_in">dict</span>(
            self._fields[<span class="hljs-string">'move_type'</span>]._description_selection(self.env),
            out_invoice=_(<span class="hljs-string">'Invoice'</span>),
            out_refund=_(<span class="hljs-string">'Credit Note'</span>),
        )

        <span class="hljs-keyword">for</span> record <span class="hljs-keyword">in</span> self:
            record.type_name = type_name_mapping[record.move_type]

<span class="hljs-meta">    @api.depends(<span class="hljs-params"><span class="hljs-string">'line_ids.account_id.account_type'</span></span>)</span>
    <span class="hljs-keyword">def</span> <span class="hljs-title function_">_compute_always_tax_exigible</span>(<span class="hljs-params">self</span>):
        <span class="hljs-keyword">for</span> record <span class="hljs-keyword">in</span> self:
            <span class="hljs-comment"># We need to check is_invoice as well because always_tax_exigible is used to</span>
            <span class="hljs-comment"># set the tags as well, during the encoding. So, if no receivable/payable</span>
            <span class="hljs-comment"># line has been created yet, the invoice would be detected as always exigible,</span>
            <span class="hljs-comment"># and set the tags on some lines ; which would be wrong.</span>
            record.always_tax_exigible = <span class="hljs-keyword">not</span> record.is_invoice(<span class="hljs-literal">True</span>) \
                                         <span class="hljs-keyword">and</span> <span class="hljs-keyword">not</span> record._collect_tax_cash_basis_values()

<span class="hljs-meta">    @api.depends(<span class="hljs-params"><span class="hljs-string">'partner_id'</span></span>)</span>
    <span class="hljs-keyword">def</span> <span class="hljs-title function_">_compute_commercial_partner_id</span>(<span class="hljs-params">self</span>):
        <span class="hljs-keyword">for</span> move <span class="hljs-keyword">in</span> self:
            move.commercial_partner_id = move.partner_id.commercial_partner_id

<span class="hljs-meta">    @api.depends(<span class="hljs-params"><span class="hljs-string">'partner_id'</span></span>)</span>
    <span class="hljs-keyword">def</span> <span class="hljs-title function_">_compute_partner_shipping_id</span>(<span class="hljs-params">self</span>):
        <span class="hljs-keyword">for</span> move <span class="hljs-keyword">in</span> self:
            <span class="hljs-keyword">if</span> move.is_invoice(include_receipts=<span class="hljs-literal">True</span>):
                addr = move.partner_id.address_get([<span class="hljs-string">'delivery'</span>])
                move.partner_shipping_id = addr <span class="hljs-keyword">and</span> addr.get(<span class="hljs-string">'delivery'</span>)
            <span class="hljs-keyword">else</span>:
                move.partner_shipping_id = <span class="hljs-literal">False</span>

<span class="hljs-meta">    @api.depends(<span class="hljs-params"><span class="hljs-string">'partner_id'</span>, <span class="hljs-string">'partner_shipping_id'</span>, <span class="hljs-string">'company_id'</span></span>)</span>
    <span class="hljs-keyword">def</span> <span class="hljs-title function_">_compute_fiscal_position_id</span>(<span class="hljs-params">self</span>):
        <span class="hljs-keyword">for</span> move <span class="hljs-keyword">in</span> self:
            delivery_partner = self.env[<span class="hljs-string">'res.partner'</span>].browse(
                move.partner_shipping_id.<span class="hljs-built_in">id</span>
                <span class="hljs-keyword">or</span> move.partner_id.address_get([<span class="hljs-string">'delivery'</span>])[<span class="hljs-string">'delivery'</span>]
            )
            move.fiscal_position_id = self.env[<span class="hljs-string">'account.fiscal.position'</span>].with_company(move.company_id)._get_fiscal_position(
                move.partner_id, delivery=delivery_partner)

<span class="hljs-meta">    @api.depends(<span class="hljs-params"><span class="hljs-string">'bank_partner_id'</span></span>)</span>
    <span class="hljs-keyword">def</span> <span class="hljs-title function_">_compute_partner_bank_id</span>(<span class="hljs-params">self</span>):
        <span class="hljs-keyword">for</span> move <span class="hljs-keyword">in</span> self:
            bank_ids = move.bank_partner_id.bank_ids.filtered(
                <span class="hljs-keyword">lambda</span> bank: <span class="hljs-keyword">not</span> bank.company_id <span class="hljs-keyword">or</span> bank.company_id == move.company_id)
            move.partner_bank_id = bank_ids[<span class="hljs-number">0</span>] <span class="hljs-keyword">if</span> bank_ids <span class="hljs-keyword">else</span> <span class="hljs-literal">False</span>

<span class="hljs-meta">    @api.depends(<span class="hljs-params"><span class="hljs-string">'partner_id'</span></span>)</span>
    <span class="hljs-keyword">def</span> <span class="hljs-title function_">_compute_invoice_payment_term_id</span>(<span class="hljs-params">self</span>):
        <span class="hljs-keyword">for</span> move <span class="hljs-keyword">in</span> self:
            <span class="hljs-keyword">if</span> move.is_sale_document(include_receipts=<span class="hljs-literal">True</span>) <span class="hljs-keyword">and</span> move.partner_id.property_payment_term_id:
                move.invoice_payment_term_id = move.partner_id.property_payment_term_id
            <span class="hljs-keyword">elif</span> move.is_purchase_document(include_receipts=<span class="hljs-literal">True</span>) <span class="hljs-keyword">and</span> move.partner_id.property_supplier_payment_term_id:
                move.invoice_payment_term_id = move.partner_id.property_supplier_payment_term_id
            <span class="hljs-keyword">else</span>:
                move.invoice_payment_term_id = <span class="hljs-literal">False</span>

<span class="hljs-meta">    @api.depends(<span class="hljs-params"><span class="hljs-string">'needed_terms'</span></span>)</span>
    <span class="hljs-keyword">def</span> <span class="hljs-title function_">_compute_invoice_date_due</span>(<span class="hljs-params">self</span>):
        today = fields.Date.context_today(self)
        <span class="hljs-keyword">for</span> move <span class="hljs-keyword">in</span> self:
            move.invoice_date_due = move.needed_terms <span class="hljs-keyword">and</span> <span class="hljs-built_in">max</span>(
                (k[<span class="hljs-string">'date_maturity'</span>] <span class="hljs-keyword">for</span> k <span class="hljs-keyword">in</span> move.needed_terms.keys() <span class="hljs-keyword">if</span> k),
                default=<span class="hljs-literal">False</span>,
            ) <span class="hljs-keyword">or</span> move.invoice_date_due <span class="hljs-keyword">or</span> today

    <span class="hljs-keyword">def</span> <span class="hljs-title function_">_compute_delivery_date</span>(<span class="hljs-params">self</span>):
        <span class="hljs-keyword">pass</span>

<span class="hljs-meta">    @api.depends(<span class="hljs-params"><span class="hljs-string">'delivery_date'</span></span>)</span>
    <span class="hljs-keyword">def</span> <span class="hljs-title function_">_compute_show_delivery_date</span>(<span class="hljs-params">self</span>):
        <span class="hljs-keyword">for</span> move <span class="hljs-keyword">in</span> self:
            move.show_delivery_date = move.delivery_date <span class="hljs-keyword">and</span> move.is_sale_document()

<span class="hljs-meta">    @api.depends(<span class="hljs-params"><span class="hljs-string">'journal_id'</span>, <span class="hljs-string">'statement_line_id'</span></span>)</span>
    <span class="hljs-keyword">def</span> <span class="hljs-title function_">_compute_currency_id</span>(<span class="hljs-params">self</span>):
        <span class="hljs-keyword">for</span> invoice <span class="hljs-keyword">in</span> self:
            currency = (
                invoice.statement_line_id.foreign_currency_id
                <span class="hljs-keyword">or</span> invoice.journal_id.currency_id
                <span class="hljs-keyword">or</span> invoice.currency_id
                <span class="hljs-keyword">or</span> invoice.journal_id.company_id.currency_id
            )
            invoice.currency_id = currency

<span class="hljs-meta">    @api.depends(<span class="hljs-params"><span class="hljs-string">'move_type'</span></span>)</span>
    <span class="hljs-keyword">def</span> <span class="hljs-title function_">_compute_direction_sign</span>(<span class="hljs-params">self</span>):
        <span class="hljs-keyword">for</span> invoice <span class="hljs-keyword">in</span> self:
            <span class="hljs-keyword">if</span> invoice.move_type == <span class="hljs-string">'entry'</span> <span class="hljs-keyword">or</span> invoice.is_outbound():
                invoice.direction_sign = <span class="hljs-number">1</span>
            <span class="hljs-keyword">else</span>:
                invoice.direction_sign = -<span class="hljs-number">1</span>

<span class="hljs-meta">    @api.depends(<span class="hljs-params">
        <span class="hljs-string">'line_ids.matched_debit_ids.debit_move_id.move_id.payment_id.is_matched'</span>,
        <span class="hljs-string">'line_ids.matched_debit_ids.debit_move_id.move_id.line_ids.amount_residual'</span>,
        <span class="hljs-string">'line_ids.matched_debit_ids.debit_move_id.move_id.line_ids.amount_residual_currency'</span>,
        <span class="hljs-string">'line_ids.matched_credit_ids.credit_move_id.move_id.payment_id.is_matched'</span>,
        <span class="hljs-string">'line_ids.matched_credit_ids.credit_move_id.move_id.line_ids.amount_residual'</span>,
        <span class="hljs-string">'line_ids.matched_credit_ids.credit_move_id.move_id.line_ids.amount_residual_currency'</span>,
        <span class="hljs-string">'line_ids.balance'</span>,
        <span class="hljs-string">'line_ids.currency_id'</span>,
        <span class="hljs-string">'line_ids.amount_currency'</span>,
        <span class="hljs-string">'line_ids.amount_residual'</span>,
        <span class="hljs-string">'line_ids.amount_residual_currency'</span>,
        <span class="hljs-string">'line_ids.payment_id.state'</span>,
        <span class="hljs-string">'line_ids.full_reconcile_id'</span>,
        <span class="hljs-string">'state'</span></span>)</span>
    <span class="hljs-keyword">def</span> <span class="hljs-title function_">_compute_amount</span>(<span class="hljs-params">self</span>):
        <span class="hljs-keyword">for</span> move <span class="hljs-keyword">in</span> self:
            total_untaxed, total_untaxed_currency = <span class="hljs-number">0.0</span>, <span class="hljs-number">0.0</span>
            total_tax, total_tax_currency = <span class="hljs-number">0.0</span>, <span class="hljs-number">0.0</span>
            total_residual, total_residual_currency = <span class="hljs-number">0.0</span>, <span class="hljs-number">0.0</span>
            total, total_currency = <span class="hljs-number">0.0</span>, <span class="hljs-number">0.0</span>

            <span class="hljs-keyword">for</span> line <span class="hljs-keyword">in</span> move.line_ids:
                <span class="hljs-keyword">if</span> move.is_invoice(<span class="hljs-literal">True</span>):
                    <span class="hljs-comment"># === Invoices ===</span>
                    <span class="hljs-keyword">if</span> line.display_type == <span class="hljs-string">'tax'</span> <span class="hljs-keyword">or</span> (line.display_type == <span class="hljs-string">'rounding'</span> <span class="hljs-keyword">and</span> line.tax_repartition_line_id):
                        <span class="hljs-comment"># Tax amount.</span>
                        total_tax += line.balance
                        total_tax_currency += line.amount_currency
                        total += line.balance
                        total_currency += line.amount_currency
                    <span class="hljs-keyword">elif</span> line.display_type <span class="hljs-keyword">in</span> (<span class="hljs-string">'product'</span>, <span class="hljs-string">'rounding'</span>):
                        <span class="hljs-comment"># Untaxed amount.</span>
                        total_untaxed += line.balance
                        total_untaxed_currency += line.amount_currency
                        total += line.balance
                        total_currency += line.amount_currency
                    <span class="hljs-keyword">elif</span> line.display_type == <span class="hljs-string">'payment_term'</span>:
                        <span class="hljs-comment"># Residual amount.</span>
                        total_residual += line.amount_residual
                        total_residual_currency += line.amount_residual_currency
                <span class="hljs-keyword">else</span>:
                    <span class="hljs-comment"># === Miscellaneous journal entry ===</span>
                    <span class="hljs-keyword">if</span> line.debit:
                        total += line.balance
                        total_currency += line.amount_currency

            sign = move.direction_sign
            move.amount_untaxed = sign * total_untaxed_currency
            move.amount_tax = sign * total_tax_currency
            move.amount_total = sign * total_currency
            move.amount_residual = -sign * total_residual_currency
            move.amount_untaxed_signed = -total_untaxed
            move.amount_tax_signed = -total_tax
            move.amount_total_signed = <span class="hljs-built_in">abs</span>(total) <span class="hljs-keyword">if</span> move.move_type == <span class="hljs-string">'entry'</span> <span class="hljs-keyword">else</span> -total
            move.amount_residual_signed = total_residual
            move.amount_total_in_currency_signed = <span class="hljs-built_in">abs</span>(move.amount_total) <span class="hljs-keyword">if</span> move.move_type == <span class="hljs-string">'entry'</span> <span class="hljs-keyword">else</span> -(sign * move.amount_total)

<span class="hljs-meta">    @api.depends(<span class="hljs-params"><span class="hljs-string">'amount_residual'</span>, <span class="hljs-string">'move_type'</span>, <span class="hljs-string">'state'</span>, <span class="hljs-string">'company_id'</span></span>)</span>
    <span class="hljs-keyword">def</span> <span class="hljs-title function_">_compute_payment_state</span>(<span class="hljs-params">self</span>):
        stored_ids = <span class="hljs-built_in">tuple</span>(self.ids)
        <span class="hljs-keyword">if</span> stored_ids:
            self.env[<span class="hljs-string">'account.partial.reconcile'</span>].flush_model()
            self.env[<span class="hljs-string">'account.payment'</span>].flush_model([<span class="hljs-string">'is_matched'</span>])

            queries = []
            <span class="hljs-keyword">for</span> source_field, counterpart_field <span class="hljs-keyword">in</span> ((<span class="hljs-string">'debit'</span>, <span class="hljs-string">'credit'</span>), (<span class="hljs-string">'credit'</span>, <span class="hljs-string">'debit'</span>)):
                queries.append(<span class="hljs-string">f'''
                    SELECT
                        source_line.id AS source_line_id,
                        source_line.move_id AS source_move_id,
                        account.account_type AS source_line_account_type,
                        ARRAY_AGG(counterpart_move.move_type) AS counterpart_move_types,
                        COALESCE(BOOL_AND(COALESCE(pay.is_matched, FALSE))
                            FILTER (WHERE counterpart_move.payment_id IS NOT NULL), TRUE) AS all_payments_matched,
                        BOOL_OR(COALESCE(BOOL(pay.id), FALSE)) as has_payment,
                        BOOL_OR(COALESCE(BOOL(counterpart_move.statement_line_id), FALSE)) as has_st_line
                    FROM account_partial_reconcile part
                    JOIN account_move_line source_line ON source_line.id = part.<span class="hljs-subst">{source_field}</span>_move_id
                    JOIN account_account account ON account.id = source_line.account_id
                    JOIN account_move_line counterpart_line ON counterpart_line.id = part.<span class="hljs-subst">{counterpart_field}</span>_move_id
                    JOIN account_move counterpart_move ON counterpart_move.id = counterpart_line.move_id
                    LEFT JOIN account_payment pay ON pay.id = counterpart_move.payment_id
                    WHERE source_line.move_id IN %s AND counterpart_line.move_id != source_line.move_id
                    GROUP BY source_line_id, source_move_id, source_line_account_type
                '''</span>)

            self._cr.execute(<span class="hljs-string">' UNION ALL '</span>.join(queries), [stored_ids, stored_ids])

            payment_data = defaultdict(<span class="hljs-keyword">lambda</span>: [])
            <span class="hljs-keyword">for</span> row <span class="hljs-keyword">in</span> self._cr.dictfetchall():
                payment_data[row[<span class="hljs-string">'source_move_id'</span>]].append(row)
        <span class="hljs-keyword">else</span>:
            payment_data = {}

        <span class="hljs-keyword">for</span> invoice <span class="hljs-keyword">in</span> self:
            <span class="hljs-keyword">if</span> invoice.payment_state == <span class="hljs-string">'invoicing_legacy'</span>:
                <span class="hljs-comment"># invoicing_legacy state is set via SQL when setting setting field</span>
                <span class="hljs-comment"># invoicing_switch_threshold (defined in account_accountant).</span>
                <span class="hljs-comment"># The only way of going out of this state is through this setting,</span>
                <span class="hljs-comment"># so we don't recompute it here.</span>
                <span class="hljs-keyword">continue</span>

            currencies = invoice._get_lines_onchange_currency().currency_id
            currency = currencies <span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(currencies) == <span class="hljs-number">1</span> <span class="hljs-keyword">else</span> invoice.company_id.currency_id
            reconciliation_vals = payment_data.get(invoice.<span class="hljs-built_in">id</span>, [])
            payment_state_matters = invoice.is_invoice(<span class="hljs-literal">True</span>)

            <span class="hljs-comment"># Restrict on 'receivable'/'payable' lines for invoices/expense entries.</span>
            <span class="hljs-keyword">if</span> payment_state_matters:
                reconciliation_vals = [x <span class="hljs-keyword">for</span> x <span class="hljs-keyword">in</span> reconciliation_vals <span class="hljs-keyword">if</span> x[<span class="hljs-string">'source_line_account_type'</span>] <span class="hljs-keyword">in</span> (<span class="hljs-string">'asset_receivable'</span>, <span class="hljs-string">'liability_payable'</span>)]

            new_pmt_state = <span class="hljs-string">'not_paid'</span>
            <span class="hljs-keyword">if</span> invoice.state == <span class="hljs-string">'posted'</span>:

                <span class="hljs-comment"># Posted invoice/expense entry.</span>
                <span class="hljs-keyword">if</span> payment_state_matters:

                    <span class="hljs-keyword">if</span> currency.is_zero(invoice.amount_residual):
                        <span class="hljs-keyword">if</span> <span class="hljs-built_in">any</span>(x[<span class="hljs-string">'has_payment'</span>] <span class="hljs-keyword">or</span> x[<span class="hljs-string">'has_st_line'</span>] <span class="hljs-keyword">for</span> x <span class="hljs-keyword">in</span> reconciliation_vals):

                            <span class="hljs-comment"># Check if the invoice/expense entry is fully paid or 'in_payment'.</span>
                            <span class="hljs-keyword">if</span> <span class="hljs-built_in">all</span>(x[<span class="hljs-string">'all_payments_matched'</span>] <span class="hljs-keyword">for</span> x <span class="hljs-keyword">in</span> reconciliation_vals):
                                new_pmt_state = <span class="hljs-string">'paid'</span>
                            <span class="hljs-keyword">else</span>:
                                new_pmt_state = invoice._get_invoice_in_payment_state()

                        <span class="hljs-keyword">else</span>:
                            new_pmt_state = <span class="hljs-string">'paid'</span>

                            reverse_move_types = <span class="hljs-built_in">set</span>()
                            <span class="hljs-keyword">for</span> x <span class="hljs-keyword">in</span> reconciliation_vals:
                                <span class="hljs-keyword">for</span> move_type <span class="hljs-keyword">in</span> x[<span class="hljs-string">'counterpart_move_types'</span>]:
                                    reverse_move_types.add(move_type)

                            in_reverse = (invoice.move_type <span class="hljs-keyword">in</span> (<span class="hljs-string">'in_invoice'</span>, <span class="hljs-string">'in_receipt'</span>)
                                          <span class="hljs-keyword">and</span> (reverse_move_types == {<span class="hljs-string">'in_refund'</span>} <span class="hljs-keyword">or</span> reverse_move_types == {<span class="hljs-string">'in_refund'</span>, <span class="hljs-string">'entry'</span>}))
                            out_reverse = (invoice.move_type <span class="hljs-keyword">in</span> (<span class="hljs-string">'out_invoice'</span>, <span class="hljs-string">'out_receipt'</span>)
                                           <span class="hljs-keyword">and</span> (reverse_move_types == {<span class="hljs-string">'out_refund'</span>} <span class="hljs-keyword">or</span> reverse_move_types == {<span class="hljs-string">'out_refund'</span>, <span class="hljs-string">'entry'</span>}))
                            misc_reverse = (invoice.move_type <span class="hljs-keyword">in</span> (<span class="hljs-string">'entry'</span>, <span class="hljs-string">'out_refund'</span>, <span class="hljs-string">'in_refund'</span>)
                                            <span class="hljs-keyword">and</span> reverse_move_types == {<span class="hljs-string">'entry'</span>})
                            <span class="hljs-keyword">if</span> in_reverse <span class="hljs-keyword">or</span> out_reverse <span class="hljs-keyword">or</span> misc_reverse:
                                new_pmt_state = <span class="hljs-string">'reversed'</span>

                    <span class="hljs-keyword">elif</span> reconciliation_vals:
                        new_pmt_state = <span class="hljs-string">'partial'</span>

            invoice.payment_state = new_pmt_state

<span class="hljs-meta">    @api.depends(<span class="hljs-params"><span class="hljs-string">'invoice_payment_term_id'</span>, <span class="hljs-string">'invoice_date'</span>, <span class="hljs-string">'currency_id'</span>, <span class="hljs-string">'amount_total_in_currency_signed'</span>, <span class="hljs-string">'invoice_date_due'</span></span>)</span>
    <span class="hljs-keyword">def</span> <span class="hljs-title function_">_compute_needed_terms</span>(<span class="hljs-params">self</span>):
        <span class="hljs-keyword">for</span> invoice <span class="hljs-keyword">in</span> self:
            is_draft = invoice.<span class="hljs-built_in">id</span> != invoice._origin.<span class="hljs-built_in">id</span>
            invoice.needed_terms = {}
            invoice.needed_terms_dirty = <span class="hljs-literal">True</span>
            sign = <span class="hljs-number">1</span> <span class="hljs-keyword">if</span> invoice.is_inbound(include_receipts=<span class="hljs-literal">True</span>) <span class="hljs-keyword">else</span> -<span class="hljs-number">1</span>
            <span class="hljs-keyword">if</span> invoice.is_invoice(<span class="hljs-literal">True</span>) <span class="hljs-keyword">and</span> invoice.invoice_line_ids:
                <span class="hljs-keyword">if</span> invoice.invoice_payment_term_id:
                    <span class="hljs-keyword">if</span> is_draft:
                        tax_amount_currency = <span class="hljs-number">0.0</span>
                        untaxed_amount_currency = <span class="hljs-number">0.0</span>
                        <span class="hljs-keyword">for</span> line <span class="hljs-keyword">in</span> invoice.invoice_line_ids:
                            untaxed_amount_currency += line.price_subtotal
                            <span class="hljs-keyword">for</span> tax_result <span class="hljs-keyword">in</span> (line.compute_all_tax <span class="hljs-keyword">or</span> {}).values():
                                tax_amount_currency += -sign * tax_result.get(<span class="hljs-string">'amount_currency'</span>, <span class="hljs-number">0.0</span>)
                        untaxed_amount = untaxed_amount_currency
                        tax_amount = tax_amount_currency
                    <span class="hljs-keyword">else</span>:
                        tax_amount_currency = invoice.amount_tax * sign
                        tax_amount = invoice.amount_tax_signed
                        untaxed_amount_currency = invoice.amount_untaxed * sign
                        untaxed_amount = invoice.amount_untaxed_signed
                    invoice_payment_terms = invoice.invoice_payment_term_id._compute_terms(
                        date_ref=invoice.invoice_date <span class="hljs-keyword">or</span> invoice.date <span class="hljs-keyword">or</span> fields.Date.context_today(invoice),
                        currency=invoice.currency_id,
                        tax_amount_currency=tax_amount_currency,
                        tax_amount=tax_amount,
                        untaxed_amount_currency=untaxed_amount_currency,
                        untaxed_amount=untaxed_amount,
                        company=invoice.company_id,
                        sign=sign
                    )
                    <span class="hljs-keyword">for</span> term_line <span class="hljs-keyword">in</span> invoice_payment_terms[<span class="hljs-string">'line_ids'</span>]:
                        key = frozendict({
                            <span class="hljs-string">'move_id'</span>: invoice.<span class="hljs-built_in">id</span>,
                            <span class="hljs-string">'date_maturity'</span>: fields.Date.to_date(term_line.get(<span class="hljs-string">'date'</span>)),
                            <span class="hljs-string">'discount_date'</span>: invoice_payment_terms.get(<span class="hljs-string">'discount_date'</span>),
                        })
                        values = {
                            <span class="hljs-string">'balance'</span>: term_line[<span class="hljs-string">'company_amount'</span>],
                            <span class="hljs-string">'amount_currency'</span>: term_line[<span class="hljs-string">'foreign_amount'</span>],
                            <span class="hljs-string">'discount_date'</span>: invoice_payment_terms.get(<span class="hljs-string">'discount_date'</span>),
                            <span class="hljs-string">'discount_balance'</span>: invoice_payment_terms.get(<span class="hljs-string">'discount_balance'</span>) <span class="hljs-keyword">or</span> <span class="hljs-number">0.0</span>,
                            <span class="hljs-string">'discount_amount_currency'</span>: invoice_payment_terms.get(<span class="hljs-string">'discount_amount_currency'</span>) <span class="hljs-keyword">or</span> <span class="hljs-number">0.0</span>,
                        }
                        <span class="hljs-keyword">if</span> key <span class="hljs-keyword">not</span> <span class="hljs-keyword">in</span> invoice.needed_terms:
                            invoice.needed_terms[key] = values
                        <span class="hljs-keyword">else</span>:
                            invoice.needed_terms[key][<span class="hljs-string">'balance'</span>] += values[<span class="hljs-string">'balance'</span>]
                            invoice.needed_terms[key][<span class="hljs-string">'amount_currency'</span>] += values[<span class="hljs-string">'amount_currency'</span>]
                <span class="hljs-keyword">else</span>:
                    invoice.needed_terms[frozendict({
                        <span class="hljs-string">'move_id'</span>: invoice.<span class="hljs-built_in">id</span>,
                        <span class="hljs-string">'date_maturity'</span>: fields.Date.to_date(invoice.invoice_date_due),
                        <span class="hljs-string">'discount_date'</span>: <span class="hljs-literal">False</span>,
                        <span class="hljs-string">'discount_balance'</span>: <span class="hljs-number">0.0</span>,
                        <span class="hljs-string">'discount_amount_currency'</span>: <span class="hljs-number">0.0</span>
                    })] = {
                        <span class="hljs-string">'balance'</span>: invoice.amount_total_signed,
                        <span class="hljs-string">'amount_currency'</span>: invoice.amount_total_in_currency_signed,
                    }

    <span class="hljs-keyword">def</span> <span class="hljs-title function_">_compute_payments_widget_to_reconcile_info</span>(<span class="hljs-params">self</span>):
        <span class="hljs-keyword">for</span> move <span class="hljs-keyword">in</span> self:
            move.invoice_outstanding_credits_debits_widget = <span class="hljs-literal">False</span>
            move.invoice_has_outstanding = <span class="hljs-literal">False</span>

            <span class="hljs-keyword">if</span> move.state != <span class="hljs-string">'posted'</span> \
                    <span class="hljs-keyword">or</span> move.payment_state <span class="hljs-keyword">not</span> <span class="hljs-keyword">in</span> (<span class="hljs-string">'not_paid'</span>, <span class="hljs-string">'partial'</span>) \
                    <span class="hljs-keyword">or</span> <span class="hljs-keyword">not</span> move.is_invoice(include_receipts=<span class="hljs-literal">True</span>):
                <span class="hljs-keyword">continue</span>

            pay_term_lines = move.line_ids\
                .filtered(<span class="hljs-keyword">lambda</span> line: line.account_id.account_type <span class="hljs-keyword">in</span> (<span class="hljs-string">'asset_receivable'</span>, <span class="hljs-string">'liability_payable'</span>))

            domain = [
                (<span class="hljs-string">'account_id'</span>, <span class="hljs-string">'in'</span>, pay_term_lines.account_id.ids),
                (<span class="hljs-string">'parent_state'</span>, <span class="hljs-string">'='</span>, <span class="hljs-string">'posted'</span>),
                (<span class="hljs-string">'partner_id'</span>, <span class="hljs-string">'='</span>, move.commercial_partner_id.<span class="hljs-built_in">id</span>),
                (<span class="hljs-string">'reconciled'</span>, <span class="hljs-string">'='</span>, <span class="hljs-literal">False</span>),
                <span class="hljs-string">'|'</span>, (<span class="hljs-string">'amount_residual'</span>, <span class="hljs-string">'!='</span>, <span class="hljs-number">0.0</span>), (<span class="hljs-string">'amount_residual_currency'</span>, <span class="hljs-string">'!='</span>, <span class="hljs-number">0.0</span>),
            ]

            payments_widget_vals = {<span class="hljs-string">'outstanding'</span>: <span class="hljs-literal">True</span>, <span class="hljs-string">'content'</span>: [], <span class="hljs-string">'move_id'</span>: move.<span class="hljs-built_in">id</span>}

            <span class="hljs-keyword">if</span> move.is_inbound():
                domain.append((<span class="hljs-string">'balance'</span>, <span class="hljs-string">'&lt;'</span>, <span class="hljs-number">0.0</span>))
                payments_widget_vals[<span class="hljs-string">'title'</span>] = _(<span class="hljs-string">'Outstanding credits'</span>)
            <span class="hljs-keyword">else</span>:
                domain.append((<span class="hljs-string">'balance'</span>, <span class="hljs-string">'&gt;'</span>, <span class="hljs-number">0.0</span>))
                payments_widget_vals[<span class="hljs-string">'title'</span>] = _(<span class="hljs-string">'Outstanding debits'</span>)

            <span class="hljs-keyword">for</span> line <span class="hljs-keyword">in</span> self.env[<span class="hljs-string">'account.move.line'</span>].search(domain):

                <span class="hljs-keyword">if</span> line.currency_id == move.currency_id:
                    <span class="hljs-comment"># Same foreign currency.</span>
                    amount = <span class="hljs-built_in">abs</span>(line.amount_residual_currency)
                <span class="hljs-keyword">else</span>:
                    <span class="hljs-comment"># Different foreign currencies.</span>
                    amount = line.company_currency_id._convert(
                        <span class="hljs-built_in">abs</span>(line.amount_residual),
                        move.currency_id,
                        move.company_id,
                        line.date,
                    )

                <span class="hljs-keyword">if</span> move.currency_id.is_zero(amount):
                    <span class="hljs-keyword">continue</span>

                payments_widget_vals[<span class="hljs-string">'content'</span>].append({
                    <span class="hljs-string">'journal_name'</span>: line.ref <span class="hljs-keyword">or</span> line.move_id.name,
                    <span class="hljs-string">'amount'</span>: amount,
                    <span class="hljs-string">'currency_id'</span>: move.currency_id.<span class="hljs-built_in">id</span>,
                    <span class="hljs-string">'id'</span>: line.<span class="hljs-built_in">id</span>,
                    <span class="hljs-string">'move_id'</span>: line.move_id.<span class="hljs-built_in">id</span>,
                    <span class="hljs-string">'date'</span>: fields.Date.to_string(line.date),
                    <span class="hljs-string">'account_payment_id'</span>: line.payment_id.<span class="hljs-built_in">id</span>,
                })

            <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> payments_widget_vals[<span class="hljs-string">'content'</span>]:
                <span class="hljs-keyword">continue</span>

            move.invoice_outstanding_credits_debits_widget = payments_widget_vals
            move.invoice_has_outstanding = <span class="hljs-literal">True</span>

<span class="hljs-meta">    @api.depends(<span class="hljs-params"><span class="hljs-string">'move_type'</span>, <span class="hljs-string">'line_ids.amount_residual'</span></span>)</span>
    <span class="hljs-keyword">def</span> <span class="hljs-title function_">_compute_payments_widget_reconciled_info</span>(<span class="hljs-params">self</span>):
        <span class="hljs-keyword">for</span> move <span class="hljs-keyword">in</span> self:
            payments_widget_vals = {<span class="hljs-string">'title'</span>: _(<span class="hljs-string">'Less Payment'</span>), <span class="hljs-string">'outstanding'</span>: <span class="hljs-literal">False</span>, <span class="hljs-string">'content'</span>: []}

            <span class="hljs-keyword">if</span> move.state == <span class="hljs-string">'posted'</span> <span class="hljs-keyword">and</span> move.is_invoice(include_receipts=<span class="hljs-literal">True</span>):
                reconciled_vals = []
                reconciled_partials = move.sudo()._get_all_reconciled_invoice_partials()
                <span class="hljs-keyword">for</span> reconciled_partial <span class="hljs-keyword">in</span> reconciled_partials:
                    counterpart_line = reconciled_partial[<span class="hljs-string">'aml'</span>]
                    <span class="hljs-keyword">if</span> counterpart_line.move_id.ref:
                        reconciliation_ref = <span class="hljs-string">'%s (%s)'</span> % (counterpart_line.move_id.name, counterpart_line.move_id.ref)
                    <span class="hljs-keyword">else</span>:
                        reconciliation_ref = counterpart_line.move_id.name
                    <span class="hljs-keyword">if</span> counterpart_line.amount_currency <span class="hljs-keyword">and</span> counterpart_line.currency_id != counterpart_line.company_id.currency_id:
                        foreign_currency = counterpart_line.currency_id
                    <span class="hljs-keyword">else</span>:
                        foreign_currency = <span class="hljs-literal">False</span>

                    reconciled_vals.append({
                        <span class="hljs-string">'name'</span>: counterpart_line.name,
                        <span class="hljs-string">'journal_name'</span>: counterpart_line.journal_id.name,
                        <span class="hljs-string">'company_name'</span>: counterpart_line.journal_id.company_id.name <span class="hljs-keyword">if</span> counterpart_line.journal_id.company_id != move.company_id <span class="hljs-keyword">else</span> <span class="hljs-literal">False</span>,
                        <span class="hljs-string">'amount'</span>: reconciled_partial[<span class="hljs-string">'amount'</span>],
                        <span class="hljs-string">'currency_id'</span>: move.company_id.currency_id.<span class="hljs-built_in">id</span> <span class="hljs-keyword">if</span> reconciled_partial[<span class="hljs-string">'is_exchange'</span>] <span class="hljs-keyword">else</span> reconciled_partial[<span class="hljs-string">'currency'</span>].<span class="hljs-built_in">id</span>,
                        <span class="hljs-string">'date'</span>: counterpart_line.date,
                        <span class="hljs-string">'partial_id'</span>: reconciled_partial[<span class="hljs-string">'partial_id'</span>],
                        <span class="hljs-string">'account_payment_id'</span>: counterpart_line.payment_id.<span class="hljs-built_in">id</span>,
                        <span class="hljs-string">'payment_method_name'</span>: counterpart_line.payment_id.payment_method_line_id.name,
                        <span class="hljs-string">'move_id'</span>: counterpart_line.move_id.<span class="hljs-built_in">id</span>,
                        <span class="hljs-string">'ref'</span>: reconciliation_ref,
                        <span class="hljs-comment"># these are necessary for the views to change depending on the values</span>
                        <span class="hljs-string">'is_exchange'</span>: reconciled_partial[<span class="hljs-string">'is_exchange'</span>],
                        <span class="hljs-string">'amount_company_currency'</span>: formatLang(self.env, <span class="hljs-built_in">abs</span>(counterpart_line.balance), currency_obj=counterpart_line.company_id.currency_id),
                        <span class="hljs-string">'amount_foreign_currency'</span>: foreign_currency <span class="hljs-keyword">and</span> formatLang(self.env, <span class="hljs-built_in">abs</span>(counterpart_line.amount_currency), currency_obj=foreign_currency)
                    })
                payments_widget_vals[<span class="hljs-string">'content'</span>] = reconciled_vals

            <span class="hljs-keyword">if</span> payments_widget_vals[<span class="hljs-string">'content'</span>]:
                move.invoice_payments_widget = payments_widget_vals
            <span class="hljs-keyword">else</span>:
                move.invoice_payments_widget = <span class="hljs-literal">False</span>

<span class="hljs-meta">    @api.depends_context(<span class="hljs-params"><span class="hljs-string">'lang'</span></span>)</span>
<span class="hljs-meta">    @api.depends(<span class="hljs-params">
        <span class="hljs-string">'invoice_line_ids.currency_rate'</span>,
        <span class="hljs-string">'invoice_line_ids.tax_base_amount'</span>,
        <span class="hljs-string">'invoice_line_ids.tax_line_id'</span>,
        <span class="hljs-string">'invoice_line_ids.price_total'</span>,
        <span class="hljs-string">'invoice_line_ids.price_subtotal'</span>,
        <span class="hljs-string">'invoice_payment_term_id'</span>,
        <span class="hljs-string">'partner_id'</span>,
        <span class="hljs-string">'currency_id'</span>,
    </span>)</span>
    <span class="hljs-keyword">def</span> <span class="hljs-title function_">_compute_tax_totals</span>(<span class="hljs-params">self</span>):
        <span class="hljs-string">""" Computed field used for custom widget's rendering.
            Only set on invoices.
        """</span>
        <span class="hljs-keyword">for</span> move <span class="hljs-keyword">in</span> self:
            <span class="hljs-keyword">if</span> move.is_invoice(include_receipts=<span class="hljs-literal">True</span>):
                base_lines = move.invoice_line_ids.filtered(<span class="hljs-keyword">lambda</span> line: line.display_type == <span class="hljs-string">'product'</span>)
                base_line_values_list = [line._convert_to_tax_base_line_dict() <span class="hljs-keyword">for</span> line <span class="hljs-keyword">in</span> base_lines]
                sign = move.direction_sign
                <span class="hljs-keyword">if</span> move.<span class="hljs-built_in">id</span>:
                    <span class="hljs-comment"># The invoice is stored so we can add the early payment discount lines directly to reduce the</span>
                    <span class="hljs-comment"># tax amount without touching the untaxed amount.</span>
                    base_line_values_list += [
                        {
                            **line._convert_to_tax_base_line_dict(),
                            <span class="hljs-string">'handle_price_include'</span>: <span class="hljs-literal">False</span>,
                            <span class="hljs-string">'quantity'</span>: <span class="hljs-number">1.0</span>,
                            <span class="hljs-string">'price_unit'</span>: sign * line.amount_currency,
                        }
                        <span class="hljs-keyword">for</span> line <span class="hljs-keyword">in</span> move.line_ids.filtered(<span class="hljs-keyword">lambda</span> line: line.display_type == <span class="hljs-string">'epd'</span>)
                    ]

                kwargs = {
                    <span class="hljs-string">'base_lines'</span>: base_line_values_list,
                    <span class="hljs-string">'currency'</span>: move.currency_id <span class="hljs-keyword">or</span> move.journal_id.currency_id <span class="hljs-keyword">or</span> move.company_id.currency_id,
                }

                <span class="hljs-keyword">if</span> move.<span class="hljs-built_in">id</span>:
                    kwargs[<span class="hljs-string">'tax_lines'</span>] = [
                        line._convert_to_tax_line_dict()
                        <span class="hljs-keyword">for</span> line <span class="hljs-keyword">in</span> move.line_ids.filtered(<span class="hljs-keyword">lambda</span> line: line.display_type == <span class="hljs-string">'tax'</span>)
                    ]
                <span class="hljs-keyword">else</span>:
                    <span class="hljs-comment"># In case the invoice isn't yet stored, the early payment discount lines are not there. Then,</span>
                    <span class="hljs-comment"># we need to simulate them.</span>
                    epd_aggregated_values = {}
                    <span class="hljs-keyword">for</span> base_line <span class="hljs-keyword">in</span> base_lines:
                        <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> base_line.epd_needed:
                            <span class="hljs-keyword">continue</span>
                        <span class="hljs-keyword">for</span> grouping_dict, values <span class="hljs-keyword">in</span> base_line.epd_needed.items():
                            epd_values = epd_aggregated_values.setdefault(grouping_dict, {<span class="hljs-string">'price_subtotal'</span>: <span class="hljs-number">0.0</span>})
                            epd_values[<span class="hljs-string">'price_subtotal'</span>] += values[<span class="hljs-string">'price_subtotal'</span>]

                    <span class="hljs-keyword">for</span> grouping_dict, values <span class="hljs-keyword">in</span> epd_aggregated_values.items():
                        taxes = <span class="hljs-literal">None</span>
                        <span class="hljs-keyword">if</span> grouping_dict.get(<span class="hljs-string">'tax_ids'</span>):
                            taxes = self.env[<span class="hljs-string">'account.tax'</span>].browse(grouping_dict[<span class="hljs-string">'tax_ids'</span>][<span class="hljs-number">0</span>][<span class="hljs-number">2</span>])

                        kwargs[<span class="hljs-string">'base_lines'</span>].append(self.env[<span class="hljs-string">'account.tax'</span>]._convert_to_tax_base_line_dict(
                            <span class="hljs-literal">None</span>,
                            partner=move.partner_id,
                            currency=move.currency_id,
                            taxes=taxes,
                            price_unit=values[<span class="hljs-string">'price_subtotal'</span>],
                            quantity=<span class="hljs-number">1.0</span>,
                            account=self.env[<span class="hljs-string">'account.account'</span>].browse(grouping_dict[<span class="hljs-string">'account_id'</span>]),
                            analytic_distribution=values.get(<span class="hljs-string">'analytic_distribution'</span>),
                            price_subtotal=values[<span class="hljs-string">'price_subtotal'</span>],
                            is_refund=move.move_type <span class="hljs-keyword">in</span> (<span class="hljs-string">'out_refund'</span>, <span class="hljs-string">'in_refund'</span>),
                            handle_price_include=<span class="hljs-literal">False</span>,
                        ))
                kwargs[<span class="hljs-string">'is_company_currency_requested'</span>] = move.currency_id != move.company_id.currency_id
                move.tax_totals = self.env[<span class="hljs-string">'account.tax'</span>]._prepare_tax_totals(**kwargs)
                <span class="hljs-keyword">if</span> move.invoice_cash_rounding_id:
                    rounding_amount = move.invoice_cash_rounding_id.compute_difference(move.currency_id, move.tax_totals[<span class="hljs-string">'amount_total'</span>])
                    totals = move.tax_totals
                    totals[<span class="hljs-string">'display_rounding'</span>] = <span class="hljs-literal">True</span>
                    <span class="hljs-keyword">if</span> rounding_amount:
                        <span class="hljs-keyword">if</span> move.invoice_cash_rounding_id.strategy == <span class="hljs-string">'add_invoice_line'</span>:
                            totals[<span class="hljs-string">'rounding_amount'</span>] = rounding_amount
                            totals[<span class="hljs-string">'formatted_rounding_amount'</span>] = formatLang(self.env, totals[<span class="hljs-string">'rounding_amount'</span>], currency_obj=move.currency_id)
                        <span class="hljs-keyword">elif</span> move.invoice_cash_rounding_id.strategy == <span class="hljs-string">'biggest_tax'</span>:
                            <span class="hljs-keyword">if</span> totals[<span class="hljs-string">'subtotals_order'</span>]:
                                max_tax_group = <span class="hljs-built_in">max</span>((
                                    tax_group
                                    <span class="hljs-keyword">for</span> tax_groups <span class="hljs-keyword">in</span> totals[<span class="hljs-string">'groups_by_subtotal'</span>].values()
                                    <span class="hljs-keyword">for</span> tax_group <span class="hljs-keyword">in</span> tax_groups
                                ), key=<span class="hljs-keyword">lambda</span> tax_group: tax_group[<span class="hljs-string">'tax_group_amount'</span>])
                                max_tax_group[<span class="hljs-string">'tax_group_amount'</span>] += rounding_amount
                                max_tax_group[<span class="hljs-string">'formatted_tax_group_amount'</span>] = formatLang(self.env, max_tax_group[<span class="hljs-string">'tax_group_amount'</span>], currency_obj=move.currency_id)
                        totals[<span class="hljs-string">'amount_total'</span>] += rounding_amount
                        totals[<span class="hljs-string">'formatted_amount_total'</span>] = formatLang(self.env, totals[<span class="hljs-string">'amount_total'</span>], currency_obj=move.currency_id)
            <span class="hljs-keyword">else</span>:
                <span class="hljs-comment"># Non-invoice moves don't support that field (because of multicurrency: all lines of the invoice share the same currency)</span>
                move.tax_totals = <span class="hljs-literal">None</span>

<span class="hljs-meta">    @api.depends(<span class="hljs-params"><span class="hljs-string">'show_payment_term_details'</span></span>)</span>
    <span class="hljs-keyword">def</span> <span class="hljs-title function_">_compute_payment_term_details</span>(<span class="hljs-params">self</span>):
        <span class="hljs-string">'''
        Returns an [] containing the payment term's information to be displayed on the invoice's PDF.
        '''</span>
        <span class="hljs-keyword">for</span> invoice <span class="hljs-keyword">in</span> self:
            invoice.payment_term_details = <span class="hljs-literal">False</span>
            <span class="hljs-keyword">if</span> invoice.show_payment_term_details:
                sign = <span class="hljs-number">1</span> <span class="hljs-keyword">if</span> invoice.is_inbound(include_receipts=<span class="hljs-literal">True</span>) <span class="hljs-keyword">else</span> -<span class="hljs-number">1</span>
                payment_term_details = []
                <span class="hljs-keyword">for</span> line <span class="hljs-keyword">in</span> invoice.line_ids.filtered(<span class="hljs-keyword">lambda</span> l: l.display_type == <span class="hljs-string">'payment_term'</span>).<span class="hljs-built_in">sorted</span>(<span class="hljs-string">'date_maturity'</span>):
                    payment_term_details.append({
                        <span class="hljs-string">'date'</span>: format_date(self.env, line.date_maturity),
                        <span class="hljs-string">'amount'</span>: sign * line.amount_currency,
                    })
                invoice.payment_term_details = payment_term_details

<span class="hljs-meta">    @api.depends(<span class="hljs-params"><span class="hljs-string">'move_type'</span>, <span class="hljs-string">'payment_state'</span>, <span class="hljs-string">'invoice_payment_term_id'</span></span>)</span>
    <span class="hljs-keyword">def</span> <span class="hljs-title function_">_compute_show_payment_term_details</span>(<span class="hljs-params">self</span>):
        <span class="hljs-string">'''
        Determines :
        - whether or not an additional table should be added at the end of the invoice to display the various
        - whether or not there is an early pay discount in this invoice that should be displayed
        '''</span>
        <span class="hljs-keyword">for</span> invoice <span class="hljs-keyword">in</span> self:
            <span class="hljs-keyword">if</span> invoice.move_type <span class="hljs-keyword">in</span> (<span class="hljs-string">'out_invoice'</span>, <span class="hljs-string">'out_receipt'</span>, <span class="hljs-string">'in_invoice'</span>, <span class="hljs-string">'in_receipt'</span>) <span class="hljs-keyword">and</span> invoice.payment_state <span class="hljs-keyword">in</span> (<span class="hljs-string">'not_paid'</span>, <span class="hljs-string">'partial'</span>):
                payment_term_lines = invoice.line_ids.filtered(<span class="hljs-keyword">lambda</span> l: l.display_type == <span class="hljs-string">'payment_term'</span>)
                invoice.show_discount_details = invoice.invoice_payment_term_id.early_discount
                invoice.show_payment_term_details = <span class="hljs-built_in">len</span>(payment_term_lines) &gt; <span class="hljs-number">1</span> <span class="hljs-keyword">or</span> invoice.show_discount_details
            <span class="hljs-keyword">else</span>:
                invoice.show_discount_details = <span class="hljs-literal">False</span>
                invoice.show_payment_term_details = <span class="hljs-literal">False</span>

    <span class="hljs-keyword">def</span> <span class="hljs-title function_">_need_cancel_request</span>(<span class="hljs-params">self</span>):
        <span class="hljs-string">""" Hook allowing a localization to prevent the user to reset draft an invoice that has been already sent
        to the government and thus, must remain untouched except if its cancellation is approved.

        :return: True if the cancel button is displayed instead of draft button, False otherwise.
        """</span>
        self.ensure_one()
        <span class="hljs-keyword">return</span> <span class="hljs-literal">False</span>

<span class="hljs-meta">    @api.depends(<span class="hljs-params"><span class="hljs-string">'country_code'</span></span>)</span>
    <span class="hljs-keyword">def</span> <span class="hljs-title function_">_compute_need_cancel_request</span>(<span class="hljs-params">self</span>):
        <span class="hljs-keyword">for</span> move <span class="hljs-keyword">in</span> self:
            move.need_cancel_request = move._need_cancel_request()

<span class="hljs-meta">    @api.depends(<span class="hljs-params"><span class="hljs-string">'partner_id'</span>, <span class="hljs-string">'invoice_source_email'</span>, <span class="hljs-string">'partner_id.display_name'</span></span>)</span>
    <span class="hljs-keyword">def</span> <span class="hljs-title function_">_compute_invoice_partner_display_info</span>(<span class="hljs-params">self</span>):
        <span class="hljs-keyword">for</span> move <span class="hljs-keyword">in</span> self:
            vendor_display_name = move.partner_id.display_name
            <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> vendor_display_name:
                <span class="hljs-keyword">if</span> move.invoice_source_email:
                    vendor_display_name = _(<span class="hljs-string">'@From: %(email)s'</span>, email=move.invoice_source_email)
                <span class="hljs-keyword">else</span>:
                    vendor_display_name = _(<span class="hljs-string">'#Created by: %s'</span>, move.sudo().create_uid.name <span class="hljs-keyword">or</span> self.env.user.name)
            move.invoice_partner_display_name = vendor_display_name

<span class="hljs-meta">    @api.depends(<span class="hljs-params"><span class="hljs-string">'move_type'</span></span>)</span>
    <span class="hljs-keyword">def</span> <span class="hljs-title function_">_compute_invoice_filter_type_domain</span>(<span class="hljs-params">self</span>):
        <span class="hljs-keyword">for</span> move <span class="hljs-keyword">in</span> self:
            <span class="hljs-keyword">if</span> move.is_sale_document(include_receipts=<span class="hljs-literal">True</span>):
                move.invoice_filter_type_domain = <span class="hljs-string">'sale'</span>
            <span class="hljs-keyword">elif</span> move.is_purchase_document(include_receipts=<span class="hljs-literal">True</span>):
                move.invoice_filter_type_domain = <span class="hljs-string">'purchase'</span>
            <span class="hljs-keyword">else</span>:
                move.invoice_filter_type_domain = <span class="hljs-literal">False</span>

<span class="hljs-meta">    @api.depends(<span class="hljs-params"><span class="hljs-string">'commercial_partner_id'</span></span>)</span>
    <span class="hljs-keyword">def</span> <span class="hljs-title function_">_compute_bank_partner_id</span>(<span class="hljs-params">self</span>):
        <span class="hljs-keyword">for</span> move <span class="hljs-keyword">in</span> self:
            <span class="hljs-keyword">if</span> move.is_inbound():
                move.bank_partner_id = move.company_id.partner_id
            <span class="hljs-keyword">else</span>:
                move.bank_partner_id = move.commercial_partner_id

<span class="hljs-meta">    @api.depends(<span class="hljs-params"><span class="hljs-string">'date'</span>, <span class="hljs-string">'line_ids.debit'</span>, <span class="hljs-string">'line_ids.credit'</span>, <span class="hljs-string">'line_ids.tax_line_id'</span>, <span class="hljs-string">'line_ids.tax_ids'</span>, <span class="hljs-string">'line_ids.tax_tag_ids'</span>,
                 <span class="hljs-string">'invoice_line_ids.debit'</span>, <span class="hljs-string">'invoice_line_ids.credit'</span>, <span class="hljs-string">'invoice_line_ids.tax_line_id'</span>, <span class="hljs-string">'invoice_line_ids.tax_ids'</span>, <span class="hljs-string">'invoice_line_ids.tax_tag_ids'</span></span>)</span>
    <span class="hljs-keyword">def</span> <span class="hljs-title function_">_compute_tax_lock_date_message</span>(<span class="hljs-params">self</span>):
        <span class="hljs-keyword">for</span> move <span class="hljs-keyword">in</span> self:
            accounting_date = move.date <span class="hljs-keyword">or</span> fields.Date.context_today(move)
            affects_tax_report = move._affect_tax_report()
            move.tax_lock_date_message = move._get_lock_date_message(accounting_date, affects_tax_report)

<span class="hljs-meta">    @api.depends(<span class="hljs-params"><span class="hljs-string">'currency_id'</span></span>)</span>
    <span class="hljs-keyword">def</span> <span class="hljs-title function_">_compute_display_inactive_currency_warning</span>(<span class="hljs-params">self</span>):
        <span class="hljs-keyword">for</span> move <span class="hljs-keyword">in</span> self.with_context(active_test=<span class="hljs-literal">False</span>):
            move.display_inactive_currency_warning = move.currency_id <span class="hljs-keyword">and</span> <span class="hljs-keyword">not</span> move.currency_id.active

<span class="hljs-meta">    @api.depends(<span class="hljs-params"><span class="hljs-string">'company_id.account_fiscal_country_id'</span>, <span class="hljs-string">'fiscal_position_id'</span>, <span class="hljs-string">'fiscal_position_id.country_id'</span>, <span class="hljs-string">'fiscal_position_id.foreign_vat'</span></span>)</span>
    <span class="hljs-keyword">def</span> <span class="hljs-title function_">_compute_tax_country_id</span>(<span class="hljs-params">self</span>):
        foreign_vat_records = self.filtered(<span class="hljs-keyword">lambda</span> r: r.fiscal_position_id.foreign_vat)
        <span class="hljs-keyword">for</span> fiscal_position_id, record_group <span class="hljs-keyword">in</span> groupby(foreign_vat_records, key=<span class="hljs-keyword">lambda</span> r: r.fiscal_position_id):
            self.env[<span class="hljs-string">'account.move'</span>].concat(*record_group).tax_country_id = fiscal_position_id.country_id
        <span class="hljs-keyword">for</span> company_id, record_group <span class="hljs-keyword">in</span> groupby((self-foreign_vat_records), key=<span class="hljs-keyword">lambda</span> r: r.company_id):
            self.env[<span class="hljs-string">'account.move'</span>].concat(*record_group).tax_country_id = company_id.account_fiscal_country_id

<span class="hljs-meta">    @api.depends(<span class="hljs-params"><span class="hljs-string">'tax_country_id'</span></span>)</span>
    <span class="hljs-keyword">def</span> <span class="hljs-title function_">_compute_tax_country_code</span>(<span class="hljs-params">self</span>):
        <span class="hljs-keyword">for</span> record <span class="hljs-keyword">in</span> self:
            record.tax_country_code = record.tax_country_id.code

<span class="hljs-meta">    @api.depends(<span class="hljs-params"><span class="hljs-string">'line_ids'</span></span>)</span>
    <span class="hljs-keyword">def</span> <span class="hljs-title function_">_compute_has_reconciled_entries</span>(<span class="hljs-params">self</span>):
        <span class="hljs-keyword">for</span> move <span class="hljs-keyword">in</span> self:
            move.has_reconciled_entries = <span class="hljs-built_in">len</span>(move.line_ids._reconciled_lines()) &gt; <span class="hljs-number">1</span>

<span class="hljs-meta">    @api.depends(<span class="hljs-params"><span class="hljs-string">'restrict_mode_hash_table'</span>, <span class="hljs-string">'state'</span></span>)</span>
    <span class="hljs-keyword">def</span> <span class="hljs-title function_">_compute_show_reset_to_draft_button</span>(<span class="hljs-params">self</span>):
        <span class="hljs-keyword">for</span> move <span class="hljs-keyword">in</span> self:
            move.show_reset_to_draft_button = (
                <span class="hljs-keyword">not</span> move.restrict_mode_hash_table \
                <span class="hljs-keyword">and</span> (move.state == <span class="hljs-string">'cancel'</span> <span class="hljs-keyword">or</span> (move.state == <span class="hljs-string">'posted'</span> <span class="hljs-keyword">and</span> <span class="hljs-keyword">not</span> move.need_cancel_request))
            )

    <span class="hljs-comment"># EXTENDS portal portal.mixin</span>
    <span class="hljs-keyword">def</span> <span class="hljs-title function_">_compute_access_url</span>(<span class="hljs-params">self</span>):
        <span class="hljs-built_in">super</span>()._compute_access_url()
        <span class="hljs-keyword">for</span> move <span class="hljs-keyword">in</span> self.filtered(<span class="hljs-keyword">lambda</span> move: move.is_invoice()):
            move.access_url = <span class="hljs-string">'/my/invoices/%s'</span> % (move.<span class="hljs-built_in">id</span>)

<span class="hljs-meta">    @api.depends(<span class="hljs-params"><span class="hljs-string">'move_type'</span>, <span class="hljs-string">'partner_id'</span>, <span class="hljs-string">'company_id'</span></span>)</span>
    <span class="hljs-keyword">def</span> <span class="hljs-title function_">_compute_narration</span>(<span class="hljs-params">self</span>):
        use_invoice_terms = self.env[<span class="hljs-string">'ir.config_parameter'</span>].sudo().get_param(<span class="hljs-string">'account.use_invoice_terms'</span>)
        <span class="hljs-keyword">for</span> move <span class="hljs-keyword">in</span> self:
            <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> move.is_sale_document(include_receipts=<span class="hljs-literal">True</span>):
                <span class="hljs-keyword">continue</span>
            <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> use_invoice_terms:
                move.narration = <span class="hljs-literal">False</span>
            <span class="hljs-keyword">else</span>:
                lang = move.partner_id.lang <span class="hljs-keyword">or</span> self.env.user.lang
                <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> move.company_id.terms_type == <span class="hljs-string">'html'</span>:
                    narration = move.company_id.with_context(lang=lang).invoice_terms <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> is_html_empty(move.company_id.invoice_terms) <span class="hljs-keyword">else</span> <span class="hljs-string">''</span>
                <span class="hljs-keyword">else</span>:
                    baseurl = self.env.company.get_base_url() + <span class="hljs-string">'/terms'</span>
                    context = {<span class="hljs-string">'lang'</span>: lang}
                    narration = _(<span class="hljs-string">'Terms &amp; Conditions: %s'</span>, baseurl)
                    <span class="hljs-keyword">del</span> context
                move.narration = narration <span class="hljs-keyword">or</span> <span class="hljs-literal">False</span>

<span class="hljs-meta">    @api.depends(<span class="hljs-params"><span class="hljs-string">'company_id'</span>, <span class="hljs-string">'partner_id'</span>, <span class="hljs-string">'tax_totals'</span>, <span class="hljs-string">'currency_id'</span></span>)</span>
    <span class="hljs-keyword">def</span> <span class="hljs-title function_">_compute_partner_credit_warning</span>(<span class="hljs-params">self</span>):
        <span class="hljs-keyword">for</span> move <span class="hljs-keyword">in</span> self:
            move.with_company(move.company_id)
            move.partner_credit_warning = <span class="hljs-string">''</span>
            show_warning = move.state == <span class="hljs-string">'draft'</span> <span class="hljs-keyword">and</span> \
                           move.move_type == <span class="hljs-string">'out_invoice'</span> <span class="hljs-keyword">and</span> \
                           move.company_id.account_use_credit_limit
            <span class="hljs-keyword">if</span> show_warning:
                move.partner_credit_warning = self._build_credit_warning_message(
                    move,
                    current_amount=move.tax_totals[<span class="hljs-string">'amount_total'</span>],
                    exclude_current=<span class="hljs-literal">True</span>,
                )

<span class="hljs-meta">    @api.depends(<span class="hljs-params"><span class="hljs-string">'partner_id'</span></span>)</span>
    <span class="hljs-keyword">def</span> <span class="hljs-title function_">_compute_partner_credit</span>(<span class="hljs-params">self</span>):
        <span class="hljs-keyword">for</span> move <span class="hljs-keyword">in</span> self:
            move.partner_credit = move.partner_id.commercial_partner_id.credit

    <span class="hljs-keyword">def</span> <span class="hljs-title function_">_build_credit_warning_message</span>(<span class="hljs-params">self, record, current_amount=<span class="hljs-number">0.0</span>, exclude_current=<span class="hljs-literal">False</span></span>):
        <span class="hljs-string">""" Build the warning message that will be displayed in a yellow banner on top of the current record
            if the partner exceeds a credit limit (set on the company or the partner itself).
            :param record:                  The record where the warning will appear (Invoice, Sales Order...).
            :param current_amount (float):  The partner's outstanding credit amount from the current document.
            :param exclude_current (bool):  Whether to exclude `current_amount` from the credit to invoice.
            :return (str):                  The warning message to be showed.
        """</span>
        partner_id = record.partner_id.commercial_partner_id
        credit_to_invoice = <span class="hljs-built_in">max</span>(partner_id.credit_to_invoice - (current_amount <span class="hljs-keyword">if</span> exclude_current <span class="hljs-keyword">else</span> <span class="hljs-number">0</span>), <span class="hljs-number">0</span>)
        total_credit = partner_id.credit + credit_to_invoice + current_amount
        <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> partner_id.credit_limit <span class="hljs-keyword">or</span> total_credit &lt;= partner_id.credit_limit:
            <span class="hljs-keyword">return</span> <span class="hljs-string">''</span>
        msg = _(
            <span class="hljs-string">'%(partner_name)s has reached its credit limit of: %(credit_limit)s'</span>,
            partner_name=partner_id.name,
            credit_limit=formatLang(self.env, partner_id.credit_limit, currency_obj=record.company_id.currency_id)
        )
        total_credit_formatted = formatLang(self.env, total_credit, currency_obj=record.company_id.currency_id)
        <span class="hljs-keyword">if</span> credit_to_invoice &gt; <span class="hljs-number">0</span> <span class="hljs-keyword">and</span> current_amount &gt; <span class="hljs-number">0</span>:
            <span class="hljs-keyword">return</span> msg + <span class="hljs-string">'\n'</span> + _(
                <span class="hljs-string">'Total amount due (including sales orders and this document): %(total_credit)s'</span>,
                total_credit=total_credit_formatted
            )
        <span class="hljs-keyword">elif</span> credit_to_invoice &gt; <span class="hljs-number">0</span>:
            <span class="hljs-keyword">return</span> msg + <span class="hljs-string">'\n'</span> + _(
                <span class="hljs-string">'Total amount due (including sales orders): %(total_credit)s'</span>,
                total_credit=total_credit_formatted
            )
        <span class="hljs-keyword">elif</span> current_amount &gt; <span class="hljs-number">0</span>:
            <span class="hljs-keyword">return</span> msg + <span class="hljs-string">'\n'</span> + _(
                <span class="hljs-string">'Total amount due (including this document): %(total_credit)s'</span>,
                total_credit=total_credit_formatted
            )
        <span class="hljs-keyword">else</span>:
            <span class="hljs-keyword">return</span> msg + <span class="hljs-string">'\n'</span> + _(
                <span class="hljs-string">'Total amount due: %(total_credit)s'</span>,
                total_credit=total_credit_formatted
            )

<span class="hljs-meta">    @api.depends(<span class="hljs-params"><span class="hljs-string">'journal_id.type'</span>, <span class="hljs-string">'company_id'</span></span>)</span>
    <span class="hljs-keyword">def</span> <span class="hljs-title function_">_compute_quick_edit_mode</span>(<span class="hljs-params">self</span>):
        <span class="hljs-keyword">for</span> move <span class="hljs-keyword">in</span> self:
            quick_edit_mode = move.company_id.quick_edit_mode
            <span class="hljs-keyword">if</span> move.journal_id.<span class="hljs-built_in">type</span> == <span class="hljs-string">'sale'</span>:
                move.quick_edit_mode = quick_edit_mode <span class="hljs-keyword">in</span> (<span class="hljs-string">'out_invoices'</span>, <span class="hljs-string">'out_and_in_invoices'</span>)
            <span class="hljs-keyword">elif</span> move.journal_id.<span class="hljs-built_in">type</span> == <span class="hljs-string">'purchase'</span>:
                move.quick_edit_mode = quick_edit_mode <span class="hljs-keyword">in</span> (<span class="hljs-string">'in_invoices'</span>, <span class="hljs-string">'out_and_in_invoices'</span>)
            <span class="hljs-keyword">else</span>:
                move.quick_edit_mode = <span class="hljs-literal">False</span>

<span class="hljs-meta">    @api.depends(<span class="hljs-params"><span class="hljs-string">'quick_edit_total_amount'</span>, <span class="hljs-string">'invoice_line_ids.price_total'</span>, <span class="hljs-string">'tax_totals'</span></span>)</span>
    <span class="hljs-keyword">def</span> <span class="hljs-title function_">_compute_quick_encoding_vals</span>(<span class="hljs-params">self</span>):
        <span class="hljs-keyword">for</span> move <span class="hljs-keyword">in</span> self:
            move.quick_encoding_vals = move._get_quick_edit_suggestions()

<span class="hljs-meta">    @api.depends(<span class="hljs-params"><span class="hljs-string">'ref'</span>, <span class="hljs-string">'move_type'</span>, <span class="hljs-string">'partner_id'</span>, <span class="hljs-string">'invoice_date'</span></span>)</span>
    <span class="hljs-keyword">def</span> <span class="hljs-title function_">_compute_duplicated_ref_ids</span>(<span class="hljs-params">self</span>):
        move_to_duplicate_move = self._fetch_duplicate_supplier_reference()
        <span class="hljs-keyword">for</span> move <span class="hljs-keyword">in</span> self:
            <span class="hljs-comment"># Uses move._origin.id to handle records in edition/existing records and 0 for new records</span>
            move.duplicated_ref_ids = move_to_duplicate_move.get(move._origin, self.env[<span class="hljs-string">'account.move'</span>])

    <span class="hljs-keyword">def</span> <span class="hljs-title function_">_fetch_duplicate_supplier_reference</span>(<span class="hljs-params">self, only_posted=<span class="hljs-literal">False</span></span>):
        moves = self.filtered(<span class="hljs-keyword">lambda</span> m: m.is_purchase_document() <span class="hljs-keyword">and</span> m.ref)
        <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> moves:
            <span class="hljs-keyword">return</span> {}

        used_fields = (<span class="hljs-string">"company_id"</span>, <span class="hljs-string">"partner_id"</span>, <span class="hljs-string">"commercial_partner_id"</span>, <span class="hljs-string">"ref"</span>, <span class="hljs-string">"move_type"</span>, <span class="hljs-string">"invoice_date"</span>, <span class="hljs-string">"state"</span>)
        self.env[<span class="hljs-string">"account.move"</span>].flush_model(used_fields)

        move_table_and_alias = <span class="hljs-string">"account_move AS move"</span>
        place_holders = {}
        <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> moves[<span class="hljs-number">0</span>].<span class="hljs-built_in">id</span>:  <span class="hljs-comment"># check if record is under creation/edition in UI</span>
            <span class="hljs-comment"># New record aren't searchable in the DB and record in edition aren't up to date yet</span>
            <span class="hljs-comment"># Replace the table by safely injecting the values in the query</span>
            place_holders = {
                <span class="hljs-string">"id"</span>: moves._origin.<span class="hljs-built_in">id</span> <span class="hljs-keyword">or</span> <span class="hljs-number">0</span>,
                **{
                    field_name: moves._fields[field_name].convert_to_write(moves[field_name], moves) <span class="hljs-keyword">or</span> <span class="hljs-literal">None</span>
                    <span class="hljs-keyword">for</span> field_name <span class="hljs-keyword">in</span> used_fields
                },
            }
            casted_values = <span class="hljs-string">", "</span>.join([<span class="hljs-string">f"%(<span class="hljs-subst">{field_name}</span>)s::<span class="hljs-subst">{moves._fields[field_name].column_type[<span class="hljs-number">0</span>]}</span>"</span> <span class="hljs-keyword">for</span> field_name <span class="hljs-keyword">in</span> place_holders])
            move_table_and_alias = <span class="hljs-string">f'(VALUES (<span class="hljs-subst">{casted_values}</span>)) AS move(<span class="hljs-subst">{<span class="hljs-string">", "</span>.join(place_holders)}</span>)'</span>

        self.env.cr.execute(<span class="hljs-string">f"""
            SELECT
                   move.id AS move_id,
                   array_agg(duplicate_move.id) AS duplicate_ids
              FROM <span class="hljs-subst">{move_table_and_alias}</span>
              JOIN account_move AS duplicate_move ON
                   move.company_id = duplicate_move.company_id
               AND move.commercial_partner_id = duplicate_move.commercial_partner_id
               AND move.ref = duplicate_move.ref
               AND move.move_type = duplicate_move.move_type
               AND move.id != duplicate_move.id
               AND (move.invoice_date = duplicate_move.invoice_date OR NOT %(only_posted)s)
               AND duplicate_move.state != 'cancel'
               AND (duplicate_move.state = 'posted' OR NOT %(only_posted)s)
             WHERE move.id IN %(moves)s
             GROUP BY move.id
        """</span>, {
            <span class="hljs-string">"only_posted"</span>: only_posted,
            <span class="hljs-string">"moves"</span>: <span class="hljs-built_in">tuple</span>(moves.ids <span class="hljs-keyword">or</span> [<span class="hljs-number">0</span>]),
            **place_holders
        })
        <span class="hljs-keyword">return</span> {
            self.env[<span class="hljs-string">'account.move'</span>].browse(res[<span class="hljs-string">'move_id'</span>]): self.env[<span class="hljs-string">'account.move'</span>].browse(res[<span class="hljs-string">'duplicate_ids'</span>])
            <span class="hljs-keyword">for</span> res <span class="hljs-keyword">in</span> self.env.cr.dictfetchall()
        }

<span class="hljs-meta">    @api.depends(<span class="hljs-params"><span class="hljs-string">'company_id'</span></span>)</span>
    <span class="hljs-keyword">def</span> <span class="hljs-title function_">_compute_display_qr_code</span>(<span class="hljs-params">self</span>):
        <span class="hljs-keyword">for</span> move <span class="hljs-keyword">in</span> self:
            move.display_qr_code = (
                move.move_type <span class="hljs-keyword">in</span> (<span class="hljs-string">'out_invoice'</span>, <span class="hljs-string">'out_receipt'</span>, <span class="hljs-string">'in_invoice'</span>, <span class="hljs-string">'in_receipt'</span>)
                <span class="hljs-keyword">and</span> move.company_id.qr_code
            )

<span class="hljs-meta">    @api.depends(<span class="hljs-params"><span class="hljs-string">'amount_total'</span>, <span class="hljs-string">'currency_id'</span></span>)</span>
    <span class="hljs-keyword">def</span> <span class="hljs-title function_">_compute_amount_total_words</span>(<span class="hljs-params">self</span>):
        <span class="hljs-keyword">for</span> move <span class="hljs-keyword">in</span> self:
            move.amount_total_words = move.currency_id.amount_to_text(move.amount_total).replace(<span class="hljs-string">','</span>, <span class="hljs-string">''</span>)

    <span class="hljs-keyword">def</span> <span class="hljs-title function_">_compute_linked_attachment_id</span>(<span class="hljs-params">self, attachment_field, binary_field</span>):
        <span class="hljs-string">"""Helper to retreive Attachment from Binary fields
        This is needed because fields.Many2one('ir.attachment') makes all
        attachments available to the user.
        """</span>
        attachments = self.env[<span class="hljs-string">'ir.attachment'</span>].search([
            (<span class="hljs-string">'res_model'</span>, <span class="hljs-string">'='</span>, self._name),
            (<span class="hljs-string">'res_id'</span>, <span class="hljs-string">'in'</span>, self.ids),
            (<span class="hljs-string">'res_field'</span>, <span class="hljs-string">'='</span>, binary_field)
        ])
        move_vals = {att.res_id: att <span class="hljs-keyword">for</span> att <span class="hljs-keyword">in</span> attachments}
        <span class="hljs-keyword">for</span> move <span class="hljs-keyword">in</span> self:
            move[attachment_field] = move_vals.get(move._origin.<span class="hljs-built_in">id</span>, <span class="hljs-literal">False</span>)

    <span class="hljs-keyword">def</span> <span class="hljs-title function_">_compute_incoterm_location</span>(<span class="hljs-params">self</span>):
        <span class="hljs-keyword">pass</span>

    <span class="hljs-comment"># -------------------------------------------------------------------------</span>
    <span class="hljs-comment"># INVERSE METHODS</span>
    <span class="hljs-comment"># -------------------------------------------------------------------------</span>

    <span class="hljs-keyword">def</span> <span class="hljs-title function_">_inverse_tax_totals</span>(<span class="hljs-params">self</span>):
        <span class="hljs-keyword">if</span> self.env.context.get(<span class="hljs-string">'skip_invoice_sync'</span>):
            <span class="hljs-keyword">return</span>
        <span class="hljs-keyword">with</span> self._sync_dynamic_line(
            existing_key_fname=<span class="hljs-string">'term_key'</span>,
            needed_vals_fname=<span class="hljs-string">'needed_terms'</span>,
            needed_dirty_fname=<span class="hljs-string">'needed_terms_dirty'</span>,
            line_type=<span class="hljs-string">'payment_term'</span>,
            container={<span class="hljs-string">'records'</span>: self},
        ):
            <span class="hljs-keyword">for</span> move <span class="hljs-keyword">in</span> self:
                <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> move.is_invoice(include_receipts=<span class="hljs-literal">True</span>):
                    <span class="hljs-keyword">continue</span>
                invoice_totals = move.tax_totals

                <span class="hljs-keyword">for</span> amount_by_group_list <span class="hljs-keyword">in</span> invoice_totals[<span class="hljs-string">'groups_by_subtotal'</span>].values():
                    <span class="hljs-keyword">for</span> amount_by_group <span class="hljs-keyword">in</span> amount_by_group_list:
                        tax_lines = move.line_ids.filtered(<span class="hljs-keyword">lambda</span> line: line.tax_group_id.<span class="hljs-built_in">id</span> == amount_by_group[<span class="hljs-string">'tax_group_id'</span>])

                        <span class="hljs-keyword">if</span> tax_lines:
                            first_tax_line = tax_lines[<span class="hljs-number">0</span>]
                            tax_group_old_amount = <span class="hljs-built_in">sum</span>(tax_lines.mapped(<span class="hljs-string">'amount_currency'</span>))
                            sign = -<span class="hljs-number">1</span> <span class="hljs-keyword">if</span> move.is_inbound() <span class="hljs-keyword">else</span> <span class="hljs-number">1</span>
                            delta_amount = tax_group_old_amount * sign - amount_by_group[<span class="hljs-string">'tax_group_amount'</span>]

                            <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> move.currency_id.is_zero(delta_amount):
                                first_tax_line.amount_currency -= delta_amount * sign
            self._compute_amount()

    <span class="hljs-keyword">def</span> <span class="hljs-title function_">_inverse_amount_total</span>(<span class="hljs-params">self</span>):
        <span class="hljs-keyword">for</span> move <span class="hljs-keyword">in</span> self:
            <span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(move.line_ids) != <span class="hljs-number">2</span> <span class="hljs-keyword">or</span> move.is_invoice(include_receipts=<span class="hljs-literal">True</span>):
                <span class="hljs-keyword">continue</span>

            to_write = []

            amount_currency = <span class="hljs-built_in">abs</span>(move.amount_total)
            balance = move.currency_id._convert(amount_currency, move.company_currency_id, move.company_id, move.invoice_date <span class="hljs-keyword">or</span> move.date)

            <span class="hljs-keyword">for</span> line <span class="hljs-keyword">in</span> move.line_ids:
                <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> line.currency_id.is_zero(balance - <span class="hljs-built_in">abs</span>(line.balance)):
                    to_write.append((<span class="hljs-number">1</span>, line.<span class="hljs-built_in">id</span>, {
                        <span class="hljs-string">'debit'</span>: line.balance &gt; <span class="hljs-number">0.0</span> <span class="hljs-keyword">and</span> balance <span class="hljs-keyword">or</span> <span class="hljs-number">0.0</span>,
                        <span class="hljs-string">'credit'</span>: line.balance &lt; <span class="hljs-number">0.0</span> <span class="hljs-keyword">and</span> balance <span class="hljs-keyword">or</span> <span class="hljs-number">0.0</span>,
                        <span class="hljs-string">'amount_currency'</span>: line.balance &gt; <span class="hljs-number">0.0</span> <span class="hljs-keyword">and</span> amount_currency <span class="hljs-keyword">or</span> -amount_currency,
                    }))

            move.write({<span class="hljs-string">'line_ids'</span>: to_write})

<span class="hljs-meta">    @api.onchange(<span class="hljs-params"><span class="hljs-string">'partner_id'</span></span>)</span>
    <span class="hljs-keyword">def</span> <span class="hljs-title function_">_inverse_partner_id</span>(<span class="hljs-params">self</span>):
        <span class="hljs-keyword">for</span> invoice <span class="hljs-keyword">in</span> self:
            <span class="hljs-keyword">if</span> invoice.is_invoice(<span class="hljs-literal">True</span>):
                <span class="hljs-keyword">for</span> line <span class="hljs-keyword">in</span> invoice.line_ids + invoice.invoice_line_ids:
                    <span class="hljs-keyword">if</span> line.partner_id != invoice.commercial_partner_id:
                        line.partner_id = invoice.commercial_partner_id
                        line._inverse_partner_id()

<span class="hljs-meta">    @api.onchange(<span class="hljs-params"><span class="hljs-string">'company_id'</span></span>)</span>
    <span class="hljs-keyword">def</span> <span class="hljs-title function_">_inverse_company_id</span>(<span class="hljs-params">self</span>):
        <span class="hljs-keyword">for</span> move <span class="hljs-keyword">in</span> self:
            <span class="hljs-comment"># This can't be caught by a python constraint as it is only triggered at save and the compute method that</span>
            <span class="hljs-comment"># needs this data to be set correctly before saving</span>
            <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> move.company_id:
                <span class="hljs-keyword">raise</span> ValidationError(_(<span class="hljs-string">"We can't leave this document without any company. Please select a company for this document."</span>))
        self._conditional_add_to_compute(<span class="hljs-string">'journal_id'</span>, <span class="hljs-keyword">lambda</span> m: (
            <span class="hljs-keyword">not</span> m.journal_id.filtered_domain(self.env[<span class="hljs-string">'account.journal'</span>]._check_company_domain(m.company_id))
        ))

<span class="hljs-meta">    @api.onchange(<span class="hljs-params"><span class="hljs-string">'currency_id'</span></span>)</span>
    <span class="hljs-keyword">def</span> <span class="hljs-title function_">_inverse_currency_id</span>(<span class="hljs-params">self</span>):
        (self.line_ids | self.invoice_line_ids)._conditional_add_to_compute(<span class="hljs-string">'currency_id'</span>, <span class="hljs-keyword">lambda</span> l: (
            l.move_id.is_invoice(<span class="hljs-literal">True</span>)
            <span class="hljs-keyword">and</span> l.move_id.currency_id != l.currency_id
        ))

<span class="hljs-meta">    @api.onchange(<span class="hljs-params"><span class="hljs-string">'journal_id'</span></span>)</span>
    <span class="hljs-keyword">def</span> <span class="hljs-title function_">_inverse_journal_id</span>(<span class="hljs-params">self</span>):
        self._conditional_add_to_compute(<span class="hljs-string">'company_id'</span>, <span class="hljs-keyword">lambda</span> m: (
            <span class="hljs-keyword">not</span> m.company_id
            <span class="hljs-keyword">or</span> m.company_id != m.journal_id.company_id
        ))
        self._conditional_add_to_compute(<span class="hljs-string">'currency_id'</span>, <span class="hljs-keyword">lambda</span> m: (
            <span class="hljs-keyword">not</span> m.currency_id
            <span class="hljs-keyword">or</span> m.journal_id.currency_id <span class="hljs-keyword">and</span> m.currency_id != m.journal_id.currency_id
        ))

<span class="hljs-meta">    @api.onchange(<span class="hljs-params"><span class="hljs-string">'payment_reference'</span></span>)</span>
    <span class="hljs-keyword">def</span> <span class="hljs-title function_">_inverse_payment_reference</span>(<span class="hljs-params">self</span>):
        self.line_ids._conditional_add_to_compute(<span class="hljs-string">'name'</span>, <span class="hljs-keyword">lambda</span> line: (
            line.display_type == <span class="hljs-string">'payment_term'</span>
        ))

<span class="hljs-meta">    @api.onchange(<span class="hljs-params"><span class="hljs-string">'invoice_payment_term_id'</span></span>)</span>
    <span class="hljs-keyword">def</span> <span class="hljs-title function_">_inverse_invoice_payment_term_id</span>(<span class="hljs-params">self</span>):
        self.line_ids._conditional_add_to_compute(<span class="hljs-string">'name'</span>, <span class="hljs-keyword">lambda</span> l: (
            l.display_type == <span class="hljs-string">'payment_term'</span>
        ))

    <span class="hljs-keyword">def</span> <span class="hljs-title function_">_inverse_name</span>(<span class="hljs-params">self</span>):
        self._conditional_add_to_compute(<span class="hljs-string">'payment_reference'</span>, <span class="hljs-keyword">lambda</span> move: (
            move.name <span class="hljs-keyword">and</span> move.name != <span class="hljs-string">'/'</span>
        ))

    <span class="hljs-comment"># -------------------------------------------------------------------------</span>
    <span class="hljs-comment"># ONCHANGE METHODS</span>
    <span class="hljs-comment"># -------------------------------------------------------------------------</span>

<span class="hljs-meta">    @api.onchange(<span class="hljs-params"><span class="hljs-string">'date'</span></span>)</span>
    <span class="hljs-keyword">def</span> <span class="hljs-title function_">_onchange_date</span>(<span class="hljs-params">self</span>):
        <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> self.is_invoice(<span class="hljs-literal">True</span>):
            self.line_ids._inverse_amount_currency()

<span class="hljs-meta">    @api.onchange(<span class="hljs-params"><span class="hljs-string">'invoice_vendor_bill_id'</span></span>)</span>
    <span class="hljs-keyword">def</span> <span class="hljs-title function_">_onchange_invoice_vendor_bill</span>(<span class="hljs-params">self</span>):
        <span class="hljs-keyword">if</span> self.invoice_vendor_bill_id:
            <span class="hljs-comment"># Copy invoice lines.</span>
            <span class="hljs-keyword">for</span> line <span class="hljs-keyword">in</span> self.invoice_vendor_bill_id.invoice_line_ids:
                copied_vals = line.copy_data()[<span class="hljs-number">0</span>]
                self.invoice_line_ids += self.env[<span class="hljs-string">'account.move.line'</span>].new(copied_vals)

            self.currency_id = self.invoice_vendor_bill_id.currency_id
            self.fiscal_position_id = self.invoice_vendor_bill_id.fiscal_position_id

            <span class="hljs-comment"># Reset</span>
            self.invoice_vendor_bill_id = <span class="hljs-literal">False</span>

<span class="hljs-meta">    @api.onchange(<span class="hljs-params"><span class="hljs-string">'partner_id'</span></span>)</span>
    <span class="hljs-keyword">def</span> <span class="hljs-title function_">_onchange_partner_id</span>(<span class="hljs-params">self</span>):
        self = self.with_company((self.journal_id.company_id <span class="hljs-keyword">or</span> self.env.company)._accessible_branches()[:<span class="hljs-number">1</span>])

        warning = {}
        <span class="hljs-keyword">if</span> self.partner_id:
            rec_account = self.partner_id.property_account_receivable_id
            pay_account = self.partner_id.property_account_payable_id
            <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> rec_account <span class="hljs-keyword">and</span> <span class="hljs-keyword">not</span> pay_account:
                action = self.env.ref(<span class="hljs-string">'account.action_account_config'</span>)
                msg = _(<span class="hljs-string">'Cannot find a chart of accounts for this company, You should configure it. \nPlease go to Account Configuration.'</span>)
                <span class="hljs-keyword">raise</span> RedirectWarning(msg, action.<span class="hljs-built_in">id</span>, _(<span class="hljs-string">'Go to the configuration panel'</span>))
            p = self.partner_id
            <span class="hljs-keyword">if</span> p.invoice_warn == <span class="hljs-string">'no-message'</span> <span class="hljs-keyword">and</span> p.parent_id:
                p = p.parent_id
            <span class="hljs-keyword">if</span> p.invoice_warn <span class="hljs-keyword">and</span> p.invoice_warn != <span class="hljs-string">'no-message'</span>:
                <span class="hljs-comment"># Block if partner only has warning but parent company is blocked</span>
                <span class="hljs-keyword">if</span> p.invoice_warn != <span class="hljs-string">'block'</span> <span class="hljs-keyword">and</span> p.parent_id <span class="hljs-keyword">and</span> p.parent_id.invoice_warn == <span class="hljs-string">'block'</span>:
                    p = p.parent_id
                warning = {
                    <span class="hljs-string">'title'</span>: _(<span class="hljs-string">"Warning for %s"</span>, p.name),
                    <span class="hljs-string">'message'</span>: p.invoice_warn_msg
                }
                <span class="hljs-keyword">if</span> p.invoice_warn == <span class="hljs-string">'block'</span>:
                    self.partner_id = <span class="hljs-literal">False</span>
                <span class="hljs-keyword">return</span> {<span class="hljs-string">'warning'</span>: warning}

<span class="hljs-meta">    @api.onchange(<span class="hljs-params"><span class="hljs-string">'name'</span>, <span class="hljs-string">'highest_name'</span></span>)</span>
    <span class="hljs-keyword">def</span> <span class="hljs-title function_">_onchange_name_warning</span>(<span class="hljs-params">self</span>):
        <span class="hljs-keyword">if</span> self.name <span class="hljs-keyword">and</span> self.name != <span class="hljs-string">'/'</span> <span class="hljs-keyword">and</span> self.name &lt;= (self.highest_name <span class="hljs-keyword">or</span> <span class="hljs-string">''</span>) <span class="hljs-keyword">and</span> <span class="hljs-keyword">not</span> self.quick_edit_mode:
            self.show_name_warning = <span class="hljs-literal">True</span>
        <span class="hljs-keyword">else</span>:
            self.show_name_warning = <span class="hljs-literal">False</span>

        origin_name = self._origin.name
        <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> origin_name <span class="hljs-keyword">or</span> origin_name == <span class="hljs-string">'/'</span>:
            origin_name = self.highest_name
        <span class="hljs-keyword">if</span> (
            self.name <span class="hljs-keyword">and</span> self.name != <span class="hljs-string">'/'</span>
            <span class="hljs-keyword">and</span> origin_name <span class="hljs-keyword">and</span> origin_name != <span class="hljs-string">'/'</span>
            <span class="hljs-keyword">and</span> self.date == self._origin.date
            <span class="hljs-keyword">and</span> self.journal_id == self._origin.journal_id
        ):
            new_format, new_format_values = self._get_sequence_format_param(self.name)
            origin_format, origin_format_values = self._get_sequence_format_param(origin_name)

            <span class="hljs-keyword">if</span> (
                new_format != origin_format
                <span class="hljs-keyword">or</span> <span class="hljs-built_in">dict</span>(new_format_values, year=<span class="hljs-number">0</span>, month=<span class="hljs-number">0</span>, seq=<span class="hljs-number">0</span>) != <span class="hljs-built_in">dict</span>(origin_format_values, year=<span class="hljs-number">0</span>, month=<span class="hljs-number">0</span>, seq=<span class="hljs-number">0</span>)
            ):
                changed = _(
                    <span class="hljs-string">"It was previously '%(previous)s' and it is now '%(current)s'."</span>,
                    previous=origin_name,
                    current=self.name,
                )
                reset = self._deduce_sequence_number_reset(self.name)
                <span class="hljs-keyword">if</span> reset == <span class="hljs-string">'month'</span>:
                    detected = _(
                        <span class="hljs-string">"The sequence will restart at 1 at the start of every month.\n"</span>
                        <span class="hljs-string">"The year detected here is '%(year)s' and the month is '%(month)s'.\n"</span>
                        <span class="hljs-string">"The incrementing number in this case is '%(formatted_seq)s'."</span>
                    )
                <span class="hljs-keyword">elif</span> reset == <span class="hljs-string">'year'</span>:
                    detected = _(
                        <span class="hljs-string">"The sequence will restart at 1 at the start of every year.\n"</span>
                        <span class="hljs-string">"The year detected here is '%(year)s'.\n"</span>
                        <span class="hljs-string">"The incrementing number in this case is '%(formatted_seq)s'."</span>
                    )
                <span class="hljs-keyword">elif</span> reset == <span class="hljs-string">'year_range'</span>:
                    detected = _(
                        <span class="hljs-string">"The sequence will restart at 1 at the start of every financial year.\n"</span>
                        <span class="hljs-string">"The financial start year detected here is '%(year)s'.\n"</span>
                        <span class="hljs-string">"The financial end year detected here is '%(year_end)s'.\n"</span>
                        <span class="hljs-string">"The incrementing number in this case is '%(formatted_seq)s'."</span>
                    )
                <span class="hljs-keyword">else</span>:
                    detected = _(
                        <span class="hljs-string">"The sequence will never restart.\n"</span>
                        <span class="hljs-string">"The incrementing number in this case is '%(formatted_seq)s'."</span>
                    )
                new_format_values[<span class="hljs-string">'formatted_seq'</span>] = <span class="hljs-string">"{seq:0{seq_length}d}"</span>.<span class="hljs-built_in">format</span>(**new_format_values)
                detected = detected % new_format_values
                <span class="hljs-keyword">return</span> {<span class="hljs-string">'warning'</span>: {
                    <span class="hljs-string">'title'</span>: _(<span class="hljs-string">"The sequence format has changed."</span>),
                    <span class="hljs-string">'message'</span>: <span class="hljs-string">"%s\n\n%s"</span> % (changed, detected)
                }}

<span class="hljs-meta">    @api.onchange(<span class="hljs-params"><span class="hljs-string">'journal_id'</span></span>)</span>
    <span class="hljs-keyword">def</span> <span class="hljs-title function_">_onchange_journal_id</span>(<span class="hljs-params">self</span>):
        <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> self.quick_edit_mode:
            self.name = <span class="hljs-string">'/'</span>
            self._compute_name()

<span class="hljs-meta">    @api.onchange(<span class="hljs-params"><span class="hljs-string">'invoice_cash_rounding_id'</span></span>)</span>
    <span class="hljs-keyword">def</span> <span class="hljs-title function_">_onchange_invoice_cash_rounding_id</span>(<span class="hljs-params">self</span>):
        <span class="hljs-keyword">for</span> move <span class="hljs-keyword">in</span> self:
            <span class="hljs-keyword">if</span> move.invoice_cash_rounding_id.strategy == <span class="hljs-string">'add_invoice_line'</span> <span class="hljs-keyword">and</span> <span class="hljs-keyword">not</span> move.invoice_cash_rounding_id.profit_account_id:
                <span class="hljs-keyword">return</span> {<span class="hljs-string">'warning'</span>: {
                    <span class="hljs-string">'title'</span>: _(<span class="hljs-string">"Warning for Cash Rounding Method: %s"</span>, move.invoice_cash_rounding_id.name),
                    <span class="hljs-string">'message'</span>: _(<span class="hljs-string">"You must specify the Profit Account (company dependent)"</span>)
                }}

    <span class="hljs-comment"># -------------------------------------------------------------------------</span>
    <span class="hljs-comment"># CONSTRAINT METHODS</span>
    <span class="hljs-comment"># -------------------------------------------------------------------------</span>

<span class="hljs-meta">    @contextmanager</span>
    <span class="hljs-keyword">def</span> <span class="hljs-title function_">_check_balanced</span>(<span class="hljs-params">self, container</span>):
        <span class="hljs-string">''' Assert the move is fully balanced debit = credit.
        An error is raised if it's not the case.
        '''</span>
        <span class="hljs-keyword">with</span> self._disable_recursion(container, <span class="hljs-string">'check_move_validity'</span>, default=<span class="hljs-literal">True</span>, target=<span class="hljs-literal">False</span>) <span class="hljs-keyword">as</span> disabled:
            <span class="hljs-keyword">yield</span>
            <span class="hljs-keyword">if</span> disabled:
                <span class="hljs-keyword">return</span>

        unbalanced_moves = self._get_unbalanced_moves(container)
        <span class="hljs-keyword">if</span> unbalanced_moves:
            error_msg = _(<span class="hljs-string">"An error has occurred."</span>)
            <span class="hljs-keyword">for</span> move_id, sum_debit, sum_credit <span class="hljs-keyword">in</span> unbalanced_moves:
                move = self.browse(move_id)
                error_msg += _(
                    <span class="hljs-string">"\n\n"</span>
                    <span class="hljs-string">"The move (%s) is not balanced.\n"</span>
                    <span class="hljs-string">"The total of debits equals %s and the total of credits equals %s.\n"</span>
                    <span class="hljs-string">"You might want to specify a default account on journal \"%s\" to automatically balance each move."</span>,
                    move.display_name,
                    format_amount(self.env, sum_debit, move.company_id.currency_id),
                    format_amount(self.env, sum_credit, move.company_id.currency_id),
                    move.journal_id.name)
            <span class="hljs-keyword">raise</span> UserError(error_msg)

    <span class="hljs-keyword">def</span> <span class="hljs-title function_">_get_unbalanced_moves</span>(<span class="hljs-params">self, container</span>):
        moves = container[<span class="hljs-string">'records'</span>].filtered(<span class="hljs-keyword">lambda</span> move: move.line_ids)
        <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> moves:
            <span class="hljs-keyword">return</span>

        <span class="hljs-comment"># /!\ As this method is called in create / write, we can't make the assumption the computed stored fields</span>
        <span class="hljs-comment"># are already done. Then, this query MUST NOT depend on computed stored fields.</span>
        <span class="hljs-comment"># It happens as the ORM calls create() with the 'no_recompute' statement.</span>
        self.env[<span class="hljs-string">'account.move.line'</span>].flush_model([<span class="hljs-string">'debit'</span>, <span class="hljs-string">'credit'</span>, <span class="hljs-string">'balance'</span>, <span class="hljs-string">'currency_id'</span>, <span class="hljs-string">'move_id'</span>])
        self._cr.execute(<span class="hljs-string">'''
            SELECT line.move_id,
                   ROUND(SUM(line.debit), currency.decimal_places) debit,
                   ROUND(SUM(line.credit), currency.decimal_places) credit
              FROM account_move_line line
              JOIN account_move move ON move.id = line.move_id
              JOIN res_company company ON company.id = move.company_id
              JOIN res_currency currency ON currency.id = company.currency_id
             WHERE line.move_id IN %s
          GROUP BY line.move_id, currency.decimal_places
            HAVING ROUND(SUM(line.balance), currency.decimal_places) != 0
        '''</span>, [<span class="hljs-built_in">tuple</span>(moves.ids)])

        <span class="hljs-keyword">return</span> self._cr.fetchall()

    <span class="hljs-keyword">def</span> <span class="hljs-title function_">_check_fiscalyear_lock_date</span>(<span class="hljs-params">self</span>):
        <span class="hljs-keyword">for</span> move <span class="hljs-keyword">in</span> self:
            lock_date = move.company_id._get_user_fiscal_lock_date()
            <span class="hljs-keyword">if</span> move.date &lt;= lock_date:
                <span class="hljs-keyword">if</span> self.user_has_groups(<span class="hljs-string">'account.group_account_manager'</span>):
                    message = _(<span class="hljs-string">"You cannot add/modify entries prior to and inclusive of the lock date %s."</span>, format_date(self.env, lock_date))
                <span class="hljs-keyword">else</span>:
                    message = _(<span class="hljs-string">"You cannot add/modify entries prior to and inclusive of the lock date %s. Check the company settings or ask someone with the 'Adviser' role"</span>, format_date(self.env, lock_date))
                <span class="hljs-keyword">raise</span> UserError(message)
        <span class="hljs-keyword">return</span> <span class="hljs-literal">True</span>

<span class="hljs-meta">    @api.constrains(<span class="hljs-params"><span class="hljs-string">'auto_post'</span>, <span class="hljs-string">'invoice_date'</span></span>)</span>
    <span class="hljs-keyword">def</span> <span class="hljs-title function_">_require_bill_date_for_autopost</span>(<span class="hljs-params">self</span>):
        <span class="hljs-string">"""Vendor bills must have an invoice date set to be posted. Require it for auto-posted bills."""</span>
        <span class="hljs-keyword">for</span> record <span class="hljs-keyword">in</span> self:
            <span class="hljs-keyword">if</span> record.auto_post != <span class="hljs-string">'no'</span> <span class="hljs-keyword">and</span> record.is_purchase_document() <span class="hljs-keyword">and</span> <span class="hljs-keyword">not</span> record.invoice_date:
                <span class="hljs-keyword">raise</span> ValidationError(_(<span class="hljs-string">"For this entry to be automatically posted, it required a bill date."</span>))

<span class="hljs-meta">    @api.constrains(<span class="hljs-params"><span class="hljs-string">'journal_id'</span>, <span class="hljs-string">'move_type'</span></span>)</span>
    <span class="hljs-keyword">def</span> <span class="hljs-title function_">_check_journal_move_type</span>(<span class="hljs-params">self</span>):
        <span class="hljs-keyword">for</span> move <span class="hljs-keyword">in</span> self:
            <span class="hljs-keyword">if</span> move.is_purchase_document(include_receipts=<span class="hljs-literal">True</span>) <span class="hljs-keyword">and</span> move.journal_id.<span class="hljs-built_in">type</span> != <span class="hljs-string">'purchase'</span>:
                <span class="hljs-keyword">raise</span> ValidationError(_(<span class="hljs-string">"Cannot create a purchase document in a non purchase journal"</span>))
            <span class="hljs-keyword">if</span> move.is_sale_document(include_receipts=<span class="hljs-literal">True</span>) <span class="hljs-keyword">and</span> move.journal_id.<span class="hljs-built_in">type</span> != <span class="hljs-string">'sale'</span>:
                <span class="hljs-keyword">raise</span> ValidationError(_(<span class="hljs-string">"Cannot create a sale document in a non sale journal"</span>))

<span class="hljs-meta">    @api.constrains(<span class="hljs-params"><span class="hljs-string">'ref'</span>, <span class="hljs-string">'move_type'</span>, <span class="hljs-string">'partner_id'</span>, <span class="hljs-string">'journal_id'</span>, <span class="hljs-string">'invoice_date'</span>, <span class="hljs-string">'state'</span></span>)</span>
    <span class="hljs-keyword">def</span> <span class="hljs-title function_">_check_duplicate_supplier_reference</span>(<span class="hljs-params">self</span>):
        <span class="hljs-string">""" Assert the move which is about to be posted isn't a duplicated move from another posted entry"""</span>
        move_to_duplicate_moves = self.filtered(<span class="hljs-keyword">lambda</span> m: m.state == <span class="hljs-string">'posted'</span>)._fetch_duplicate_supplier_reference(only_posted=<span class="hljs-literal">True</span>)
        <span class="hljs-keyword">if</span> <span class="hljs-built_in">any</span>(duplicate_move <span class="hljs-keyword">for</span> duplicate_move <span class="hljs-keyword">in</span> move_to_duplicate_moves.values()):
            duplicate_move_ids = <span class="hljs-built_in">list</span>(<span class="hljs-built_in">set</span>(
                move_id
                <span class="hljs-keyword">for</span> move_ids <span class="hljs-keyword">in</span> (move.ids + duplicate.ids <span class="hljs-keyword">for</span> move, duplicate <span class="hljs-keyword">in</span> move_to_duplicate_moves.items() <span class="hljs-keyword">if</span> duplicate)
                <span class="hljs-keyword">for</span> move_id <span class="hljs-keyword">in</span> move_ids
            ))
            action = self.env[<span class="hljs-string">'ir.actions.actions'</span>]._for_xml_id(<span class="hljs-string">'account.action_move_line_form'</span>)
            action[<span class="hljs-string">'domain'</span>] = [(<span class="hljs-string">'id'</span>, <span class="hljs-string">'in'</span>, duplicate_move_ids)]
            action[<span class="hljs-string">'views'</span>] = [((view_id, <span class="hljs-string">'list'</span>) <span class="hljs-keyword">if</span> view_type == <span class="hljs-string">'tree'</span> <span class="hljs-keyword">else</span> (view_id, view_type)) <span class="hljs-keyword">for</span> view_id, view_type <span class="hljs-keyword">in</span> action[<span class="hljs-string">'views'</span>]]
            <span class="hljs-keyword">raise</span> RedirectWarning(
                message=_(<span class="hljs-string">"Duplicated vendor reference detected. You probably encoded twice the same vendor bill/credit note."</span>),
                action=action,
                button_text=_(<span class="hljs-string">"Open list"</span>),
            )

<span class="hljs-meta">    @api.constrains(<span class="hljs-params"><span class="hljs-string">'line_ids'</span>, <span class="hljs-string">'fiscal_position_id'</span>, <span class="hljs-string">'company_id'</span></span>)</span>
    <span class="hljs-keyword">def</span> <span class="hljs-title function_">_validate_taxes_country</span>(<span class="hljs-params">self</span>):
        <span class="hljs-string">""" By playing with the fiscal position in the form view, it is possible to keep taxes on the invoices from
        a different country than the one allowed by the fiscal country or the fiscal position.
        This contrains ensure such account.move cannot be kept, as they could generate inconsistencies in the reports.
        """</span>
        self._compute_tax_country_id() <span class="hljs-comment"># We need to ensure this field has been computed, as we use it in our check</span>
        <span class="hljs-keyword">for</span> record <span class="hljs-keyword">in</span> self:
            amls = record.line_ids
            impacted_countries = amls.tax_ids.country_id | amls.tax_line_id.country_id
            <span class="hljs-keyword">if</span> impacted_countries <span class="hljs-keyword">and</span> impacted_countries != record.tax_country_id:
                <span class="hljs-keyword">if</span> record.fiscal_position_id <span class="hljs-keyword">and</span> impacted_countries != record.fiscal_position_id.country_id:
                    <span class="hljs-keyword">raise</span> ValidationError(_(<span class="hljs-string">"This entry contains taxes that are not compatible with your fiscal position. Check the country set in fiscal position and in your tax configuration."</span>))
                <span class="hljs-keyword">raise</span> ValidationError(_(<span class="hljs-string">"This entry contains one or more taxes that are incompatible with your fiscal country. Check company fiscal country in the settings and tax country in taxes configuration."</span>))

    <span class="hljs-comment"># -------------------------------------------------------------------------</span>
    <span class="hljs-comment"># EARLY PAYMENT DISCOUNT</span>
    <span class="hljs-comment"># -------------------------------------------------------------------------</span>
    <span class="hljs-keyword">def</span> <span class="hljs-title function_">_is_eligible_for_early_payment_discount</span>(<span class="hljs-params">self, currency, reference_date</span>):
        self.ensure_one()
        <span class="hljs-keyword">return</span> self.currency_id == currency \
            <span class="hljs-keyword">and</span> self.move_type <span class="hljs-keyword">in</span> (<span class="hljs-string">'out_invoice'</span>, <span class="hljs-string">'out_receipt'</span>, <span class="hljs-string">'in_invoice'</span>, <span class="hljs-string">'in_receipt'</span>) \
            <span class="hljs-keyword">and</span> self.invoice_payment_term_id.early_discount \
            <span class="hljs-keyword">and</span> (<span class="hljs-keyword">not</span> reference_date <span class="hljs-keyword">or</span> reference_date &lt;= self.invoice_payment_term_id._get_last_discount_date(self.invoice_date)) \
            <span class="hljs-keyword">and</span> self.payment_state == <span class="hljs-string">'not_paid'</span>

    <span class="hljs-comment"># -------------------------------------------------------------------------</span>
    <span class="hljs-comment"># BUSINESS MODELS SYNCHRONIZATION</span>
    <span class="hljs-comment"># -------------------------------------------------------------------------</span>

    <span class="hljs-keyword">def</span> <span class="hljs-title function_">_synchronize_business_models</span>(<span class="hljs-params">self, changed_fields</span>):
        <span class="hljs-string">''' Ensure the consistency between:
        account.payment &amp; account.move
        account.bank.statement.line &amp; account.move

        The idea is to call the method performing the synchronization of the business
        models regarding their related journal entries. To avoid cycling, the
        'skip_account_move_synchronization' key is used through the context.

        :param changed_fields: A set containing all modified fields on account.move.
        '''</span>
        <span class="hljs-keyword">if</span> self._context.get(<span class="hljs-string">'skip_account_move_synchronization'</span>):
            <span class="hljs-keyword">return</span>

        self_sudo = self.sudo()
        self_sudo.payment_id._synchronize_from_moves(changed_fields)
        self_sudo.statement_line_id._synchronize_from_moves(changed_fields)

    <span class="hljs-comment"># -------------------------------------------------------------------------</span>
    <span class="hljs-comment"># DYNAMIC LINES</span>
    <span class="hljs-comment"># -------------------------------------------------------------------------</span>

    <span class="hljs-keyword">def</span> <span class="hljs-title function_">_recompute_cash_rounding_lines</span>(<span class="hljs-params">self</span>):
        <span class="hljs-string">''' Handle the cash rounding feature on invoices.

        In some countries, the smallest coins do not exist. For example, in Switzerland, there is no coin for 0.01 CHF.
        For this reason, if invoices are paid in cash, you have to round their total amount to the smallest coin that
        exists in the currency. For the CHF, the smallest coin is 0.05 CHF.

        There are two strategies for the rounding:

        1) Add a line on the invoice for the rounding: The cash rounding line is added as a new invoice line.
        2) Add the rounding in the biggest tax amount: The cash rounding line is added as a new tax line on the tax
        having the biggest balance.
        '''</span>
        self.ensure_one()
        <span class="hljs-keyword">def</span> <span class="hljs-title function_">_compute_cash_rounding</span>(<span class="hljs-params">self, total_amount_currency</span>):
            <span class="hljs-string">''' Compute the amount differences due to the cash rounding.
            :param self:                    The current account.move record.
            :param total_amount_currency:   The invoice's total in invoice's currency.
            :return:                        The amount differences both in company's currency &amp; invoice's currency.
            '''</span>
            difference = self.invoice_cash_rounding_id.compute_difference(self.currency_id, total_amount_currency)
            <span class="hljs-keyword">if</span> self.currency_id == self.company_id.currency_id:
                diff_amount_currency = diff_balance = difference
            <span class="hljs-keyword">else</span>:
                diff_amount_currency = difference
                diff_balance = self.currency_id._convert(diff_amount_currency, self.company_id.currency_id, self.company_id, self.invoice_date <span class="hljs-keyword">or</span> self.date)
            <span class="hljs-keyword">return</span> diff_balance, diff_amount_currency

        <span class="hljs-keyword">def</span> <span class="hljs-title function_">_apply_cash_rounding</span>(<span class="hljs-params">self, diff_balance, diff_amount_currency, cash_rounding_line</span>):
            <span class="hljs-string">''' Apply the cash rounding.
            :param self:                    The current account.move record.
            :param diff_balance:            The computed balance to set on the new rounding line.
            :param diff_amount_currency:    The computed amount in invoice's currency to set on the new rounding line.
            :param cash_rounding_line:      The existing cash rounding line.
            :return:                        The newly created rounding line.
            '''</span>
            rounding_line_vals = {
                <span class="hljs-string">'balance'</span>: diff_balance,
                <span class="hljs-string">'amount_currency'</span>: diff_amount_currency,
                <span class="hljs-string">'partner_id'</span>: self.partner_id.<span class="hljs-built_in">id</span>,
                <span class="hljs-string">'move_id'</span>: self.<span class="hljs-built_in">id</span>,
                <span class="hljs-string">'currency_id'</span>: self.currency_id.<span class="hljs-built_in">id</span>,
                <span class="hljs-string">'company_id'</span>: self.company_id.<span class="hljs-built_in">id</span>,
                <span class="hljs-string">'company_currency_id'</span>: self.company_id.currency_id.<span class="hljs-built_in">id</span>,
                <span class="hljs-string">'display_type'</span>: <span class="hljs-string">'rounding'</span>,
            }

            <span class="hljs-keyword">if</span> self.invoice_cash_rounding_id.strategy == <span class="hljs-string">'biggest_tax'</span>:
                biggest_tax_line = <span class="hljs-literal">None</span>
                <span class="hljs-keyword">for</span> tax_line <span class="hljs-keyword">in</span> self.line_ids.filtered(<span class="hljs-string">'tax_repartition_line_id'</span>):
                    <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> biggest_tax_line <span class="hljs-keyword">or</span> <span class="hljs-built_in">abs</span>(tax_line.balance) &gt; <span class="hljs-built_in">abs</span>(biggest_tax_line.balance):
                        biggest_tax_line = tax_line

                <span class="hljs-comment"># No tax found.</span>
                <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> biggest_tax_line:
                    <span class="hljs-keyword">return</span>

                rounding_line_vals.update({
                    <span class="hljs-string">'name'</span>: _(<span class="hljs-string">'%s (rounding)'</span>, biggest_tax_line.name),
                    <span class="hljs-string">'account_id'</span>: biggest_tax_line.account_id.<span class="hljs-built_in">id</span>,
                    <span class="hljs-string">'tax_repartition_line_id'</span>: biggest_tax_line.tax_repartition_line_id.<span class="hljs-built_in">id</span>,
                    <span class="hljs-string">'tax_tag_ids'</span>: [(<span class="hljs-number">6</span>, <span class="hljs-number">0</span>, biggest_tax_line.tax_tag_ids.ids)],
                    <span class="hljs-string">'tax_ids'</span>: [Command.<span class="hljs-built_in">set</span>(biggest_tax_line.tax_ids.ids)]
                })

            <span class="hljs-keyword">elif</span> self.invoice_cash_rounding_id.strategy == <span class="hljs-string">'add_invoice_line'</span>:
                <span class="hljs-keyword">if</span> diff_balance &gt; <span class="hljs-number">0.0</span> <span class="hljs-keyword">and</span> self.invoice_cash_rounding_id.loss_account_id:
                    account_id = self.invoice_cash_rounding_id.loss_account_id.<span class="hljs-built_in">id</span>
                <span class="hljs-keyword">else</span>:
                    account_id = self.invoice_cash_rounding_id.profit_account_id.<span class="hljs-built_in">id</span>
                rounding_line_vals.update({
                    <span class="hljs-string">'name'</span>: self.invoice_cash_rounding_id.name,
                    <span class="hljs-string">'account_id'</span>: account_id,
                    <span class="hljs-string">'tax_ids'</span>: [Command.clear()]
                })

            <span class="hljs-comment"># Create or update the cash rounding line.</span>
            <span class="hljs-keyword">if</span> cash_rounding_line:
                cash_rounding_line.write(rounding_line_vals)
            <span class="hljs-keyword">else</span>:
                cash_rounding_line = self.env[<span class="hljs-string">'account.move.line'</span>].create(rounding_line_vals)

        existing_cash_rounding_line = self.line_ids.filtered(<span class="hljs-keyword">lambda</span> line: line.display_type == <span class="hljs-string">'rounding'</span>)

        <span class="hljs-comment"># The cash rounding has been removed.</span>
        <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> self.invoice_cash_rounding_id:
            existing_cash_rounding_line.unlink()
            <span class="hljs-comment"># self.line_ids -= existing_cash_rounding_line</span>
            <span class="hljs-keyword">return</span>

        <span class="hljs-comment"># The cash rounding strategy has changed.</span>
        <span class="hljs-keyword">if</span> self.invoice_cash_rounding_id <span class="hljs-keyword">and</span> existing_cash_rounding_line:
            strategy = self.invoice_cash_rounding_id.strategy
            old_strategy = <span class="hljs-string">'biggest_tax'</span> <span class="hljs-keyword">if</span> existing_cash_rounding_line.tax_line_id <span class="hljs-keyword">else</span> <span class="hljs-string">'add_invoice_line'</span>
            <span class="hljs-keyword">if</span> strategy != old_strategy:
                <span class="hljs-comment"># self.line_ids -= existing_cash_rounding_line</span>
                existing_cash_rounding_line.unlink()
                existing_cash_rounding_line = self.env[<span class="hljs-string">'account.move.line'</span>]

        others_lines = self.line_ids.filtered(<span class="hljs-keyword">lambda</span> line: line.account_id.account_type <span class="hljs-keyword">not</span> <span class="hljs-keyword">in</span> (<span class="hljs-string">'asset_receivable'</span>, <span class="hljs-string">'liability_payable'</span>))
        others_lines -= existing_cash_rounding_line
        total_amount_currency = <span class="hljs-built_in">sum</span>(others_lines.mapped(<span class="hljs-string">'amount_currency'</span>))

        diff_balance, diff_amount_currency = _compute_cash_rounding(self, total_amount_currency)

        <span class="hljs-comment"># The invoice is already rounded.</span>
        <span class="hljs-keyword">if</span> self.currency_id.is_zero(diff_balance) <span class="hljs-keyword">and</span> self.currency_id.is_zero(diff_amount_currency):
            existing_cash_rounding_line.unlink()
            <span class="hljs-comment"># self.line_ids -= existing_cash_rounding_line</span>
            <span class="hljs-keyword">return</span>

        <span class="hljs-comment"># No update needed</span>
        <span class="hljs-keyword">if</span> existing_cash_rounding_line \
            <span class="hljs-keyword">and</span> float_compare(existing_cash_rounding_line.balance, diff_balance, precision_rounding=self.currency_id.rounding) == <span class="hljs-number">0</span> \
            <span class="hljs-keyword">and</span> float_compare(existing_cash_rounding_line.amount_currency, diff_amount_currency, precision_rounding=self.currency_id.rounding) == <span class="hljs-number">0</span>:
            <span class="hljs-keyword">return</span>

        _apply_cash_rounding(self, diff_balance, diff_amount_currency, existing_cash_rounding_line)

<span class="hljs-meta">    @contextmanager</span>
    <span class="hljs-keyword">def</span> <span class="hljs-title function_">_sync_unbalanced_lines</span>(<span class="hljs-params">self, container</span>):
        <span class="hljs-keyword">yield</span>
        <span class="hljs-comment"># Skip posted moves.</span>
        <span class="hljs-keyword">for</span> invoice <span class="hljs-keyword">in</span> (x <span class="hljs-keyword">for</span> x <span class="hljs-keyword">in</span> container[<span class="hljs-string">'records'</span>] <span class="hljs-keyword">if</span> x.state != <span class="hljs-string">'posted'</span>):

            <span class="hljs-comment"># Unlink tax lines if all taxes have been removed.</span>
            <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> invoice.line_ids.tax_ids:
                <span class="hljs-comment"># if there isn't any tax but there remains a tax_line_id, it means we are currently in the process of</span>
                <span class="hljs-comment"># removing the taxes from the entry. Thus, we want the automatic balancing to happen in order  to have</span>
                <span class="hljs-comment"># a smooth process for tax deletion</span>
                <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> invoice.line_ids.filtered(<span class="hljs-string">'tax_line_id'</span>):
                    <span class="hljs-keyword">continue</span>
                invoice.line_ids.filtered(<span class="hljs-string">'tax_line_id'</span>).unlink()

            <span class="hljs-comment"># Set the balancing line's balance and amount_currency to zero,</span>
            <span class="hljs-comment"># so that it does not interfere with _get_unbalanced_moves() below.</span>
            balance_name = _(<span class="hljs-string">'Automatic Balancing Line'</span>)
            existing_balancing_line = invoice.line_ids.filtered(<span class="hljs-keyword">lambda</span> line: line.name == balance_name)
            <span class="hljs-keyword">if</span> existing_balancing_line:
                existing_balancing_line.balance = existing_balancing_line.amount_currency = <span class="hljs-number">0.0</span>

            <span class="hljs-comment"># Create an automatic balancing line to make sure the entry can be saved/posted.</span>
            <span class="hljs-comment"># If such a line already exists, we simply update its amounts.</span>
            unbalanced_moves = self._get_unbalanced_moves({<span class="hljs-string">'records'</span>: invoice})
            <span class="hljs-keyword">if</span> <span class="hljs-built_in">isinstance</span>(unbalanced_moves, <span class="hljs-built_in">list</span>) <span class="hljs-keyword">and</span> <span class="hljs-built_in">len</span>(unbalanced_moves) == <span class="hljs-number">1</span>:
                dummy, debit, credit = unbalanced_moves[<span class="hljs-number">0</span>]

                vals = {<span class="hljs-string">'balance'</span>: credit - debit}
                <span class="hljs-keyword">if</span> existing_balancing_line:
                    existing_balancing_line.write(vals)
                <span class="hljs-keyword">else</span>:
                    vals.update({
                        <span class="hljs-string">'name'</span>: balance_name,
                        <span class="hljs-string">'move_id'</span>: invoice.<span class="hljs-built_in">id</span>,
                        <span class="hljs-string">'account_id'</span>: invoice.company_id.account_journal_suspense_account_id.<span class="hljs-built_in">id</span>,
                        <span class="hljs-string">'currency_id'</span>: invoice.currency_id.<span class="hljs-built_in">id</span>,
                    })
                    self.env[<span class="hljs-string">'account.move.line'</span>].create(vals)

<span class="hljs-meta">    @contextmanager</span>
    <span class="hljs-keyword">def</span> <span class="hljs-title function_">_sync_rounding_lines</span>(<span class="hljs-params">self, container</span>):
        <span class="hljs-keyword">yield</span>
        <span class="hljs-keyword">for</span> invoice <span class="hljs-keyword">in</span> container[<span class="hljs-string">'records'</span>]:
            <span class="hljs-keyword">if</span> invoice.state != <span class="hljs-string">'posted'</span>:
                invoice._recompute_cash_rounding_lines()

<span class="hljs-meta">    @contextmanager</span>
    <span class="hljs-keyword">def</span> <span class="hljs-title function_">_sync_dynamic_line</span>(<span class="hljs-params">self, existing_key_fname, needed_vals_fname, needed_dirty_fname, line_type, container</span>):
        <span class="hljs-keyword">def</span> <span class="hljs-title function_">existing</span>():
            <span class="hljs-keyword">return</span> {
                line[existing_key_fname]: line
                <span class="hljs-keyword">for</span> line <span class="hljs-keyword">in</span> container[<span class="hljs-string">'records'</span>].line_ids
                <span class="hljs-keyword">if</span> line[existing_key_fname]
            }
        <span class="hljs-keyword">def</span> <span class="hljs-title function_">needed</span>():
            res = {}
            <span class="hljs-keyword">for</span> computed_needed <span class="hljs-keyword">in</span> container[<span class="hljs-string">'records'</span>].mapped(needed_vals_fname):
                <span class="hljs-keyword">if</span> computed_needed <span class="hljs-keyword">is</span> <span class="hljs-literal">False</span>:
                    <span class="hljs-keyword">continue</span>  <span class="hljs-comment"># there was an invalidation, let's hope nothing needed to be changed...</span>
                <span class="hljs-keyword">for</span> key, values <span class="hljs-keyword">in</span> computed_needed.items():
                    <span class="hljs-keyword">if</span> key <span class="hljs-keyword">not</span> <span class="hljs-keyword">in</span> res:
                        res[key] = <span class="hljs-built_in">dict</span>(values)
                    <span class="hljs-keyword">else</span>:
                        ignore = <span class="hljs-literal">True</span>
                        <span class="hljs-keyword">for</span> fname <span class="hljs-keyword">in</span> res[key]:
                            <span class="hljs-keyword">if</span> self.env[<span class="hljs-string">'account.move.line'</span>]._fields[fname].<span class="hljs-built_in">type</span> == <span class="hljs-string">'monetary'</span>:
                                res[key][fname] += values[fname]
                                <span class="hljs-keyword">if</span> res[key][fname]:
                                    ignore = <span class="hljs-literal">False</span>
                        <span class="hljs-keyword">if</span> ignore:
                            <span class="hljs-keyword">del</span> res[key]

            <span class="hljs-comment"># Convert float values to their "ORM cache" one to prevent different rounding calculations</span>
            <span class="hljs-keyword">for</span> dict_key <span class="hljs-keyword">in</span> res:
                move_id = dict_key.get(<span class="hljs-string">'move_id'</span>)
                <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> move_id:
                    <span class="hljs-keyword">continue</span>
                record = self.env[<span class="hljs-string">'account.move'</span>].browse(move_id)
                <span class="hljs-keyword">for</span> fname, current_value <span class="hljs-keyword">in</span> res[dict_key].items():
                    field = self.env[<span class="hljs-string">'account.move.line'</span>]._fields[fname]
                    <span class="hljs-keyword">if</span> <span class="hljs-built_in">isinstance</span>(current_value, <span class="hljs-built_in">float</span>):
                        new_value = field.convert_to_cache(current_value, record)
                        res[dict_key][fname] = new_value

            <span class="hljs-keyword">return</span> res

        <span class="hljs-keyword">def</span> <span class="hljs-title function_">dirty</span>():
            *path, dirty_fname = needed_dirty_fname.split(<span class="hljs-string">'.'</span>)
            eligible_recs = container[<span class="hljs-string">'records'</span>].mapped(<span class="hljs-string">'.'</span>.join(path))
            <span class="hljs-keyword">if</span> eligible_recs._name == <span class="hljs-string">'account.move.line'</span>:
                eligible_recs = eligible_recs.filtered(<span class="hljs-keyword">lambda</span> l: l.display_type != <span class="hljs-string">'cogs'</span>)
            dirty_recs = eligible_recs.filtered(dirty_fname)
            <span class="hljs-keyword">return</span> dirty_recs, dirty_fname

        <span class="hljs-keyword">def</span> <span class="hljs-title function_">filter_trivial</span>(<span class="hljs-params">mapping</span>):
            <span class="hljs-keyword">return</span> {k: v <span class="hljs-keyword">for</span> k, v <span class="hljs-keyword">in</span> mapping.items() <span class="hljs-keyword">if</span> <span class="hljs-string">'id'</span> <span class="hljs-keyword">not</span> <span class="hljs-keyword">in</span> k}

        existing_before = existing()
        needed_before = needed()
        dirty_recs_before, dirty_fname = dirty()
        dirty_recs_before[dirty_fname] = <span class="hljs-literal">False</span>
        <span class="hljs-keyword">yield</span>
        dirty_recs_after, dirty_fname = dirty()
        <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> dirty_recs_after:  <span class="hljs-comment"># TODO improve filter</span>
            <span class="hljs-keyword">return</span>
        existing_after = existing()
        needed_after = needed()

        <span class="hljs-comment"># Filter out deleted lines from `needed_before` to not recompute lines if not necessary or wanted</span>
        line_ids = <span class="hljs-built_in">set</span>(self.env[<span class="hljs-string">'account.move.line'</span>].browse(k[<span class="hljs-string">'id'</span>] <span class="hljs-keyword">for</span> k <span class="hljs-keyword">in</span> needed_before <span class="hljs-keyword">if</span> <span class="hljs-string">'id'</span> <span class="hljs-keyword">in</span> k).exists().ids)
        needed_before = {k: v <span class="hljs-keyword">for</span> k, v <span class="hljs-keyword">in</span> needed_before.items() <span class="hljs-keyword">if</span> <span class="hljs-string">'id'</span> <span class="hljs-keyword">not</span> <span class="hljs-keyword">in</span> k <span class="hljs-keyword">or</span> k[<span class="hljs-string">'id'</span>] <span class="hljs-keyword">in</span> line_ids}

        <span class="hljs-comment"># old key to new key for the same line</span>
        inv_existing_before = {v: k <span class="hljs-keyword">for</span> k, v <span class="hljs-keyword">in</span> existing_before.items()}
        inv_existing_after = {v: k <span class="hljs-keyword">for</span> k, v <span class="hljs-keyword">in</span> existing_after.items()}
        before2after = {
            before: inv_existing_after[bline]
            <span class="hljs-keyword">for</span> bline, before <span class="hljs-keyword">in</span> inv_existing_before.items()
            <span class="hljs-keyword">if</span> bline <span class="hljs-keyword">in</span> inv_existing_after
        }

        <span class="hljs-keyword">if</span> needed_after == needed_before:
            <span class="hljs-keyword">return</span>  <span class="hljs-comment"># do not modify user input if nothing changed in the needs</span>
        <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> needed_before <span class="hljs-keyword">and</span> (filter_trivial(existing_after) != filter_trivial(existing_before)):
            <span class="hljs-keyword">return</span>  <span class="hljs-comment"># do not modify user input if already created manually</span>

        to_delete = [
            line.<span class="hljs-built_in">id</span>
            <span class="hljs-keyword">for</span> key, line <span class="hljs-keyword">in</span> existing_before.items()
            <span class="hljs-keyword">if</span> key <span class="hljs-keyword">not</span> <span class="hljs-keyword">in</span> needed_after
            <span class="hljs-keyword">and</span> key <span class="hljs-keyword">in</span> existing_after
            <span class="hljs-keyword">and</span> before2after[key] <span class="hljs-keyword">not</span> <span class="hljs-keyword">in</span> needed_after
        ]
        to_delete_set = <span class="hljs-built_in">set</span>(to_delete)
        to_delete.extend(line.<span class="hljs-built_in">id</span>
            <span class="hljs-keyword">for</span> key, line <span class="hljs-keyword">in</span> existing_after.items()
            <span class="hljs-keyword">if</span> key <span class="hljs-keyword">not</span> <span class="hljs-keyword">in</span> needed_after <span class="hljs-keyword">and</span> line.<span class="hljs-built_in">id</span> <span class="hljs-keyword">not</span> <span class="hljs-keyword">in</span> to_delete_set
        )
        to_create = {
            key: values
            <span class="hljs-keyword">for</span> key, values <span class="hljs-keyword">in</span> needed_after.items()
            <span class="hljs-keyword">if</span> key <span class="hljs-keyword">not</span> <span class="hljs-keyword">in</span> existing_after
        }
        to_write = {
            existing_after[key]: values
            <span class="hljs-keyword">for</span> key, values <span class="hljs-keyword">in</span> needed_after.items()
            <span class="hljs-keyword">if</span> key <span class="hljs-keyword">in</span> existing_after
            <span class="hljs-keyword">and</span> <span class="hljs-built_in">any</span>(
                self.env[<span class="hljs-string">'account.move.line'</span>]._fields[fname].convert_to_write(existing_after[key][fname], self)
                != values[fname]
                <span class="hljs-keyword">for</span> fname <span class="hljs-keyword">in</span> values
            )
        }

        <span class="hljs-keyword">while</span> to_delete <span class="hljs-keyword">and</span> to_create:
            key, values = to_create.popitem()
            line_id = to_delete.pop()
            self.env[<span class="hljs-string">'account.move.line'</span>].browse(line_id).write(
                {**key, **values, <span class="hljs-string">'display_type'</span>: line_type}
            )
        <span class="hljs-keyword">if</span> to_delete:
            self.env[<span class="hljs-string">'account.move.line'</span>].browse(to_delete).with_context(dynamic_unlink=<span class="hljs-literal">True</span>).unlink()
        <span class="hljs-keyword">if</span> to_create:
            self.env[<span class="hljs-string">'account.move.line'</span>].create([
                {**key, **values, <span class="hljs-string">'display_type'</span>: line_type}
                <span class="hljs-keyword">for</span> key, values <span class="hljs-keyword">in</span> to_create.items()
            ])
        <span class="hljs-keyword">if</span> to_write:
            <span class="hljs-keyword">for</span> line, values <span class="hljs-keyword">in</span> to_write.items():
                line.write(values)

<span class="hljs-meta">    @contextmanager</span>
    <span class="hljs-keyword">def</span> <span class="hljs-title function_">_sync_invoice</span>(<span class="hljs-params">self, container</span>):
        <span class="hljs-keyword">def</span> <span class="hljs-title function_">existing</span>():
            <span class="hljs-keyword">return</span> {
                move: {
                    <span class="hljs-string">'commercial_partner_id'</span>: move.commercial_partner_id,
                }
                <span class="hljs-keyword">for</span> move <span class="hljs-keyword">in</span> container[<span class="hljs-string">'records'</span>].filtered(<span class="hljs-keyword">lambda</span> m: m.is_invoice(<span class="hljs-literal">True</span>))
            }

        <span class="hljs-keyword">def</span> <span class="hljs-title function_">changed</span>(<span class="hljs-params">fname</span>):
            <span class="hljs-keyword">return</span> move <span class="hljs-keyword">not</span> <span class="hljs-keyword">in</span> before <span class="hljs-keyword">or</span> before[move][fname] != after[move][fname]

        before = existing()
        <span class="hljs-keyword">yield</span>
        after = existing()

        <span class="hljs-keyword">for</span> move <span class="hljs-keyword">in</span> after:
            <span class="hljs-keyword">if</span> changed(<span class="hljs-string">'commercial_partner_id'</span>):
                move.line_ids.partner_id = after[move][<span class="hljs-string">'commercial_partner_id'</span>]

<span class="hljs-meta">    @contextmanager</span>
    <span class="hljs-keyword">def</span> <span class="hljs-title function_">_sync_dynamic_lines</span>(<span class="hljs-params">self, container</span>):
        <span class="hljs-keyword">with</span> self._disable_recursion(container, <span class="hljs-string">'skip_invoice_sync'</span>) <span class="hljs-keyword">as</span> disabled:
            <span class="hljs-keyword">if</span> disabled:
                <span class="hljs-keyword">yield</span>
                <span class="hljs-keyword">return</span>
            <span class="hljs-keyword">def</span> <span class="hljs-title function_">update_containers</span>():
                <span class="hljs-comment"># Only invoice-like and journal entries in "auto tax mode" are synced</span>
                tax_container[<span class="hljs-string">'records'</span>] = container[<span class="hljs-string">'records'</span>].filtered(<span class="hljs-keyword">lambda</span> m: (m.is_invoice(<span class="hljs-literal">True</span>) <span class="hljs-keyword">or</span> m.line_ids.tax_ids <span class="hljs-keyword">and</span> <span class="hljs-keyword">not</span> m.tax_cash_basis_origin_move_id))
                invoice_container[<span class="hljs-string">'records'</span>] = container[<span class="hljs-string">'records'</span>].filtered(<span class="hljs-keyword">lambda</span> m: m.is_invoice(<span class="hljs-literal">True</span>))
                misc_container[<span class="hljs-string">'records'</span>] = container[<span class="hljs-string">'records'</span>].filtered(<span class="hljs-keyword">lambda</span> m: m.is_entry() <span class="hljs-keyword">and</span> <span class="hljs-keyword">not</span> m.tax_cash_basis_origin_move_id)

            tax_container, invoice_container, misc_container = ({} <span class="hljs-keyword">for</span> __ <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">3</span>))
            update_containers()
            <span class="hljs-keyword">with</span> ExitStack() <span class="hljs-keyword">as</span> stack:
                stack.enter_context(self._sync_dynamic_line(
                    existing_key_fname=<span class="hljs-string">'term_key'</span>,
                    needed_vals_fname=<span class="hljs-string">'needed_terms'</span>,
                    needed_dirty_fname=<span class="hljs-string">'needed_terms_dirty'</span>,
                    line_type=<span class="hljs-string">'payment_term'</span>,
                    container=invoice_container,
                ))
                stack.enter_context(self._sync_unbalanced_lines(misc_container))
                stack.enter_context(self._sync_rounding_lines(invoice_container))
                stack.enter_context(self._sync_dynamic_line(
                    existing_key_fname=<span class="hljs-string">'discount_allocation_key'</span>,
                    needed_vals_fname=<span class="hljs-string">'line_ids.discount_allocation_needed'</span>,
                    needed_dirty_fname=<span class="hljs-string">'line_ids.discount_allocation_dirty'</span>,
                    line_type=<span class="hljs-string">'discount'</span>,
                    container=invoice_container,
                ))
                stack.enter_context(self._sync_dynamic_line(
                    existing_key_fname=<span class="hljs-string">'tax_key'</span>,
                    needed_vals_fname=<span class="hljs-string">'line_ids.compute_all_tax'</span>,
                    needed_dirty_fname=<span class="hljs-string">'line_ids.compute_all_tax_dirty'</span>,
                    line_type=<span class="hljs-string">'tax'</span>,
                    container=tax_container,
                ))
                stack.enter_context(self._sync_dynamic_line(
                    existing_key_fname=<span class="hljs-string">'epd_key'</span>,
                    needed_vals_fname=<span class="hljs-string">'line_ids.epd_needed'</span>,
                    needed_dirty_fname=<span class="hljs-string">'line_ids.epd_dirty'</span>,
                    line_type=<span class="hljs-string">'epd'</span>,
                    container=invoice_container,
                ))
                stack.enter_context(self._sync_invoice(invoice_container))
                line_container = {<span class="hljs-string">'records'</span>: self.line_ids}
                <span class="hljs-keyword">with</span> self.line_ids._sync_invoice(line_container):
                    <span class="hljs-keyword">yield</span>
                    line_container[<span class="hljs-string">'records'</span>] = self.line_ids
                update_containers()

    <span class="hljs-comment"># -------------------------------------------------------------------------</span>
    <span class="hljs-comment"># LOW-LEVEL METHODS</span>
    <span class="hljs-comment"># -------------------------------------------------------------------------</span>

    <span class="hljs-keyword">def</span> <span class="hljs-title function_">check_field_access_rights</span>(<span class="hljs-params">self, operation, field_names</span>):
        result = <span class="hljs-built_in">super</span>().check_field_access_rights(operation, field_names)
        <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> field_names:
            weirdos = [<span class="hljs-string">'needed_terms'</span>, <span class="hljs-string">'quick_encoding_vals'</span>, <span class="hljs-string">'payment_term_details'</span>]
            result = [fname <span class="hljs-keyword">for</span> fname <span class="hljs-keyword">in</span> result <span class="hljs-keyword">if</span> fname <span class="hljs-keyword">not</span> <span class="hljs-keyword">in</span> weirdos]
        <span class="hljs-keyword">return</span> result

    <span class="hljs-keyword">def</span> <span class="hljs-title function_">copy_data</span>(<span class="hljs-params">self, default=<span class="hljs-literal">None</span></span>):
        data_list = <span class="hljs-built_in">super</span>().copy_data(default)
        <span class="hljs-keyword">for</span> move, data <span class="hljs-keyword">in</span> <span class="hljs-built_in">zip</span>(self, data_list):
            <span class="hljs-keyword">if</span> move.move_type <span class="hljs-keyword">in</span> (<span class="hljs-string">'out_invoice'</span>, <span class="hljs-string">'in_invoice'</span>):
                data[<span class="hljs-string">'line_ids'</span>] = [
                    (command, _<span class="hljs-built_in">id</span>, line_vals)
                    <span class="hljs-keyword">for</span> command, _<span class="hljs-built_in">id</span>, line_vals <span class="hljs-keyword">in</span> data[<span class="hljs-string">'line_ids'</span>]
                    <span class="hljs-keyword">if</span> command == Command.CREATE
                ]
            <span class="hljs-keyword">elif</span> move.move_type == <span class="hljs-string">'entry'</span>:
                <span class="hljs-keyword">if</span> <span class="hljs-string">'partner_id'</span> <span class="hljs-keyword">not</span> <span class="hljs-keyword">in</span> data:
                    data[<span class="hljs-string">'partner_id'</span>] = <span class="hljs-literal">False</span>
        <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> self.journal_id.active <span class="hljs-keyword">and</span> <span class="hljs-string">'journal_id'</span> <span class="hljs-keyword">in</span> data_list:
            <span class="hljs-keyword">del</span> default[<span class="hljs-string">'journal_id'</span>]
        <span class="hljs-keyword">return</span> data_list

<span class="hljs-meta">    @api.returns(<span class="hljs-params"><span class="hljs-string">'self'</span>, <span class="hljs-keyword">lambda</span> value: value.<span class="hljs-built_in">id</span></span>)</span>
    <span class="hljs-keyword">def</span> <span class="hljs-title function_">copy</span>(<span class="hljs-params">self, default=<span class="hljs-literal">None</span></span>):
        default = <span class="hljs-built_in">dict</span>(default <span class="hljs-keyword">or</span> {})
        <span class="hljs-keyword">if</span> (fields.Date.to_date(default.get(<span class="hljs-string">'date'</span>)) <span class="hljs-keyword">or</span> self.date) &lt;= self.company_id._get_user_fiscal_lock_date():
            default[<span class="hljs-string">'date'</span>] = self.company_id._get_user_fiscal_lock_date() + timedelta(days=<span class="hljs-number">1</span>)
        copied_am = <span class="hljs-built_in">super</span>().copy(default)
        message_origin = <span class="hljs-string">''</span> <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> copied_am.auto_post_origin_id <span class="hljs-keyword">else</span> \
            (Markup(<span class="hljs-string">'&lt;br/&gt;'</span>) + _(<span class="hljs-string">'This recurring entry originated from %s'</span>, copied_am.auto_post_origin_id._get_html_link()))
        message_content = _(<span class="hljs-string">'This entry has been reversed from %s'</span>, self._get_html_link()) <span class="hljs-keyword">if</span> default.get(<span class="hljs-string">'reversed_entry_id'</span>) <span class="hljs-keyword">else</span> _(<span class="hljs-string">'This entry has been duplicated from %s'</span>, self._get_html_link())
        copied_am._message_log(body=message_content + message_origin)

        <span class="hljs-keyword">return</span> copied_am

    <span class="hljs-keyword">def</span> <span class="hljs-title function_">_sanitize_vals</span>(<span class="hljs-params">self, vals</span>):
        <span class="hljs-keyword">if</span> vals.get(<span class="hljs-string">'invoice_line_ids'</span>) <span class="hljs-keyword">and</span> vals.get(<span class="hljs-string">'line_ids'</span>):
            <span class="hljs-comment"># values can sometimes be in only one of the two fields, sometimes in</span>
            <span class="hljs-comment"># both fields, sometimes one field can be explicitely empty while the other</span>
            <span class="hljs-comment"># one is not, sometimes not...</span>
            update_vals = {
                line_id: line_vals[<span class="hljs-number">0</span>]
                <span class="hljs-keyword">for</span> command, line_id, *line_vals <span class="hljs-keyword">in</span> vals[<span class="hljs-string">'invoice_line_ids'</span>]
                <span class="hljs-keyword">if</span> command == Command.UPDATE
            }
            <span class="hljs-keyword">for</span> command, line_id, line_vals <span class="hljs-keyword">in</span> vals[<span class="hljs-string">'line_ids'</span>]:
                <span class="hljs-keyword">if</span> command == Command.UPDATE <span class="hljs-keyword">and</span> line_id <span class="hljs-keyword">in</span> update_vals:
                    line_vals.update(update_vals.pop(line_id))
            <span class="hljs-keyword">for</span> line_id, line_vals <span class="hljs-keyword">in</span> update_vals.items():
                vals[<span class="hljs-string">'line_ids'</span>] += [Command.update(line_id, line_vals)]
            <span class="hljs-keyword">for</span> command, line_id, *line_vals <span class="hljs-keyword">in</span> vals[<span class="hljs-string">'invoice_line_ids'</span>]:
                <span class="hljs-keyword">assert</span> command <span class="hljs-keyword">not</span> <span class="hljs-keyword">in</span> (Command.SET, Command.CLEAR)
                <span class="hljs-keyword">if</span> [command, line_id, *line_vals] <span class="hljs-keyword">not</span> <span class="hljs-keyword">in</span> vals[<span class="hljs-string">'line_ids'</span>]:
                    vals[<span class="hljs-string">'line_ids'</span>] += [(command, line_id, *line_vals)]
            <span class="hljs-keyword">del</span> vals[<span class="hljs-string">'invoice_line_ids'</span>]
        <span class="hljs-keyword">return</span> vals

    <span class="hljs-keyword">def</span> <span class="hljs-title function_">_stolen_move</span>(<span class="hljs-params">self, vals</span>):
        <span class="hljs-keyword">for</span> command <span class="hljs-keyword">in</span> vals.get(<span class="hljs-string">'line_ids'</span>, ()):
            <span class="hljs-keyword">if</span> command[<span class="hljs-number">0</span>] == Command.LINK:
                <span class="hljs-keyword">yield</span> self.env[<span class="hljs-string">'account.move.line'</span>].browse(command[<span class="hljs-number">1</span>]).move_id.<span class="hljs-built_in">id</span>
            <span class="hljs-keyword">if</span> command[<span class="hljs-number">0</span>] == Command.SET:
                <span class="hljs-keyword">yield</span> <span class="hljs-keyword">from</span> self.env[<span class="hljs-string">'account.move.line'</span>].browse(command[<span class="hljs-number">2</span>]).move_id.ids

<span class="hljs-meta">    @api.model_create_multi</span>
    <span class="hljs-keyword">def</span> <span class="hljs-title function_">create</span>(<span class="hljs-params">self, vals_list</span>):
        <span class="hljs-keyword">if</span> <span class="hljs-built_in">any</span>(<span class="hljs-string">'state'</span> <span class="hljs-keyword">in</span> vals <span class="hljs-keyword">and</span> vals.get(<span class="hljs-string">'state'</span>) == <span class="hljs-string">'posted'</span> <span class="hljs-keyword">for</span> vals <span class="hljs-keyword">in</span> vals_list):
            <span class="hljs-keyword">raise</span> UserError(_(<span class="hljs-string">'You cannot create a move already in the posted state. Please create a draft move and post it after.'</span>))
        container = {<span class="hljs-string">'records'</span>: self}
        <span class="hljs-keyword">with</span> self._check_balanced(container):
            <span class="hljs-keyword">with</span> self._sync_dynamic_lines(container):
                <span class="hljs-keyword">for</span> vals <span class="hljs-keyword">in</span> vals_list:
                    self._sanitize_vals(vals)
                stolen_moves = self.browse(<span class="hljs-built_in">set</span>(move <span class="hljs-keyword">for</span> vals <span class="hljs-keyword">in</span> vals_list <span class="hljs-keyword">for</span> move <span class="hljs-keyword">in</span> self._stolen_move(vals)))
                moves = <span class="hljs-built_in">super</span>().create(vals_list)
                container[<span class="hljs-string">'records'</span>] = moves | stolen_moves
            <span class="hljs-keyword">for</span> move, vals <span class="hljs-keyword">in</span> <span class="hljs-built_in">zip</span>(moves, vals_list):
                <span class="hljs-keyword">if</span> <span class="hljs-string">'tax_totals'</span> <span class="hljs-keyword">in</span> vals:
                    move.tax_totals = vals[<span class="hljs-string">'tax_totals'</span>]
        <span class="hljs-keyword">return</span> moves

    <span class="hljs-keyword">def</span> <span class="hljs-title function_">write</span>(<span class="hljs-params">self, vals</span>):
        <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> vals:
            <span class="hljs-keyword">return</span> <span class="hljs-literal">True</span>
        self._sanitize_vals(vals)
        <span class="hljs-keyword">for</span> move <span class="hljs-keyword">in</span> self:
            <span class="hljs-keyword">if</span> (move.restrict_mode_hash_table <span class="hljs-keyword">and</span> move.state == <span class="hljs-string">"posted"</span> <span class="hljs-keyword">and</span> <span class="hljs-built_in">set</span>(vals).intersection(move._get_integrity_hash_fields())):
                <span class="hljs-keyword">raise</span> UserError(_(<span class="hljs-string">"You cannot edit the following fields due to restrict mode being activated on the journal: %s."</span>, <span class="hljs-string">', '</span>.join(move._get_integrity_hash_fields())))
            <span class="hljs-keyword">if</span> (move.restrict_mode_hash_table <span class="hljs-keyword">and</span> move.inalterable_hash <span class="hljs-keyword">and</span> <span class="hljs-string">'inalterable_hash'</span> <span class="hljs-keyword">in</span> vals) <span class="hljs-keyword">or</span> (move.secure_sequence_number <span class="hljs-keyword">and</span> <span class="hljs-string">'secure_sequence_number'</span> <span class="hljs-keyword">in</span> vals):
                <span class="hljs-keyword">raise</span> UserError(_(<span class="hljs-string">'You cannot overwrite the values ensuring the inalterability of the accounting.'</span>))
            <span class="hljs-keyword">if</span> (move.posted_before <span class="hljs-keyword">and</span> <span class="hljs-string">'journal_id'</span> <span class="hljs-keyword">in</span> vals <span class="hljs-keyword">and</span> move.journal_id.<span class="hljs-built_in">id</span> != vals[<span class="hljs-string">'journal_id'</span>]):
                <span class="hljs-keyword">raise</span> UserError(_(<span class="hljs-string">'You cannot edit the journal of an account move if it has been posted once.'</span>))
            <span class="hljs-keyword">if</span> (move.name <span class="hljs-keyword">and</span> move.name != <span class="hljs-string">'/'</span> <span class="hljs-keyword">and</span> move.sequence_number <span class="hljs-keyword">not</span> <span class="hljs-keyword">in</span> (<span class="hljs-number">0</span>, <span class="hljs-number">1</span>) <span class="hljs-keyword">and</span> <span class="hljs-string">'journal_id'</span> <span class="hljs-keyword">in</span> vals <span class="hljs-keyword">and</span> move.journal_id.<span class="hljs-built_in">id</span> != vals[<span class="hljs-string">'journal_id'</span>]):
                <span class="hljs-keyword">raise</span> UserError(_(<span class="hljs-string">'You cannot edit the journal of an account move if it already has a sequence number assigned.'</span>))

            <span class="hljs-comment"># You can't change the date or name of a move being inside a locked period.</span>
            <span class="hljs-keyword">if</span> move.state == <span class="hljs-string">"posted"</span> <span class="hljs-keyword">and</span> (
                    (<span class="hljs-string">'name'</span> <span class="hljs-keyword">in</span> vals <span class="hljs-keyword">and</span> move.name != vals[<span class="hljs-string">'name'</span>])
                    <span class="hljs-keyword">or</span> (<span class="hljs-string">'date'</span> <span class="hljs-keyword">in</span> vals <span class="hljs-keyword">and</span> move.date != vals[<span class="hljs-string">'date'</span>])
            ):
                move._check_fiscalyear_lock_date()
                move.line_ids._check_tax_lock_date()

            <span class="hljs-comment"># You can't post subtract a move to a locked period.</span>
            <span class="hljs-keyword">if</span> <span class="hljs-string">'state'</span> <span class="hljs-keyword">in</span> vals <span class="hljs-keyword">and</span> move.state == <span class="hljs-string">'posted'</span> <span class="hljs-keyword">and</span> vals[<span class="hljs-string">'state'</span>] != <span class="hljs-string">'posted'</span>:
                move._check_fiscalyear_lock_date()
                move.line_ids._check_tax_lock_date()

            <span class="hljs-keyword">if</span> move.journal_id.sequence_override_regex <span class="hljs-keyword">and</span> vals.get(<span class="hljs-string">'name'</span>) <span class="hljs-keyword">and</span> vals[<span class="hljs-string">'name'</span>] != <span class="hljs-string">'/'</span> <span class="hljs-keyword">and</span> <span class="hljs-keyword">not</span> re.<span class="hljs-keyword">match</span>(move.journal_id.sequence_override_regex, vals[<span class="hljs-string">'name'</span>]):
                <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> self.env.user.has_group(<span class="hljs-string">'account.group_account_manager'</span>):
                    <span class="hljs-keyword">raise</span> UserError(_(<span class="hljs-string">'The Journal Entry sequence is not conform to the current format. Only the Accountant can change it.'</span>))
                move.journal_id.sequence_override_regex = <span class="hljs-literal">False</span>

        to_protect = []
        <span class="hljs-keyword">for</span> fname <span class="hljs-keyword">in</span> vals:
            field = self._fields[fname]
            <span class="hljs-keyword">if</span> field.compute <span class="hljs-keyword">and</span> <span class="hljs-keyword">not</span> field.readonly:
                to_protect.append(field)
        stolen_moves = self.browse(<span class="hljs-built_in">set</span>(move <span class="hljs-keyword">for</span> move <span class="hljs-keyword">in</span> self._stolen_move(vals)))
        container = {<span class="hljs-string">'records'</span>: self | stolen_moves}
        <span class="hljs-keyword">with</span> self.env.protecting(to_protect, self), self._check_balanced(container):
            <span class="hljs-keyword">with</span> self._sync_dynamic_lines(container):
                res = <span class="hljs-built_in">super</span>(AccountMove, self.with_context(
                    skip_account_move_synchronization=<span class="hljs-literal">True</span>,
                )).write(vals)


                <span class="hljs-comment"># Reset the name of draft moves when changing the journal.</span>
                <span class="hljs-comment"># Protected against holes in the pre-validation checks.</span>
                <span class="hljs-keyword">if</span> <span class="hljs-string">'journal_id'</span> <span class="hljs-keyword">in</span> vals <span class="hljs-keyword">and</span> <span class="hljs-string">'name'</span> <span class="hljs-keyword">not</span> <span class="hljs-keyword">in</span> vals:
                    self.name = <span class="hljs-literal">False</span>
                    self._compute_name()

                <span class="hljs-comment"># You can't change the date of a not-locked move to a locked period.</span>
                <span class="hljs-comment"># You can't post a new journal entry inside a locked period.</span>
                <span class="hljs-keyword">if</span> <span class="hljs-string">'date'</span> <span class="hljs-keyword">in</span> vals <span class="hljs-keyword">or</span> <span class="hljs-string">'state'</span> <span class="hljs-keyword">in</span> vals:
                    posted_move = self.filtered(<span class="hljs-keyword">lambda</span> m: m.state == <span class="hljs-string">'posted'</span>)
                    posted_move._check_fiscalyear_lock_date()
                    posted_move.line_ids._check_tax_lock_date()

                <span class="hljs-comment"># Hash the move</span>
                <span class="hljs-keyword">if</span> vals.get(<span class="hljs-string">'state'</span>) == <span class="hljs-string">'posted'</span>:
                    self.flush_recordset()  <span class="hljs-comment"># Ensure that the name is correctly computed before it is used to generate the hash</span>
                    <span class="hljs-keyword">for</span> move <span class="hljs-keyword">in</span> self.filtered(<span class="hljs-keyword">lambda</span> m: m.restrict_mode_hash_table <span class="hljs-keyword">and</span> <span class="hljs-keyword">not</span>(m.secure_sequence_number <span class="hljs-keyword">or</span> m.inalterable_hash)).<span class="hljs-built_in">sorted</span>(<span class="hljs-keyword">lambda</span> m: (m.date, m.ref <span class="hljs-keyword">or</span> <span class="hljs-string">''</span>, m.<span class="hljs-built_in">id</span>)):
                        new_number = move.journal_id.secure_sequence_id.next_by_id()
                        res |= <span class="hljs-built_in">super</span>(AccountMove, move).write({
                            <span class="hljs-string">'secure_sequence_number'</span>: new_number,
                            <span class="hljs-string">'inalterable_hash'</span>: move._get_new_hash(new_number),
                        })

            self._synchronize_business_models(<span class="hljs-built_in">set</span>(vals.keys()))

            <span class="hljs-comment"># Apply the rounding on the Quick Edit mode only when adding a new line</span>
            <span class="hljs-keyword">for</span> move <span class="hljs-keyword">in</span> self:
                <span class="hljs-keyword">if</span> <span class="hljs-string">'tax_totals'</span> <span class="hljs-keyword">in</span> vals:
                    <span class="hljs-built_in">super</span>(AccountMove, move).write({<span class="hljs-string">'tax_totals'</span>: vals[<span class="hljs-string">'tax_totals'</span>]})
        <span class="hljs-keyword">if</span> <span class="hljs-string">'journal_id'</span> <span class="hljs-keyword">in</span> vals:
            self.line_ids._check_constrains_account_id_journal_id()

        <span class="hljs-keyword">return</span> res

    <span class="hljs-keyword">def</span> <span class="hljs-title function_">check_move_sequence_chain</span>(<span class="hljs-params">self</span>):
        <span class="hljs-keyword">return</span> self.filtered(<span class="hljs-keyword">lambda</span> move: move.name != <span class="hljs-string">'/'</span>)._is_end_of_seq_chain()

<span class="hljs-meta">    @api.ondelete(<span class="hljs-params">at_uninstall=<span class="hljs-literal">False</span></span>)</span>
    <span class="hljs-keyword">def</span> <span class="hljs-title function_">_unlink_forbid_parts_of_chain</span>(<span class="hljs-params">self</span>):
        <span class="hljs-string">""" For a user with Billing/Bookkeeper rights, when the fidu mode is deactivated,
        moves with a sequence number can only be deleted if they are the last element of a chain of sequence.
        If they are not, deleting them would create a gap. If the user really wants to do this, he still can
        explicitly empty the 'name' field of the move; but we discourage that practice.
        If a user is a Billing Administrator/Accountant or if fidu mode is activated, we show a warning,
        but they can delete the moves even if it creates a sequence gap.
        """</span>
        <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> (
            self.user_has_groups(<span class="hljs-string">'account.group_account_manager'</span>)
            <span class="hljs-keyword">or</span> self.company_id.quick_edit_mode
            <span class="hljs-keyword">or</span> self._context.get(<span class="hljs-string">'force_delete'</span>)
            <span class="hljs-keyword">or</span> self.check_move_sequence_chain()
        ):
            <span class="hljs-keyword">raise</span> UserError(_(
                <span class="hljs-string">"You cannot delete this entry, as it has already consumed a sequence number and is not the last one in the chain. "</span>
                <span class="hljs-string">"You should probably revert it instead."</span>
            ))

    <span class="hljs-keyword">def</span> <span class="hljs-title function_">unlink</span>(<span class="hljs-params">self</span>):
        self = self.with_context(skip_invoice_sync=<span class="hljs-literal">True</span>, dynamic_unlink=<span class="hljs-literal">True</span>)  <span class="hljs-comment"># no need to sync to delete everything</span>
        self.line_ids.unlink()
        <span class="hljs-keyword">return</span> <span class="hljs-built_in">super</span>().unlink()

<span class="hljs-meta">    @api.depends(<span class="hljs-params"><span class="hljs-string">'partner_id'</span>, <span class="hljs-string">'date'</span>, <span class="hljs-string">'state'</span>, <span class="hljs-string">'move_type'</span></span>)</span>
<span class="hljs-meta">    @api.depends_context(<span class="hljs-params"><span class="hljs-string">'input_full_display_name'</span></span>)</span>
    <span class="hljs-keyword">def</span> <span class="hljs-title function_">_compute_display_name</span>(<span class="hljs-params">self</span>):
        <span class="hljs-keyword">for</span> move <span class="hljs-keyword">in</span> self:
            move.display_name = move._get_move_display_name(show_ref=<span class="hljs-literal">True</span>)

    <span class="hljs-keyword">def</span> <span class="hljs-title function_">onchange</span>(<span class="hljs-params">self, values, field_names, fields_spec</span>):
        <span class="hljs-comment"># Since only one field can be changed at the same time (the record is</span>
        <span class="hljs-comment"># saved when changing tabs) we can avoid building the snapshots for the</span>
        <span class="hljs-comment"># other field</span>
        <span class="hljs-keyword">if</span> <span class="hljs-string">'line_ids'</span> <span class="hljs-keyword">in</span> field_names:
            values = {key: val <span class="hljs-keyword">for</span> key, val <span class="hljs-keyword">in</span> values.items() <span class="hljs-keyword">if</span> key != <span class="hljs-string">'invoice_line_ids'</span>}
            fields_spec = {key: val <span class="hljs-keyword">for</span> key, val <span class="hljs-keyword">in</span> fields_spec.items() <span class="hljs-keyword">if</span> key != <span class="hljs-string">'invoice_line_ids'</span>}
        <span class="hljs-keyword">elif</span> <span class="hljs-string">'invoice_line_ids'</span> <span class="hljs-keyword">in</span> field_names:
            values = {key: val <span class="hljs-keyword">for</span> key, val <span class="hljs-keyword">in</span> values.items() <span class="hljs-keyword">if</span> key != <span class="hljs-string">'line_ids'</span>}
            fields_spec = {key: val <span class="hljs-keyword">for</span> key, val <span class="hljs-keyword">in</span> fields_spec.items() <span class="hljs-keyword">if</span> key != <span class="hljs-string">'line_ids'</span>}
        <span class="hljs-keyword">return</span> <span class="hljs-built_in">super</span>().onchange(values, field_names, fields_spec)

    <span class="hljs-comment"># -------------------------------------------------------------------------</span>
    <span class="hljs-comment"># RECONCILIATION METHODS</span>
    <span class="hljs-comment"># -------------------------------------------------------------------------</span>

    <span class="hljs-keyword">def</span> <span class="hljs-title function_">_collect_tax_cash_basis_values</span>(<span class="hljs-params">self</span>):
        <span class="hljs-string">''' Collect all information needed to create the tax cash basis journal entries:
        - Determine if a tax cash basis journal entry is needed.
        - Compute the lines to be processed and the amounts needed to compute a percentage.
        :return: A dictionary:
            * move:                     The current account.move record passed as parameter.
            * to_process_lines:         A tuple (caba_treatment, line) where:
                                            - caba_treatment is either 'tax' or 'base', depending on what should
                                              be considered on the line when generating the caba entry.
                                              For example, a line with tax_ids=caba and tax_line_id=non_caba
                                              will have a 'base' caba treatment, as we only want to treat its base
                                              part in the caba entry (the tax part is already exigible on the invoice)

                                            - line is an account.move.line record being not exigible on the tax report.
            * currency:                 The currency on which the percentage has been computed.
            * total_balance:            sum(payment_term_lines.mapped('balance').
            * total_residual:           sum(payment_term_lines.mapped('amount_residual').
            * total_amount_currency:    sum(payment_term_lines.mapped('amount_currency').
            * total_residual_currency:  sum(payment_term_lines.mapped('amount_residual_currency').
            * is_fully_paid:            A flag indicating the current move is now fully paid.
        '''</span>
        self.ensure_one()

        values = {
            <span class="hljs-string">'move'</span>: self,
            <span class="hljs-string">'to_process_lines'</span>: [],
            <span class="hljs-string">'total_balance'</span>: <span class="hljs-number">0.0</span>,
            <span class="hljs-string">'total_residual'</span>: <span class="hljs-number">0.0</span>,
            <span class="hljs-string">'total_amount_currency'</span>: <span class="hljs-number">0.0</span>,
            <span class="hljs-string">'total_residual_currency'</span>: <span class="hljs-number">0.0</span>,
        }

        currencies = <span class="hljs-built_in">set</span>()
        has_term_lines = <span class="hljs-literal">False</span>
        <span class="hljs-keyword">for</span> line <span class="hljs-keyword">in</span> self.line_ids:
            <span class="hljs-keyword">if</span> line.account_type <span class="hljs-keyword">in</span> (<span class="hljs-string">'asset_receivable'</span>, <span class="hljs-string">'liability_payable'</span>):
                sign = <span class="hljs-number">1</span> <span class="hljs-keyword">if</span> line.balance &gt; <span class="hljs-number">0.0</span> <span class="hljs-keyword">else</span> -<span class="hljs-number">1</span>

                currencies.add(line.currency_id)
                has_term_lines = <span class="hljs-literal">True</span>
                values[<span class="hljs-string">'total_balance'</span>] += sign * line.balance
                values[<span class="hljs-string">'total_residual'</span>] += sign * line.amount_residual
                values[<span class="hljs-string">'total_amount_currency'</span>] += sign * line.amount_currency
                values[<span class="hljs-string">'total_residual_currency'</span>] += sign * line.amount_residual_currency

            <span class="hljs-keyword">elif</span> line.tax_line_id.tax_exigibility == <span class="hljs-string">'on_payment'</span>:
                values[<span class="hljs-string">'to_process_lines'</span>].append((<span class="hljs-string">'tax'</span>, line))
                currencies.add(line.currency_id)

            <span class="hljs-keyword">elif</span> <span class="hljs-string">'on_payment'</span> <span class="hljs-keyword">in</span> line.tax_ids.flatten_taxes_hierarchy().mapped(<span class="hljs-string">'tax_exigibility'</span>):
                values[<span class="hljs-string">'to_process_lines'</span>].append((<span class="hljs-string">'base'</span>, line))
                currencies.add(line.currency_id)

        <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> values[<span class="hljs-string">'to_process_lines'</span>] <span class="hljs-keyword">or</span> <span class="hljs-keyword">not</span> has_term_lines:
            <span class="hljs-keyword">return</span> <span class="hljs-literal">None</span>

        <span class="hljs-comment"># Compute the currency on which made the percentage.</span>
        <span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(currencies) == <span class="hljs-number">1</span>:
            values[<span class="hljs-string">'currency'</span>] = <span class="hljs-built_in">list</span>(currencies)[<span class="hljs-number">0</span>]
        <span class="hljs-keyword">else</span>:
            <span class="hljs-comment"># Don't support the case where there is multiple involved currencies.</span>
            <span class="hljs-keyword">return</span> <span class="hljs-literal">None</span>

        <span class="hljs-comment"># Determine whether the move is now fully paid.</span>
        values[<span class="hljs-string">'is_fully_paid'</span>] = self.company_id.currency_id.is_zero(values[<span class="hljs-string">'total_residual'</span>]) \
                                  <span class="hljs-keyword">or</span> values[<span class="hljs-string">'currency'</span>].is_zero(values[<span class="hljs-string">'total_residual_currency'</span>])

        <span class="hljs-keyword">return</span> values

    <span class="hljs-comment"># -------------------------------------------------------------------------</span>
    <span class="hljs-comment"># SEQUENCE MIXIN</span>
    <span class="hljs-comment"># -------------------------------------------------------------------------</span>

    <span class="hljs-keyword">def</span> <span class="hljs-title function_">_must_check_constrains_date_sequence</span>(<span class="hljs-params">self</span>):
        <span class="hljs-comment"># OVERRIDES sequence.mixin</span>
        <span class="hljs-keyword">return</span> self.state == <span class="hljs-string">'posted'</span> <span class="hljs-keyword">and</span> <span class="hljs-keyword">not</span> self.quick_edit_mode

    <span class="hljs-keyword">def</span> <span class="hljs-title function_">_get_last_sequence_domain</span>(<span class="hljs-params">self, relaxed=<span class="hljs-literal">False</span></span>):
        <span class="hljs-comment">#pylint: disable=sql-injection</span>
        <span class="hljs-comment"># EXTENDS account sequence.mixin</span>
        self.ensure_one()
        <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> self.date <span class="hljs-keyword">or</span> <span class="hljs-keyword">not</span> self.journal_id:
            <span class="hljs-keyword">return</span> <span class="hljs-string">"WHERE FALSE"</span>, {}
        where_string = <span class="hljs-string">"WHERE journal_id = %(journal_id)s AND name != '/'"</span>
        param = {<span class="hljs-string">'journal_id'</span>: self.journal_id.<span class="hljs-built_in">id</span>}

        <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> relaxed:
            domain = [(<span class="hljs-string">'journal_id'</span>, <span class="hljs-string">'='</span>, self.journal_id.<span class="hljs-built_in">id</span>), (<span class="hljs-string">'id'</span>, <span class="hljs-string">'!='</span>, self.<span class="hljs-built_in">id</span> <span class="hljs-keyword">or</span> self._origin.<span class="hljs-built_in">id</span>), (<span class="hljs-string">'name'</span>, <span class="hljs-string">'not in'</span>, (<span class="hljs-string">'/'</span>, <span class="hljs-string">''</span>, <span class="hljs-literal">False</span>))]
            <span class="hljs-keyword">if</span> self.journal_id.refund_sequence:
                refund_types = (<span class="hljs-string">'out_refund'</span>, <span class="hljs-string">'in_refund'</span>)
                domain += [(<span class="hljs-string">'move_type'</span>, <span class="hljs-string">'in'</span> <span class="hljs-keyword">if</span> self.move_type <span class="hljs-keyword">in</span> refund_types <span class="hljs-keyword">else</span> <span class="hljs-string">'not in'</span>, refund_types)]
            <span class="hljs-keyword">if</span> self.journal_id.payment_sequence:
                domain += [(<span class="hljs-string">'payment_id'</span>, <span class="hljs-string">'!='</span> <span class="hljs-keyword">if</span> self.payment_id <span class="hljs-keyword">else</span> <span class="hljs-string">'='</span>, <span class="hljs-literal">False</span>)]
            reference_move_name = self.sudo().search(domain + [(<span class="hljs-string">'date'</span>, <span class="hljs-string">'&lt;='</span>, self.date)], order=<span class="hljs-string">'date desc'</span>, limit=<span class="hljs-number">1</span>).name
            <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> reference_move_name:
                reference_move_name = self.sudo().search(domain, order=<span class="hljs-string">'date asc'</span>, limit=<span class="hljs-number">1</span>).name
            sequence_number_reset = self._deduce_sequence_number_reset(reference_move_name)
            date_start, date_end = self._get_sequence_date_range(sequence_number_reset)
            where_string += <span class="hljs-string">""" AND date BETWEEN %(date_start)s AND %(date_end)s"""</span>
            param[<span class="hljs-string">'date_start'</span>] = date_start
            param[<span class="hljs-string">'date_end'</span>] = date_end
            <span class="hljs-keyword">if</span> sequence_number_reset <span class="hljs-keyword">in</span> (<span class="hljs-string">'year'</span>, <span class="hljs-string">'year_range'</span>):
                param[<span class="hljs-string">'anti_regex'</span>] = re.sub(<span class="hljs-string">r"\?P&lt;\w+&gt;"</span>, <span class="hljs-string">"?:"</span>, self._sequence_monthly_regex.split(<span class="hljs-string">'(?P&lt;seq&gt;'</span>)[<span class="hljs-number">0</span>]) + <span class="hljs-string">'$'</span>
            <span class="hljs-keyword">elif</span> sequence_number_reset == <span class="hljs-string">'never'</span>:
                param[<span class="hljs-string">'anti_regex'</span>] = re.sub(<span class="hljs-string">r"\?P&lt;\w+&gt;"</span>, <span class="hljs-string">"?:"</span>, self._sequence_yearly_regex.split(<span class="hljs-string">'(?P&lt;seq&gt;'</span>)[<span class="hljs-number">0</span>]) + <span class="hljs-string">'$'</span>

            <span class="hljs-keyword">if</span> param.get(<span class="hljs-string">'anti_regex'</span>) <span class="hljs-keyword">and</span> <span class="hljs-keyword">not</span> self.journal_id.sequence_override_regex:
                where_string += <span class="hljs-string">" AND sequence_prefix !~ %(anti_regex)s "</span>

        <span class="hljs-keyword">if</span> self.journal_id.refund_sequence:
            <span class="hljs-keyword">if</span> self.move_type <span class="hljs-keyword">in</span> (<span class="hljs-string">'out_refund'</span>, <span class="hljs-string">'in_refund'</span>):
                where_string += <span class="hljs-string">" AND move_type IN ('out_refund', 'in_refund') "</span>
            <span class="hljs-keyword">else</span>:
                where_string += <span class="hljs-string">" AND move_type NOT IN ('out_refund', 'in_refund') "</span>
        <span class="hljs-keyword">elif</span> self.journal_id.payment_sequence:
            <span class="hljs-keyword">if</span> self.payment_id:
                where_string += <span class="hljs-string">" AND payment_id IS NOT NULL "</span>
            <span class="hljs-keyword">else</span>:
                where_string += <span class="hljs-string">" AND payment_id IS NULL "</span>

        <span class="hljs-keyword">return</span> where_string, param

    <span class="hljs-keyword">def</span> <span class="hljs-title function_">_get_starting_sequence</span>(<span class="hljs-params">self</span>):
        <span class="hljs-comment"># EXTENDS account sequence.mixin</span>
        self.ensure_one()
        <span class="hljs-keyword">if</span> self.journal_id.<span class="hljs-built_in">type</span> <span class="hljs-keyword">in</span> [<span class="hljs-string">'sale'</span>, <span class="hljs-string">'bank'</span>, <span class="hljs-string">'cash'</span>]:
            starting_sequence = <span class="hljs-string">"%s/%04d/00000"</span> % (self.journal_id.code, self.date.year)
        <span class="hljs-keyword">else</span>:
            starting_sequence = <span class="hljs-string">"%s/%04d/%02d/0000"</span> % (self.journal_id.code, self.date.year, self.date.month)
        <span class="hljs-keyword">if</span> self.journal_id.refund_sequence <span class="hljs-keyword">and</span> self.move_type <span class="hljs-keyword">in</span> (<span class="hljs-string">'out_refund'</span>, <span class="hljs-string">'in_refund'</span>):
            starting_sequence = <span class="hljs-string">"R"</span> + starting_sequence
        <span class="hljs-keyword">if</span> self.journal_id.payment_sequence <span class="hljs-keyword">and</span> self.payment_id:
            starting_sequence = <span class="hljs-string">"P"</span> + starting_sequence
        <span class="hljs-keyword">return</span> starting_sequence

    <span class="hljs-keyword">def</span> <span class="hljs-title function_">_get_sequence_date_range</span>(<span class="hljs-params">self, reset</span>):
        <span class="hljs-keyword">if</span> reset == <span class="hljs-string">'year_range'</span>:
            company = self.company_id
            <span class="hljs-keyword">return</span> date_utils.get_fiscal_year(self.date, day=company.fiscalyear_last_day, month=<span class="hljs-built_in">int</span>(company.fiscalyear_last_month))
        <span class="hljs-keyword">return</span> <span class="hljs-built_in">super</span>()._get_sequence_date_range(reset)

    <span class="hljs-comment"># -------------------------------------------------------------------------</span>
    <span class="hljs-comment"># PAYMENT REFERENCE</span>
    <span class="hljs-comment"># -------------------------------------------------------------------------</span>

    <span class="hljs-keyword">def</span> <span class="hljs-title function_">_get_invoice_reference_euro_invoice</span>(<span class="hljs-params">self</span>):
        <span class="hljs-string">""" This computes the reference based on the RF Creditor Reference.
            The data of the reference is the database id number of the invoice.
            For instance, if an invoice is issued with id 43, the check number
            is 07 so the reference will be 'RF07 43'.
        """</span>
        self.ensure_one()
        <span class="hljs-keyword">return</span> format_structured_reference_iso(self.<span class="hljs-built_in">id</span>)

    <span class="hljs-keyword">def</span> <span class="hljs-title function_">_get_invoice_reference_euro_partner</span>(<span class="hljs-params">self</span>):
        <span class="hljs-string">""" This computes the reference based on the RF Creditor Reference.
            The data of the reference is the user defined reference of the
            partner or the database id number of the parter.
            For instance, if an invoice is issued for the partner with internal
            reference 'food buyer 654', the digits will be extracted and used as
            the data. This will lead to a check number equal to 00 and the
            reference will be 'RF00 654'.
            If no reference is set for the partner, its id in the database will
            be used.
        """</span>
        self.ensure_one()
        partner_ref = self.partner_id.ref
        partner_ref_nr = re.sub(<span class="hljs-string">r'\D'</span>, <span class="hljs-string">''</span>, partner_ref <span class="hljs-keyword">or</span> <span class="hljs-string">''</span>)[-<span class="hljs-number">21</span>:] <span class="hljs-keyword">or</span> <span class="hljs-built_in">str</span>(self.partner_id.<span class="hljs-built_in">id</span>)[-<span class="hljs-number">21</span>:]
        partner_ref_nr = partner_ref_nr[-<span class="hljs-number">21</span>:]
        <span class="hljs-keyword">return</span> format_structured_reference_iso(partner_ref_nr)

    <span class="hljs-keyword">def</span> <span class="hljs-title function_">_get_invoice_reference_odoo_invoice</span>(<span class="hljs-params">self</span>):
        <span class="hljs-string">""" This computes the reference based on the Odoo format.
            We simply return the number of the invoice, defined on the journal
            sequence.
        """</span>
        self.ensure_one()
        <span class="hljs-keyword">return</span> self.name

    <span class="hljs-keyword">def</span> <span class="hljs-title function_">_get_invoice_reference_odoo_partner</span>(<span class="hljs-params">self</span>):
        <span class="hljs-string">""" This computes the reference based on the Odoo format.
            The data used is the reference set on the partner or its database
            id otherwise. For instance if the reference of the customer is
            'dumb customer 97', the reference will be 'CUST/dumb customer 97'.
        """</span>
        ref = self.partner_id.ref <span class="hljs-keyword">or</span> <span class="hljs-built_in">str</span>(self.partner_id.<span class="hljs-built_in">id</span>)
        prefix = _(<span class="hljs-string">'CUST'</span>)
        <span class="hljs-keyword">return</span> <span class="hljs-string">'%s/%s'</span> % (prefix, ref)

    <span class="hljs-keyword">def</span> <span class="hljs-title function_">_get_invoice_computed_reference</span>(<span class="hljs-params">self</span>):
        self.ensure_one()
        <span class="hljs-keyword">if</span> self.journal_id.invoice_reference_type == <span class="hljs-string">'none'</span>:
            <span class="hljs-keyword">return</span> <span class="hljs-string">''</span>
        ref_function = <span class="hljs-built_in">getattr</span>(self, <span class="hljs-string">f'_get_invoice_reference_<span class="hljs-subst">{self.journal_id.invoice_reference_model}</span>_<span class="hljs-subst">{self.journal_id.invoice_reference_type}</span>'</span>, <span class="hljs-literal">None</span>)
        <span class="hljs-keyword">if</span> ref_function <span class="hljs-keyword">is</span> <span class="hljs-literal">None</span>:
            <span class="hljs-keyword">raise</span> UserError(_(<span class="hljs-string">"The combination of reference model and reference type on the journal is not implemented"</span>))
        <span class="hljs-keyword">return</span> ref_function()

    <span class="hljs-comment"># -------------------------------------------------------------------------</span>
    <span class="hljs-comment"># QUICK ENCODING</span>
    <span class="hljs-comment"># -------------------------------------------------------------------------</span>
<span class="hljs-meta">    @api.model</span>
    <span class="hljs-keyword">def</span> <span class="hljs-title function_">_get_frequent_account_and_taxes</span>(<span class="hljs-params">self, company_id, partner_id, move_type</span>):
        <span class="hljs-string">"""
        Returns the most used accounts and taxes for a given partner and company,
        eventually filtered according to the move type.
        """</span>
        <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> partner_id:
            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>, <span class="hljs-literal">False</span>, <span class="hljs-literal">False</span>
        domain = [
            *self.env[<span class="hljs-string">'account.move.line'</span>]._check_company_domain(company_id),
            (<span class="hljs-string">'partner_id'</span>, <span class="hljs-string">'='</span>, partner_id),
            (<span class="hljs-string">'account_id.deprecated'</span>, <span class="hljs-string">'='</span>, <span class="hljs-literal">False</span>),
            (<span class="hljs-string">'date'</span>, <span class="hljs-string">'&gt;='</span>, date.today() - timedelta(days=<span class="hljs-number">365</span> * <span class="hljs-number">2</span>)),
        ]
        <span class="hljs-keyword">if</span> move_type <span class="hljs-keyword">in</span> self.env[<span class="hljs-string">'account.move'</span>].get_inbound_types(include_receipts=<span class="hljs-literal">True</span>):
            domain.append((<span class="hljs-string">'account_id.internal_group'</span>, <span class="hljs-string">'='</span>, <span class="hljs-string">'income'</span>))
        <span class="hljs-keyword">elif</span> move_type <span class="hljs-keyword">in</span> self.env[<span class="hljs-string">'account.move'</span>].get_outbound_types(include_receipts=<span class="hljs-literal">True</span>):
            domain.append((<span class="hljs-string">'account_id.internal_group'</span>, <span class="hljs-string">'='</span>, <span class="hljs-string">'expense'</span>))

        query = self.env[<span class="hljs-string">'account.move.line'</span>]._where_calc(domain)
        from_clause, where_clause, params = query.get_sql()
        self._cr.execute(<span class="hljs-string">f"""
            SELECT COUNT(foo.id), foo.account_id, foo.taxes
              FROM (
                         SELECT account_move_line__account_id.id AS account_id,
                                account_move_line__account_id.code,
                                account_move_line.id,
                                ARRAY_AGG(tax_rel.account_tax_id) FILTER (WHERE tax_rel.account_tax_id IS NOT NULL) AS taxes
                           FROM <span class="hljs-subst">{from_clause}</span>
                      LEFT JOIN account_move_line_account_tax_rel tax_rel ON account_move_line.id = tax_rel.account_move_line_id
                          WHERE <span class="hljs-subst">{where_clause}</span>
                       GROUP BY account_move_line__account_id.id,
                                account_move_line.id
                   ) AS foo
          GROUP BY foo.account_id, foo.code, foo.taxes
          ORDER BY COUNT(foo.id) DESC, foo.code, taxes ASC NULLS LAST
             LIMIT 1
        """</span>, params)
        <span class="hljs-keyword">return</span> self._cr.fetchone() <span class="hljs-keyword">or</span> (<span class="hljs-number">0</span>, <span class="hljs-literal">False</span>, <span class="hljs-literal">False</span>)

    <span class="hljs-keyword">def</span> <span class="hljs-title function_">_get_quick_edit_suggestions</span>(<span class="hljs-params">self</span>):
        <span class="hljs-string">"""
        Returns a dictionnary containing the suggested values when creating a new
        line with the quick_edit_total_amount set. We will compute the price_unit
        that has to be set with the correct that in order to match this total amount.
        If the vendor/customer is set, we will suggest the most frequently used account
        for that partner as the default one, otherwise the default of the journal.
        """</span>
        self.ensure_one()
        <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> self.quick_edit_mode <span class="hljs-keyword">or</span> <span class="hljs-keyword">not</span> self.quick_edit_total_amount:
            <span class="hljs-keyword">return</span> <span class="hljs-literal">False</span>
        count, account_id, tax_ids = self._get_frequent_account_and_taxes(
            self.company_id.<span class="hljs-built_in">id</span>,
            self.partner_id.<span class="hljs-built_in">id</span>,
            self.move_type,
        )
        <span class="hljs-keyword">if</span> count:
            taxes = self.env[<span class="hljs-string">'account.tax'</span>].browse(tax_ids)
        <span class="hljs-keyword">else</span>:
            account_id = self.journal_id.default_account_id.<span class="hljs-built_in">id</span>
            <span class="hljs-keyword">if</span> self.is_sale_document(include_receipts=<span class="hljs-literal">True</span>):
                taxes = self.journal_id.default_account_id.tax_ids.filtered(<span class="hljs-keyword">lambda</span> tax: tax.type_tax_use == <span class="hljs-string">'sale'</span>)
            <span class="hljs-keyword">else</span>:
                taxes = self.journal_id.default_account_id.tax_ids.filtered(<span class="hljs-keyword">lambda</span> tax: tax.type_tax_use == <span class="hljs-string">'purchase'</span>)
            <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> taxes:
                taxes = (
                    self.journal_id.company_id.account_sale_tax_id
                    <span class="hljs-keyword">if</span> self.journal_id.<span class="hljs-built_in">type</span> == <span class="hljs-string">'sale'</span> <span class="hljs-keyword">else</span>
                    self.journal_id.company_id.account_purchase_tax_id
                )
            taxes = self.fiscal_position_id.map_tax(taxes)

        <span class="hljs-comment"># When a payment term has an early payment discount with the epd computation set to 'mixed', recomputing</span>
        <span class="hljs-comment"># the untaxed amount should take in consideration the discount percentage otherwise we'd get a wrong value.</span>
        <span class="hljs-comment"># We check that we have only one percentage tax as computing from multiple taxes with different types can get complicated.</span>
        <span class="hljs-comment"># In one example: let's say: base = 100, discount = 2%, tax = 21%</span>
        <span class="hljs-comment"># the total will be calculated as: total = base + (base * (1 - discount)) * tax</span>
        <span class="hljs-comment"># If we manipulate the equation to get the base from the total, we'll have base = total / ((1 - discount) * tax + 1)</span>
        term = self.invoice_payment_term_id
        discount_percentage = term.discount_percentage <span class="hljs-keyword">if</span> term.early_discount <span class="hljs-keyword">else</span> <span class="hljs-number">0</span>
        remaining_amount = self.quick_edit_total_amount - self.tax_totals[<span class="hljs-string">'amount_total'</span>]

        <span class="hljs-keyword">if</span> (
                discount_percentage
                <span class="hljs-keyword">and</span> term.early_pay_discount_computation == <span class="hljs-string">'mixed'</span>
                <span class="hljs-keyword">and</span> <span class="hljs-built_in">len</span>(taxes) == <span class="hljs-number">1</span>
                <span class="hljs-keyword">and</span> taxes.amount_type == <span class="hljs-string">'percent'</span>
        ):
            price_untaxed = self.currency_id.<span class="hljs-built_in">round</span>(
                remaining_amount / (((<span class="hljs-number">1.0</span> - discount_percentage / <span class="hljs-number">100.0</span>) * (taxes.amount / <span class="hljs-number">100.0</span>)) + <span class="hljs-number">1.0</span>))
        <span class="hljs-keyword">else</span>:
            price_untaxed = taxes.with_context(force_price_include=<span class="hljs-literal">True</span>).compute_all(remaining_amount)[<span class="hljs-string">'total_excluded'</span>]
        <span class="hljs-keyword">return</span> {<span class="hljs-string">'account_id'</span>: account_id, <span class="hljs-string">'tax_ids'</span>: taxes.ids, <span class="hljs-string">'price_unit'</span>: price_untaxed}

<span class="hljs-meta">    @api.onchange(<span class="hljs-params"><span class="hljs-string">'quick_edit_mode'</span>, <span class="hljs-string">'journal_id'</span>, <span class="hljs-string">'company_id'</span></span>)</span>
    <span class="hljs-keyword">def</span> <span class="hljs-title function_">_quick_edit_mode_suggest_invoice_date</span>(<span class="hljs-params">self</span>):
        <span class="hljs-string">"""Suggest the Customer Invoice/Vendor Bill date based on previous invoice and lock dates"""</span>
        <span class="hljs-keyword">for</span> record <span class="hljs-keyword">in</span> self:
            <span class="hljs-keyword">if</span> record.quick_edit_mode <span class="hljs-keyword">and</span> <span class="hljs-keyword">not</span> record.invoice_date:
                invoice_date = fields.Date.context_today(self)
                prev_move = self.search([(<span class="hljs-string">'state'</span>, <span class="hljs-string">'='</span>, <span class="hljs-string">'posted'</span>),
                                         (<span class="hljs-string">'journal_id'</span>, <span class="hljs-string">'='</span>, record.journal_id.<span class="hljs-built_in">id</span>),
                                         (<span class="hljs-string">'company_id'</span>, <span class="hljs-string">'='</span>, record.company_id.<span class="hljs-built_in">id</span>),
                                         (<span class="hljs-string">'invoice_date'</span>, <span class="hljs-string">'!='</span>, <span class="hljs-literal">False</span>)],
                                        limit=<span class="hljs-number">1</span>)
                <span class="hljs-keyword">if</span> prev_move:
                    invoice_date = self._get_accounting_date(prev_move.invoice_date, <span class="hljs-literal">False</span>)
                record.invoice_date = invoice_date

<span class="hljs-meta">    @api.onchange(<span class="hljs-params"><span class="hljs-string">'quick_edit_total_amount'</span>, <span class="hljs-string">'partner_id'</span></span>)</span>
    <span class="hljs-keyword">def</span> <span class="hljs-title function_">_onchange_quick_edit_total_amount</span>(<span class="hljs-params">self</span>):
        <span class="hljs-string">"""
        Creates a new line with the suggested values (for the account, the price_unit,
        and the tax) such that the total amount matches the quick total amount.
        """</span>
        <span class="hljs-keyword">if</span> (
            <span class="hljs-keyword">not</span> self.quick_edit_total_amount
            <span class="hljs-keyword">or</span> <span class="hljs-keyword">not</span> self.quick_edit_mode
            <span class="hljs-keyword">or</span> <span class="hljs-built_in">len</span>(self.invoice_line_ids) &gt; <span class="hljs-number">0</span>
        ):
            <span class="hljs-keyword">return</span>
        suggestions = self.quick_encoding_vals
        self.invoice_line_ids = [Command.clear()]
        self.invoice_line_ids += self.env[<span class="hljs-string">'account.move.line'</span>].new({
            <span class="hljs-string">'partner_id'</span>: self.partner_id,
            <span class="hljs-string">'account_id'</span>: suggestions[<span class="hljs-string">'account_id'</span>],
            <span class="hljs-string">'currency_id'</span>: self.currency_id.<span class="hljs-built_in">id</span>,
            <span class="hljs-string">'price_unit'</span>: suggestions[<span class="hljs-string">'price_unit'</span>],
            <span class="hljs-string">'tax_ids'</span>: [Command.<span class="hljs-built_in">set</span>(suggestions[<span class="hljs-string">'tax_ids'</span>])],
        })
        self._check_total_amount(self.quick_edit_total_amount)

<span class="hljs-meta">    @api.onchange(<span class="hljs-params"><span class="hljs-string">'invoice_line_ids'</span></span>)</span>
    <span class="hljs-keyword">def</span> <span class="hljs-title function_">_onchange_quick_edit_line_ids</span>(<span class="hljs-params">self</span>):
        quick_encode_suggestion = self.env.context.get(<span class="hljs-string">'quick_encoding_vals'</span>)
        <span class="hljs-keyword">if</span> (
            <span class="hljs-keyword">not</span> self.quick_edit_total_amount
            <span class="hljs-keyword">or</span> <span class="hljs-keyword">not</span> self.quick_edit_mode
            <span class="hljs-keyword">or</span> <span class="hljs-keyword">not</span> self.invoice_line_ids
            <span class="hljs-keyword">or</span> <span class="hljs-keyword">not</span> quick_encode_suggestion
            <span class="hljs-keyword">or</span> <span class="hljs-keyword">not</span> quick_encode_suggestion[<span class="hljs-string">'price_unit'</span>] == self.invoice_line_ids[-<span class="hljs-number">1</span>].price_unit
        ):
            <span class="hljs-keyword">return</span>
        self._check_total_amount(self.quick_edit_total_amount)

    <span class="hljs-keyword">def</span> <span class="hljs-title function_">_check_total_amount</span>(<span class="hljs-params">self, amount_total</span>):
        <span class="hljs-string">"""
        Verifies that the total amount corresponds to the quick total amount chosen as some
        rounding errors may appear. In such a case, we round up the tax such that the total
        is equal to the quick total amount set
        E.g.: 100€ including 21% tax: base = 82.64, tax = 17.35, total = 99.99
        The tax will be set to 17.36 in order to have a total of 100.00
        """</span>
        <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> self.tax_totals <span class="hljs-keyword">or</span> <span class="hljs-keyword">not</span> amount_total:
            <span class="hljs-keyword">return</span>
        totals = self.tax_totals
        tax_amount_rounding_error = amount_total - totals[<span class="hljs-string">'amount_total'</span>]
        <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> float_is_zero(tax_amount_rounding_error, precision_rounding=self.currency_id.rounding):
            <span class="hljs-keyword">if</span> _(<span class="hljs-string">'Untaxed Amount'</span>) <span class="hljs-keyword">in</span> totals[<span class="hljs-string">'groups_by_subtotal'</span>]:
                totals[<span class="hljs-string">'groups_by_subtotal'</span>][_(<span class="hljs-string">'Untaxed Amount'</span>)][<span class="hljs-number">0</span>][<span class="hljs-string">'tax_group_amount'</span>] += tax_amount_rounding_error
                totals[<span class="hljs-string">'amount_total'</span>] = amount_total
                self.tax_totals = totals

    <span class="hljs-comment"># -------------------------------------------------------------------------</span>
    <span class="hljs-comment"># HASH</span>
    <span class="hljs-comment"># -------------------------------------------------------------------------</span>

    <span class="hljs-keyword">def</span> <span class="hljs-title function_">_get_integrity_hash_fields</span>(<span class="hljs-params">self</span>):
        <span class="hljs-comment"># Use the latest hash version by default, but keep the old one for backward compatibility when generating the integrity report.</span>
        hash_version = self._context.get(<span class="hljs-string">'hash_version'</span>, MAX_HASH_VERSION)
        <span class="hljs-keyword">if</span> hash_version == <span class="hljs-number">1</span>:
            <span class="hljs-keyword">return</span> [<span class="hljs-string">'date'</span>, <span class="hljs-string">'journal_id'</span>, <span class="hljs-string">'company_id'</span>]
        <span class="hljs-keyword">elif</span> hash_version <span class="hljs-keyword">in</span> (<span class="hljs-number">2</span>, <span class="hljs-number">3</span>):
            <span class="hljs-keyword">return</span> [<span class="hljs-string">'name'</span>, <span class="hljs-string">'date'</span>, <span class="hljs-string">'journal_id'</span>, <span class="hljs-string">'company_id'</span>]
        <span class="hljs-keyword">raise</span> NotImplementedError(<span class="hljs-string">f"hash_version=<span class="hljs-subst">{hash_version}</span> doesn't exist"</span>)

    <span class="hljs-keyword">def</span> <span class="hljs-title function_">_get_integrity_hash_fields_and_subfields</span>(<span class="hljs-params">self</span>):
        <span class="hljs-keyword">return</span> self._get_integrity_hash_fields() + [<span class="hljs-string">f'line_ids.<span class="hljs-subst">{subfield}</span>'</span> <span class="hljs-keyword">for</span> subfield <span class="hljs-keyword">in</span> self.line_ids._get_integrity_hash_fields()]

    <span class="hljs-keyword">def</span> <span class="hljs-title function_">_get_new_hash</span>(<span class="hljs-params">self, secure_seq_number</span>):
        <span class="hljs-string">""" Returns the hash to write on journal entries when they get posted"""</span>
        self.ensure_one()
        <span class="hljs-comment">#get the only one exact previous move in the securisation sequence</span>
        prev_move = self.sudo().search([(<span class="hljs-string">'state'</span>, <span class="hljs-string">'='</span>, <span class="hljs-string">'posted'</span>),
                                 (<span class="hljs-string">'company_id'</span>, <span class="hljs-string">'='</span>, self.company_id.<span class="hljs-built_in">id</span>),
                                 (<span class="hljs-string">'journal_id'</span>, <span class="hljs-string">'='</span>, self.journal_id.<span class="hljs-built_in">id</span>),
                                 (<span class="hljs-string">'secure_sequence_number'</span>, <span class="hljs-string">'!='</span>, <span class="hljs-number">0</span>),
                                 (<span class="hljs-string">'secure_sequence_number'</span>, <span class="hljs-string">'='</span>, <span class="hljs-built_in">int</span>(secure_seq_number) - <span class="hljs-number">1</span>)])
        <span class="hljs-keyword">if</span> prev_move <span class="hljs-keyword">and</span> <span class="hljs-built_in">len</span>(prev_move) != <span class="hljs-number">1</span>:
            <span class="hljs-keyword">raise</span> UserError(
               _(<span class="hljs-string">'An error occurred when computing the inalterability. Impossible to get the unique previous posted journal entry.'</span>))

        <span class="hljs-comment">#build and return the hash</span>
        <span class="hljs-keyword">return</span> self._compute_hash(prev_move.inalterable_hash <span class="hljs-keyword">if</span> prev_move <span class="hljs-keyword">else</span> <span class="hljs-string">u''</span>)

    <span class="hljs-keyword">def</span> <span class="hljs-title function_">_compute_hash</span>(<span class="hljs-params">self, previous_hash</span>):
        <span class="hljs-string">""" Computes the hash of the browse_record given as self, based on the hash
        of the previous record in the company's securisation sequence given as parameter"""</span>
        self.ensure_one()
        hash_string = sha256((previous_hash + self.string_to_hash).encode(<span class="hljs-string">'utf-8'</span>))
        <span class="hljs-keyword">return</span> hash_string.hexdigest()

<span class="hljs-meta">    @api.depends(<span class="hljs-params"><span class="hljs-keyword">lambda</span> self: self._get_integrity_hash_fields_and_subfields(<span class="hljs-params"></span>)</span>)</span>
<span class="hljs-meta">    @api.depends_context(<span class="hljs-params"><span class="hljs-string">'hash_version'</span></span>)</span>
    <span class="hljs-keyword">def</span> <span class="hljs-title function_">_compute_string_to_hash</span>(<span class="hljs-params">self</span>):
        <span class="hljs-keyword">def</span> <span class="hljs-title function_">_getattrstring</span>(<span class="hljs-params">obj, field_str</span>):
            hash_version = self._context.get(<span class="hljs-string">'hash_version'</span>, MAX_HASH_VERSION)
            field_value = obj[field_str]
            <span class="hljs-keyword">if</span> obj._fields[field_str].<span class="hljs-built_in">type</span> == <span class="hljs-string">'many2one'</span>:
                field_value = field_value.<span class="hljs-built_in">id</span>
            <span class="hljs-keyword">if</span> obj._fields[field_str].<span class="hljs-built_in">type</span> == <span class="hljs-string">'monetary'</span> <span class="hljs-keyword">and</span> hash_version &gt;= <span class="hljs-number">3</span>:
                <span class="hljs-keyword">return</span> float_repr(field_value, obj.currency_id.decimal_places)
            <span class="hljs-keyword">return</span> <span class="hljs-built_in">str</span>(field_value)

        <span class="hljs-keyword">for</span> move <span class="hljs-keyword">in</span> self:
            values = {}
            <span class="hljs-keyword">for</span> field <span class="hljs-keyword">in</span> move._get_integrity_hash_fields():
                values[field] = _getattrstring(move, field)

            <span class="hljs-keyword">for</span> line <span class="hljs-keyword">in</span> move.line_ids:
                <span class="hljs-keyword">for</span> field <span class="hljs-keyword">in</span> line._get_integrity_hash_fields():
                    k = <span class="hljs-string">'line_%d_%s'</span> % (line.<span class="hljs-built_in">id</span>, field)
                    values[k] = _getattrstring(line, field)
            <span class="hljs-comment">#make the json serialization canonical</span>
            <span class="hljs-comment">#  (https://tools.ietf.org/html/draft-staykov-hu-json-canonical-form-00)</span>
            move.string_to_hash = dumps(values, sort_keys=<span class="hljs-literal">True</span>,
                                                ensure_ascii=<span class="hljs-literal">True</span>, indent=<span class="hljs-literal">None</span>,
                                                separators=(<span class="hljs-string">','</span>, <span class="hljs-string">':'</span>))

    <span class="hljs-comment"># -------------------------------------------------------------------------</span>
    <span class="hljs-comment"># RECURRING ENTRIES</span>
    <span class="hljs-comment"># -------------------------------------------------------------------------</span>

<span class="hljs-meta">    @api.model</span>
    <span class="hljs-keyword">def</span> <span class="hljs-title function_">_apply_delta_recurring_entries</span>(<span class="hljs-params">self, date, date_origin, period</span>):
        <span class="hljs-string">'''Advances date by `period` months, maintaining original day of the month if possible.'''</span>
        deltas = {<span class="hljs-string">'monthly'</span>: <span class="hljs-number">1</span>, <span class="hljs-string">'quarterly'</span>: <span class="hljs-number">3</span>, <span class="hljs-string">'yearly'</span>: <span class="hljs-number">12</span>}
        prev_months = (date.year - date_origin.year) * <span class="hljs-number">12</span> + date.month - date_origin.month
        <span class="hljs-keyword">return</span> date_origin + relativedelta(months=deltas[period] + prev_months)

    <span class="hljs-keyword">def</span> <span class="hljs-title function_">_copy_recurring_entries</span>(<span class="hljs-params">self</span>):
        <span class="hljs-string">''' Creates a copy of a recurring (periodic) entry and adjusts its dates for the next period.
        Meant to be called right after posting a periodic entry.
        Copies extra fields as defined by _get_fields_to_copy_recurring_entries().
        '''</span>
        <span class="hljs-keyword">for</span> record <span class="hljs-keyword">in</span> self:
            record.auto_post_origin_id = record.auto_post_origin_id <span class="hljs-keyword">or</span> record  <span class="hljs-comment"># original entry references itself</span>
            next_date = self._apply_delta_recurring_entries(record.date, record.auto_post_origin_id.date, record.auto_post)

            <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> record.auto_post_until <span class="hljs-keyword">or</span> next_date &lt;= record.auto_post_until:  <span class="hljs-comment"># recurrence continues</span>
                record.copy(default=record._get_fields_to_copy_recurring_entries({<span class="hljs-string">'date'</span>: next_date}))

    <span class="hljs-keyword">def</span> <span class="hljs-title function_">_get_fields_to_copy_recurring_entries</span>(<span class="hljs-params">self, values</span>):
        <span class="hljs-string">''' Determines which extra fields to copy when copying a recurring entry.
        To be extended by modules that add fields with copy=False (implicit or explicit)
        whenever the opposite behavior is expected for recurring invoices.
        '''</span>
        values.update({
            <span class="hljs-string">'auto_post'</span>: self.auto_post,  <span class="hljs-comment"># copy=False to avoid mistakes but should be the same in recurring copies</span>
            <span class="hljs-string">'auto_post_until'</span>: self.auto_post_until,  <span class="hljs-comment"># same as above</span>
            <span class="hljs-string">'auto_post_origin_id'</span>: self.auto_post_origin_id.<span class="hljs-built_in">id</span>,  <span class="hljs-comment"># same as above</span>
            <span class="hljs-string">'invoice_user_id'</span>: self.invoice_user_id.<span class="hljs-built_in">id</span>,  <span class="hljs-comment"># otherwise user would be OdooBot</span>
        })
        <span class="hljs-keyword">if</span> self.invoice_date:
            values.update({<span class="hljs-string">'invoice_date'</span>: self._apply_delta_recurring_entries(self.invoice_date, self.auto_post_origin_id.invoice_date, self.auto_post)})
        <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> self.invoice_payment_term_id <span class="hljs-keyword">and</span> self.invoice_date_due:
            <span class="hljs-comment"># no payment terms: maintain timedelta between due date and accounting date</span>
            values.update({<span class="hljs-string">'invoice_date_due'</span>: values[<span class="hljs-string">'date'</span>] + (self.invoice_date_due - self.date)})
        <span class="hljs-keyword">return</span> values

    <span class="hljs-comment"># -------------------------------------------------------------------------</span>
    <span class="hljs-comment"># EDI</span>
    <span class="hljs-comment"># -------------------------------------------------------------------------</span>

<span class="hljs-meta">    @contextmanager</span>
    <span class="hljs-keyword">def</span> <span class="hljs-title function_">_get_edi_creation</span>(<span class="hljs-params">self</span>):
        <span class="hljs-string">"""Get an environment to import documents from other sources.

        Allow to edit the current move or create a new one.
        This will prevent computing the dynamic lines at each invoice line added and only
        compute everything at the end.
        """</span>
        container = {<span class="hljs-string">'records'</span>: self}
        <span class="hljs-keyword">with</span> self._check_balanced(container),\
             self._disable_discount_precision(),\
             self._sync_dynamic_lines(container):
            move = self <span class="hljs-keyword">or</span> self.create({})
            <span class="hljs-keyword">yield</span> move
            container[<span class="hljs-string">'records'</span>] = move

<span class="hljs-meta">    @contextmanager</span>
    <span class="hljs-keyword">def</span> <span class="hljs-title function_">_disable_discount_precision</span>(<span class="hljs-params">self</span>):
        <span class="hljs-string">"""Disable the user defined precision for discounts.

        This is useful for importing documents coming from other softwares and providers.
        The reasonning is that if the document that we are importing has a discount, it
        shouldn't be rounded to the local settings.
        """</span>
        <span class="hljs-keyword">with</span> self._disable_recursion({<span class="hljs-string">'records'</span>: self}, <span class="hljs-string">'ignore_discount_precision'</span>):
            <span class="hljs-keyword">yield</span>

    <span class="hljs-keyword">def</span> <span class="hljs-title function_">_get_edi_decoder</span>(<span class="hljs-params">self, file_data, new=<span class="hljs-literal">False</span></span>):
        <span class="hljs-string">"""To be extended with decoding capabilities.
        :returns:  Function to be later used to import the file.
                   Function' args:
                   - invoice: account.move
                   - file_data: attachemnt information / value
                   - new: whether the invoice is newly created
                   returns True if was able to process the invoice
        """</span>
        <span class="hljs-keyword">return</span>

    <span class="hljs-keyword">def</span> <span class="hljs-title function_">_extend_with_attachments</span>(<span class="hljs-params">self, attachments, new=<span class="hljs-literal">False</span></span>):
        <span class="hljs-string">"""Main entry point to extend/enhance invoices with attachments.

        Either coming from:
        - The chatter when the user drops an attachment on an existing invoice.
        - The journal when the user drops one or multiple attachments from the dashboard.
        - The server mail alias when an alias is configured on the journal.

        It will unwrap all attachments by priority then try to decode until it succeed.

        :param attachments: A recordset of ir.attachment.
        :param new:         Indicate if the current invoice is a fresh one or an existing one.
        :returns:           True if at least one document is successfully imported
        """</span>
        <span class="hljs-keyword">def</span> <span class="hljs-title function_">close_file</span>(<span class="hljs-params">file_data</span>):
            <span class="hljs-keyword">if</span> file_data.get(<span class="hljs-string">'on_close'</span>):
                file_data[<span class="hljs-string">'on_close'</span>]()

        <span class="hljs-keyword">def</span> <span class="hljs-title function_">add_file_data_results</span>(<span class="hljs-params">file_data, invoice</span>):
            passed_file_data_list.append(file_data)
            attachment = file_data.get(<span class="hljs-string">'attachment'</span>) <span class="hljs-keyword">or</span> file_data.get(<span class="hljs-string">'originator_pdf'</span>)
            <span class="hljs-keyword">if</span> attachment:
                <span class="hljs-keyword">if</span> attachments_by_invoice[attachment]:
                    attachments_by_invoice[attachment] |= invoice
                <span class="hljs-keyword">else</span>:
                    attachments_by_invoice[attachment] = invoice

        file_data_list = attachments._unwrap_edi_attachments()
        attachments_by_invoice = {
            attachment: <span class="hljs-literal">None</span>
            <span class="hljs-keyword">for</span> attachment <span class="hljs-keyword">in</span> attachments
        }
        invoices = self
        current_invoice = self
        passed_file_data_list = []
        <span class="hljs-keyword">for</span> file_data <span class="hljs-keyword">in</span> file_data_list:

            <span class="hljs-comment"># The invoice has already been decoded by an embedded file.</span>
            <span class="hljs-keyword">if</span> attachments_by_invoice.get(file_data[<span class="hljs-string">'attachment'</span>]):
                add_file_data_results(file_data, attachments_by_invoice[file_data[<span class="hljs-string">'attachment'</span>]])
                close_file(file_data)
                <span class="hljs-keyword">continue</span>

            <span class="hljs-comment"># When receiving multiple files, if they have a different type, we supposed they are all linked</span>
            <span class="hljs-comment"># to the same invoice.</span>
            <span class="hljs-keyword">if</span> (
                passed_file_data_list
                <span class="hljs-keyword">and</span> passed_file_data_list[-<span class="hljs-number">1</span>][<span class="hljs-string">'filename'</span>] != file_data[<span class="hljs-string">'filename'</span>]
                <span class="hljs-keyword">and</span> passed_file_data_list[-<span class="hljs-number">1</span>][<span class="hljs-string">'sort_weight'</span>] != file_data[<span class="hljs-string">'sort_weight'</span>]
            ):
                add_file_data_results(file_data, invoices[-<span class="hljs-number">1</span>])
                close_file(file_data)
                <span class="hljs-keyword">continue</span>

            <span class="hljs-keyword">if</span> passed_file_data_list <span class="hljs-keyword">and</span> <span class="hljs-keyword">not</span> new:
                add_file_data_results(file_data, invoices[-<span class="hljs-number">1</span>])
                close_file(file_data)
                <span class="hljs-keyword">continue</span>

            decoder = self._get_edi_decoder(file_data, new=new)
            <span class="hljs-keyword">if</span> decoder:
                <span class="hljs-keyword">try</span>:
                    <span class="hljs-keyword">with</span> self.env.cr.savepoint():
                        <span class="hljs-keyword">with</span> current_invoice._get_edi_creation() <span class="hljs-keyword">as</span> invoice:
                            <span class="hljs-comment"># pylint: disable=not-callable</span>
                            success = decoder(invoice, file_data, new)
                        <span class="hljs-keyword">if</span> success <span class="hljs-keyword">or</span> file_data[<span class="hljs-string">'type'</span>] == <span class="hljs-string">'pdf'</span>:
                            invoice._link_bill_origin_to_purchase_orders(timeout=<span class="hljs-number">4</span>)

                            invoices |= invoice
                            current_invoice = self.env[<span class="hljs-string">'account.move'</span>]
                            add_file_data_results(file_data, invoice)

                <span class="hljs-keyword">except</span> RedirectWarning:
                    <span class="hljs-keyword">raise</span>
                <span class="hljs-keyword">except</span> Exception:
                    _logger.exception(
                        <span class="hljs-string">"Error importing attachment '%s' as invoice (decoder=%s)"</span>,
                        file_data[<span class="hljs-string">'filename'</span>],
                        decoder.__name__
                    )

            passed_file_data_list.append(file_data)
            close_file(file_data)

        <span class="hljs-keyword">return</span> attachments_by_invoice

    <span class="hljs-comment"># -------------------------------------------------------------------------</span>
    <span class="hljs-comment"># BUSINESS METHODS</span>
    <span class="hljs-comment"># -------------------------------------------------------------------------</span>

    <span class="hljs-keyword">def</span> <span class="hljs-title function_">_prepare_invoice_aggregated_taxes</span>(<span class="hljs-params">self, filter_invl_to_apply=<span class="hljs-literal">None</span>, filter_tax_values_to_apply=<span class="hljs-literal">None</span>, grouping_key_generator=<span class="hljs-literal">None</span></span>):
        self.ensure_one()

        base_lines = [
            x._convert_to_tax_base_line_dict()
            <span class="hljs-keyword">for</span> x <span class="hljs-keyword">in</span> self.line_ids.filtered(<span class="hljs-keyword">lambda</span> x: x.display_type == <span class="hljs-string">'product'</span> <span class="hljs-keyword">and</span> (<span class="hljs-keyword">not</span> filter_invl_to_apply <span class="hljs-keyword">or</span> filter_invl_to_apply(x)))
        ]

        to_process = []
        <span class="hljs-keyword">for</span> base_line <span class="hljs-keyword">in</span> base_lines:
            to_update_vals, tax_values_list = self.env[<span class="hljs-string">'account.tax'</span>]._compute_taxes_for_single_line(base_line)
            to_process.append((base_line, to_update_vals, tax_values_list))

        <span class="hljs-comment"># Handle manually changed tax amounts (via quick-edit or journal entry manipulation):</span>
        <span class="hljs-comment"># For each tax repartition line we compute the difference between the following 2 amounts</span>
        <span class="hljs-comment">#     * Manual tax amount:</span>
        <span class="hljs-comment">#       The sum of the amounts on the tax lines belonging to the tax repartition line.</span>
        <span class="hljs-comment">#       These amounts may have been manually changed.</span>
        <span class="hljs-comment">#     * Computed tax amount:</span>
        <span class="hljs-comment">#       The sum of the amounts on the items in 'tax_values_list' in 'to_process' belonging to the tax repartition line.</span>
        <span class="hljs-comment"># This difference is then distributed evenly across the 'tax_values_list' in 'to_process'</span>
        <span class="hljs-comment"># such that the manual and computed tax amounts match.</span>
        <span class="hljs-comment"># The updated tax information is later used by '_aggregate_taxes' to compute the right tax amounts (consistently on all levels).</span>
        tax_lines = self.line_ids.filtered(<span class="hljs-keyword">lambda</span> x: x.display_type == <span class="hljs-string">'tax'</span>)
        sign = -<span class="hljs-number">1</span> <span class="hljs-keyword">if</span> self.is_inbound(include_receipts=<span class="hljs-literal">True</span>) <span class="hljs-keyword">else</span> <span class="hljs-number">1</span>

        <span class="hljs-comment"># Collect the tax_amount_currency/balance from tax lines.</span>
        current_tax_amount_per_rep_line = {}
        <span class="hljs-keyword">for</span> tax_line <span class="hljs-keyword">in</span> tax_lines:
            tax_rep_amounts = current_tax_amount_per_rep_line.setdefault(tax_line.tax_repartition_line_id.<span class="hljs-built_in">id</span>, {
                <span class="hljs-string">'tax_amount_currency'</span>: <span class="hljs-number">0.0</span>,
                <span class="hljs-string">'tax_amount'</span>: <span class="hljs-number">0.0</span>,
            })
            tax_rep_amounts[<span class="hljs-string">'tax_amount_currency'</span>] += sign * tax_line.amount_currency
            tax_rep_amounts[<span class="hljs-string">'tax_amount'</span>] += sign * tax_line.balance

        <span class="hljs-comment"># Collect the computed tax_amount_currency/tax_amount from the taxes computation.</span>
        tax_details_per_rep_line = {}
        <span class="hljs-keyword">for</span> _base_line, _to_update_vals, tax_values_list <span class="hljs-keyword">in</span> to_process:
            <span class="hljs-keyword">for</span> tax_values <span class="hljs-keyword">in</span> tax_values_list:
                tax_rep_id = tax_values[<span class="hljs-string">'tax_repartition_line_id'</span>]
                tax_rep_amounts = tax_details_per_rep_line.setdefault(tax_rep_id, {
                    <span class="hljs-string">'tax_amount_currency'</span>: <span class="hljs-number">0.0</span>,
                    <span class="hljs-string">'tax_amount'</span>: <span class="hljs-number">0.0</span>,
                    <span class="hljs-string">'distribute_on'</span>: [],
                })
                tax_rep_amounts[<span class="hljs-string">'tax_amount_currency'</span>] += tax_values[<span class="hljs-string">'tax_amount_currency'</span>]
                tax_rep_amounts[<span class="hljs-string">'tax_amount'</span>] += tax_values[<span class="hljs-string">'tax_amount'</span>]
                tax_rep_amounts[<span class="hljs-string">'distribute_on'</span>].append(tax_values)

        <span class="hljs-comment"># Dispatch the delta on tax_values.</span>
        <span class="hljs-keyword">for</span> key, currency <span class="hljs-keyword">in</span> ((<span class="hljs-string">'tax_amount_currency'</span>, self.currency_id), (<span class="hljs-string">'tax_amount'</span>, self.company_currency_id)):
            <span class="hljs-keyword">for</span> tax_rep_id, computed_tax_rep_amounts <span class="hljs-keyword">in</span> tax_details_per_rep_line.items():
                current_tax_rep_amounts = current_tax_amount_per_rep_line.get(tax_rep_id, computed_tax_rep_amounts)
                diff = current_tax_rep_amounts[key] - computed_tax_rep_amounts[key]
                abs_diff = <span class="hljs-built_in">abs</span>(diff)

                <span class="hljs-keyword">if</span> currency.is_zero(abs_diff):
                    <span class="hljs-keyword">continue</span>

                diff_sign = -<span class="hljs-number">1</span> <span class="hljs-keyword">if</span> diff &lt; <span class="hljs-number">0</span> <span class="hljs-keyword">else</span> <span class="hljs-number">1</span>
                nb_error = math.ceil(abs_diff / currency.rounding)
                nb_cents_per_tax_values = math.floor(nb_error / <span class="hljs-built_in">len</span>(computed_tax_rep_amounts[<span class="hljs-string">'distribute_on'</span>]))
                nb_extra_cent = nb_error % <span class="hljs-built_in">len</span>(computed_tax_rep_amounts[<span class="hljs-string">'distribute_on'</span>])
                <span class="hljs-keyword">for</span> tax_values <span class="hljs-keyword">in</span> computed_tax_rep_amounts[<span class="hljs-string">'distribute_on'</span>]:

                    <span class="hljs-keyword">if</span> currency.is_zero(abs_diff):
                        <span class="hljs-keyword">break</span>

                    nb_amount_curr_cent = nb_cents_per_tax_values
                    <span class="hljs-keyword">if</span> nb_extra_cent:
                        nb_amount_curr_cent += <span class="hljs-number">1</span>
                        nb_extra_cent -= <span class="hljs-number">1</span>

                    <span class="hljs-comment"># We can have more than one cent to distribute on a single tax_values.</span>
                    abs_delta_to_add = <span class="hljs-built_in">min</span>(abs_diff, currency.rounding * nb_amount_curr_cent)
                    tax_values[key] += diff_sign * abs_delta_to_add
                    abs_diff -= abs_delta_to_add

        <span class="hljs-keyword">return</span> self.env[<span class="hljs-string">'account.tax'</span>]._aggregate_taxes(
            to_process,
            filter_tax_values_to_apply=filter_tax_values_to_apply,
            grouping_key_generator=grouping_key_generator,
        )

    <span class="hljs-keyword">def</span> <span class="hljs-title function_">_get_invoice_counterpart_amls_for_early_payment_discount_per_payment_term_line</span>(<span class="hljs-params">self</span>):
        <span class="hljs-string">""" Helper to get the values to create the counterpart journal items on the register payment wizard and the
        bank reconciliation widget in case of an early payment discount. When the early payment discount computation
        is included, we need to compute the base amounts / tax amounts for each receivable / payable but we need to
        take care about the rounding issues. For others computations, we need to balance the discount you get.

        :return: A list of values to create the counterpart journal items split in 3 categories:
            * term_lines:   The journal items containing the discount amounts for each receivable line when the
                            discount computation is excluded / mixed.
            * tax_lines:    The journal items acting as tax lines when the discount computation is included.
            * base_lines:   The journal items acting as base for tax lines when the discount computation is included.
        """</span>
        self.ensure_one()

        <span class="hljs-keyword">def</span> <span class="hljs-title function_">grouping_key_generator</span>(<span class="hljs-params">base_line, tax_values</span>):
            <span class="hljs-keyword">return</span> self.env[<span class="hljs-string">'account.tax'</span>]._get_generation_dict_from_base_line(base_line, tax_values)

        <span class="hljs-keyword">def</span> <span class="hljs-title function_">inverse_tax_rep</span>(<span class="hljs-params">tax_rep</span>):
            tax = tax_rep.tax_id
            index = <span class="hljs-built_in">list</span>(tax.invoice_repartition_line_ids).index(tax_rep)
            <span class="hljs-keyword">return</span> tax.refund_repartition_line_ids[index]

        <span class="hljs-comment"># Get the current tax amounts in the current invoice.</span>
        tax_amounts = {
            inverse_tax_rep(line.tax_repartition_line_id).<span class="hljs-built_in">id</span>: {
                <span class="hljs-string">'amount_currency'</span>: line.amount_currency,
                <span class="hljs-string">'balance'</span>: line.balance,
            }
            <span class="hljs-keyword">for</span> line <span class="hljs-keyword">in</span> self.line_ids.filtered(<span class="hljs-keyword">lambda</span> x: x.display_type == <span class="hljs-string">'tax'</span>)
        }

        product_lines = self.line_ids.filtered(<span class="hljs-keyword">lambda</span> x: x.display_type == <span class="hljs-string">'product'</span>)
        base_lines = [
            {
                **x._convert_to_tax_base_line_dict(),
                <span class="hljs-string">'is_refund'</span>: <span class="hljs-literal">True</span>,
            }
            <span class="hljs-keyword">for</span> x <span class="hljs-keyword">in</span> product_lines
        ]
        <span class="hljs-keyword">for</span> base_line <span class="hljs-keyword">in</span> base_lines:
            base_line[<span class="hljs-string">'taxes'</span>] = base_line[<span class="hljs-string">'taxes'</span>].filtered(<span class="hljs-keyword">lambda</span> t: t.amount_type != <span class="hljs-string">'fixed'</span>)

        <span class="hljs-keyword">if</span> self.is_inbound(include_receipts=<span class="hljs-literal">True</span>):
            cash_discount_account = self.company_id.account_journal_early_pay_discount_loss_account_id
        <span class="hljs-keyword">else</span>:
            cash_discount_account = self.company_id.account_journal_early_pay_discount_gain_account_id

        res = {
            <span class="hljs-string">'term_lines'</span>: defaultdict(<span class="hljs-keyword">lambda</span>: {}),
            <span class="hljs-string">'tax_lines'</span>: defaultdict(<span class="hljs-keyword">lambda</span>: {}),
            <span class="hljs-string">'base_lines'</span>: defaultdict(<span class="hljs-keyword">lambda</span>: {}),
        }

        bases_details = {}
        payment_term_line = self.line_ids.filtered(<span class="hljs-keyword">lambda</span> x: x.display_type == <span class="hljs-string">'payment_term'</span>)
        discount_percentage = payment_term_line.move_id.invoice_payment_term_id.discount_percentage
        <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> discount_percentage:
            <span class="hljs-keyword">return</span> res
        early_pay_discount_computation = payment_term_line.move_id.invoice_payment_term_id.early_pay_discount_computation
        term_amount_currency = payment_term_line.amount_currency - payment_term_line.discount_amount_currency
        term_balance = payment_term_line.balance - payment_term_line.discount_balance
        <span class="hljs-keyword">if</span> early_pay_discount_computation == <span class="hljs-string">'included'</span> <span class="hljs-keyword">and</span> product_lines.tax_ids:
            <span class="hljs-comment"># Compute the base amounts.</span>
            resulting_delta_base_details = {}
            resulting_delta_tax_details = {}
            to_process = []
            <span class="hljs-keyword">for</span> base_line <span class="hljs-keyword">in</span> base_lines:
                invoice_line = base_line[<span class="hljs-string">'record'</span>]
                to_update_vals, tax_values_list = self.env[<span class="hljs-string">'account.tax'</span>]._compute_taxes_for_single_line(
                    base_line,
                    early_pay_discount_computation=early_pay_discount_computation,
                    early_pay_discount_percentage=discount_percentage,
                )
                to_process.append((base_line, to_update_vals, tax_values_list))

                grouping_dict = {
                    <span class="hljs-string">'tax_ids'</span>: [Command.<span class="hljs-built_in">set</span>(base_line[<span class="hljs-string">'taxes'</span>].ids)],
                    <span class="hljs-string">'tax_tag_ids'</span>: to_update_vals[<span class="hljs-string">'tax_tag_ids'</span>],
                    <span class="hljs-string">'partner_id'</span>: base_line[<span class="hljs-string">'partner'</span>].<span class="hljs-built_in">id</span>,
                    <span class="hljs-string">'currency_id'</span>: base_line[<span class="hljs-string">'currency'</span>].<span class="hljs-built_in">id</span>,
                    <span class="hljs-string">'account_id'</span>: cash_discount_account.<span class="hljs-built_in">id</span>,
                    <span class="hljs-string">'analytic_distribution'</span>: base_line[<span class="hljs-string">'analytic_distribution'</span>],
                }
                base_detail = resulting_delta_base_details.setdefault(frozendict(grouping_dict), {
                    <span class="hljs-string">'balance'</span>: <span class="hljs-number">0.0</span>,
                    <span class="hljs-string">'amount_currency'</span>: <span class="hljs-number">0.0</span>,
                })

                amount_currency = self.currency_id\
                    .<span class="hljs-built_in">round</span>(self.direction_sign * to_update_vals[<span class="hljs-string">'price_subtotal'</span>] - invoice_line.amount_currency)
                balance = self.company_currency_id\
                    .<span class="hljs-built_in">round</span>(amount_currency / base_line[<span class="hljs-string">'rate'</span>])

                base_detail[<span class="hljs-string">'balance'</span>] += balance
                base_detail[<span class="hljs-string">'amount_currency'</span>] += amount_currency

                bases_details[frozendict(grouping_dict)] = base_detail

                <span class="hljs-comment"># Compute the tax amounts.</span>
                tax_details_with_epd = self.env[<span class="hljs-string">'account.tax'</span>]._aggregate_taxes(
                    to_process,
                    grouping_key_generator=grouping_key_generator,
                )

                <span class="hljs-keyword">for</span> tax_detail <span class="hljs-keyword">in</span> tax_details_with_epd[<span class="hljs-string">'tax_details'</span>].values():
                    tax_amount_without_epd = tax_amounts.get(tax_detail[<span class="hljs-string">'tax_repartition_line_id'</span>])
                    <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> tax_amount_without_epd:
                        <span class="hljs-keyword">continue</span>

                    tax_amount_currency = self.currency_id\
                        .<span class="hljs-built_in">round</span>(self.direction_sign * tax_detail[<span class="hljs-string">'tax_amount_currency'</span>] - tax_amount_without_epd[<span class="hljs-string">'amount_currency'</span>])
                    tax_amount = self.company_currency_id\
                        .<span class="hljs-built_in">round</span>(self.direction_sign * tax_detail[<span class="hljs-string">'tax_amount'</span>] - tax_amount_without_epd[<span class="hljs-string">'balance'</span>])

                    <span class="hljs-keyword">if</span> self.currency_id.is_zero(tax_amount_currency) <span class="hljs-keyword">and</span> self.company_currency_id.is_zero(tax_amount):
                        <span class="hljs-keyword">continue</span>

                    resulting_delta_tax_details[tax_detail[<span class="hljs-string">'tax_repartition_line_id'</span>]] = {
                        **tax_detail,
                        <span class="hljs-string">'amount_currency'</span>: tax_amount_currency,
                        <span class="hljs-string">'balance'</span>: tax_amount,
                    }

            <span class="hljs-comment"># Multiply the amount by the percentage</span>
            percentage_paid = <span class="hljs-built_in">abs</span>(payment_term_line.amount_residual_currency / self.amount_total)
            <span class="hljs-keyword">for</span> tax_detail <span class="hljs-keyword">in</span> resulting_delta_tax_details.values():
                tax_rep = self.env[<span class="hljs-string">'account.tax.repartition.line'</span>].browse(tax_detail[<span class="hljs-string">'tax_repartition_line_id'</span>])
                tax = tax_rep.tax_id

                grouping_dict = {
                    <span class="hljs-string">'account_id'</span>: tax_detail[<span class="hljs-string">'account_id'</span>],
                    <span class="hljs-string">'partner_id'</span>: tax_detail[<span class="hljs-string">'partner_id'</span>],
                    <span class="hljs-string">'currency_id'</span>: tax_detail[<span class="hljs-string">'currency_id'</span>],
                    <span class="hljs-string">'analytic_distribution'</span>: tax_detail[<span class="hljs-string">'analytic_distribution'</span>],
                    <span class="hljs-string">'tax_repartition_line_id'</span>: tax_rep.<span class="hljs-built_in">id</span>,
                    <span class="hljs-string">'tax_ids'</span>: tax_detail[<span class="hljs-string">'tax_ids'</span>],
                    <span class="hljs-string">'tax_tag_ids'</span>: tax_detail[<span class="hljs-string">'tax_tag_ids'</span>],
                    <span class="hljs-string">'group_tax_id'</span>: tax_detail[<span class="hljs-string">'tax_id'</span>] <span class="hljs-keyword">if</span> tax_detail[<span class="hljs-string">'tax_id'</span>] != tax.<span class="hljs-built_in">id</span> <span class="hljs-keyword">else</span> <span class="hljs-literal">None</span>,
                }

                res[<span class="hljs-string">'tax_lines'</span>][payment_term_line][frozendict(grouping_dict)] = {
                    <span class="hljs-string">'name'</span>: _(<span class="hljs-string">"Early Payment Discount (%s)"</span>, tax.name),
                    <span class="hljs-string">'amount_currency'</span>: payment_term_line.currency_id.<span class="hljs-built_in">round</span>(tax_detail[<span class="hljs-string">'amount_currency'</span>] * percentage_paid),
                    <span class="hljs-string">'balance'</span>: payment_term_line.company_currency_id.<span class="hljs-built_in">round</span>(tax_detail[<span class="hljs-string">'balance'</span>] * percentage_paid),
                    <span class="hljs-string">'tax_tag_invert'</span>: <span class="hljs-literal">True</span>,
                }

            <span class="hljs-keyword">for</span> grouping_dict, base_detail <span class="hljs-keyword">in</span> bases_details.items():
                res[<span class="hljs-string">'base_lines'</span>][payment_term_line][grouping_dict] = {
                    <span class="hljs-string">'name'</span>: _(<span class="hljs-string">"Early Payment Discount"</span>),
                    <span class="hljs-string">'amount_currency'</span>: payment_term_line.currency_id.<span class="hljs-built_in">round</span>(base_detail[<span class="hljs-string">'amount_currency'</span>] * percentage_paid),
                    <span class="hljs-string">'balance'</span>: payment_term_line.company_currency_id.<span class="hljs-built_in">round</span>(base_detail[<span class="hljs-string">'balance'</span>] * percentage_paid),
                }

            <span class="hljs-comment"># Fix the rounding issue if any.</span>
            delta_amount_currency = term_amount_currency \
                                    - <span class="hljs-built_in">sum</span>(x[<span class="hljs-string">'amount_currency'</span>] <span class="hljs-keyword">for</span> x <span class="hljs-keyword">in</span> res[<span class="hljs-string">'base_lines'</span>][payment_term_line].values()) \
                                    - <span class="hljs-built_in">sum</span>(x[<span class="hljs-string">'amount_currency'</span>] <span class="hljs-keyword">for</span> x <span class="hljs-keyword">in</span> res[<span class="hljs-string">'tax_lines'</span>][payment_term_line].values())
            delta_balance = term_balance \
                            - <span class="hljs-built_in">sum</span>(x[<span class="hljs-string">'balance'</span>] <span class="hljs-keyword">for</span> x <span class="hljs-keyword">in</span> res[<span class="hljs-string">'base_lines'</span>][payment_term_line].values()) \
                            - <span class="hljs-built_in">sum</span>(x[<span class="hljs-string">'balance'</span>] <span class="hljs-keyword">for</span> x <span class="hljs-keyword">in</span> res[<span class="hljs-string">'tax_lines'</span>][payment_term_line].values())

            last_tax_line = (<span class="hljs-built_in">list</span>(res[<span class="hljs-string">'tax_lines'</span>][payment_term_line].values()) <span class="hljs-keyword">or</span> <span class="hljs-built_in">list</span>(res[<span class="hljs-string">'base_lines'</span>][payment_term_line].values()))[-<span class="hljs-number">1</span>]
            last_tax_line[<span class="hljs-string">'amount_currency'</span>] += delta_amount_currency
            last_tax_line[<span class="hljs-string">'balance'</span>] += delta_balance

        <span class="hljs-keyword">else</span>:
            grouping_dict = {<span class="hljs-string">'account_id'</span>: cash_discount_account.<span class="hljs-built_in">id</span>}

            res[<span class="hljs-string">'term_lines'</span>][payment_term_line][frozendict(grouping_dict)] = {
                <span class="hljs-string">'name'</span>: _(<span class="hljs-string">"Early Payment Discount"</span>),
                <span class="hljs-string">'partner_id'</span>: payment_term_line.partner_id.<span class="hljs-built_in">id</span>,
                <span class="hljs-string">'currency_id'</span>: payment_term_line.currency_id.<span class="hljs-built_in">id</span>,
                <span class="hljs-string">'amount_currency'</span>: term_amount_currency,
                <span class="hljs-string">'balance'</span>: term_balance,
            }

        <span class="hljs-keyword">return</span> res

<span class="hljs-meta">    @api.model</span>
    <span class="hljs-keyword">def</span> <span class="hljs-title function_">_get_invoice_counterpart_amls_for_early_payment_discount</span>(<span class="hljs-params">self, aml_values_list, open_balance</span>):
        <span class="hljs-string">""" Helper to get the values to create the counterpart journal items on the register payment wizard and the
        bank reconciliation widget in case of an early payment discount by taking care of the payment term lines we
        are matching and the exchange difference in case of multi-currencies.

        :param aml_values_list: A list of dictionaries containing:
            * aml:              The payment term line we match.
            * amount_currency:  The matched amount_currency for this line.
            * balance:          The matched balance for this line (could be different in case of multi-currencies).
        :param open_balance:    The current open balance to be covered by the early payment discount.
        :return: A list of values to create the counterpart journal items split in 3 categories:
            * term_lines:       The journal items containing the discount amounts for each receivable line when the
                                discount computation is excluded / mixed.
            * tax_lines:        The journal items acting as tax lines when the discount computation is included.
            * base_lines:       The journal items acting as base for tax lines when the discount computation is included.
            * exchange_lines:   The journal items representing the exchange differences in case of multi-currencies.
        """</span>
        res = {
            <span class="hljs-string">'base_lines'</span>: {},
            <span class="hljs-string">'tax_lines'</span>: {},
            <span class="hljs-string">'term_lines'</span>: {},
            <span class="hljs-string">'exchange_lines'</span>: {},
        }

        res_per_invoice = {}
        <span class="hljs-keyword">for</span> aml_values <span class="hljs-keyword">in</span> aml_values_list:
            aml = aml_values[<span class="hljs-string">'aml'</span>]
            invoice = aml.move_id

            <span class="hljs-keyword">if</span> invoice <span class="hljs-keyword">not</span> <span class="hljs-keyword">in</span> res_per_invoice:
                res_per_invoice[invoice] = invoice._get_invoice_counterpart_amls_for_early_payment_discount_per_payment_term_line()

            <span class="hljs-keyword">for</span> key <span class="hljs-keyword">in</span> (<span class="hljs-string">'base_lines'</span>, <span class="hljs-string">'tax_lines'</span>, <span class="hljs-string">'term_lines'</span>):
                <span class="hljs-keyword">for</span> grouping_dict, vals <span class="hljs-keyword">in</span> res_per_invoice[invoice][key][aml].items():
                    line_vals = res[key].setdefault(grouping_dict, {
                        **vals,
                        <span class="hljs-string">'amount_currency'</span>: <span class="hljs-number">0.0</span>,
                        <span class="hljs-string">'balance'</span>: <span class="hljs-number">0.0</span>,
                    })
                    line_vals[<span class="hljs-string">'amount_currency'</span>] += vals[<span class="hljs-string">'amount_currency'</span>]
                    line_vals[<span class="hljs-string">'balance'</span>] += vals[<span class="hljs-string">'balance'</span>]

                    <span class="hljs-comment"># Track the balance to handle the exchange difference.</span>
                    open_balance -= vals[<span class="hljs-string">'balance'</span>]

        exchange_diff_sign = aml.company_currency_id.compare_amounts(open_balance, <span class="hljs-number">0.0</span>)
        <span class="hljs-keyword">if</span> exchange_diff_sign != <span class="hljs-number">0.0</span>:

            <span class="hljs-keyword">if</span> exchange_diff_sign &gt; <span class="hljs-number">0.0</span>:
                exchange_line_account = aml.company_id.expense_currency_exchange_account_id
            <span class="hljs-keyword">else</span>:
                exchange_line_account = aml.company_id.income_currency_exchange_account_id

            grouping_dict = {
                <span class="hljs-string">'account_id'</span>: exchange_line_account.<span class="hljs-built_in">id</span>,
                <span class="hljs-string">'currency_id'</span>: aml.currency_id.<span class="hljs-built_in">id</span>,
                <span class="hljs-string">'partner_id'</span>: aml.partner_id.<span class="hljs-built_in">id</span>,
            }
            line_vals = res[<span class="hljs-string">'exchange_lines'</span>].setdefault(frozendict(grouping_dict), {
                **grouping_dict,
                <span class="hljs-string">'name'</span>: _(<span class="hljs-string">"Early Payment Discount (Exchange Difference)"</span>),
                <span class="hljs-string">'amount_currency'</span>: <span class="hljs-number">0.0</span>,
                <span class="hljs-string">'balance'</span>: <span class="hljs-number">0.0</span>,
            })
            line_vals[<span class="hljs-string">'balance'</span>] += open_balance

        <span class="hljs-keyword">return</span> {
            key: [
                {
                    **grouping_dict,
                    **vals,
                }
                <span class="hljs-keyword">for</span> grouping_dict, vals <span class="hljs-keyword">in</span> mapping.items()
            ]
            <span class="hljs-keyword">for</span> key, mapping <span class="hljs-keyword">in</span> res.items()
        }

    <span class="hljs-keyword">def</span> <span class="hljs-title function_">_affect_tax_report</span>(<span class="hljs-params">self</span>):
        <span class="hljs-keyword">return</span> <span class="hljs-built_in">any</span>(line._affect_tax_report() <span class="hljs-keyword">for</span> line <span class="hljs-keyword">in</span> (self.line_ids | self.invoice_line_ids))

    <span class="hljs-keyword">def</span> <span class="hljs-title function_">_get_move_display_name</span>(<span class="hljs-params">self, show_ref=<span class="hljs-literal">False</span></span>):
        <span class="hljs-string">''' Helper to get the display name of an invoice depending of its type.
        :param show_ref:    A flag indicating of the display name must include or not the journal entry reference.
        :return:            A string representing the invoice.
        '''</span>
        self.ensure_one()
        name = <span class="hljs-string">''</span>
        <span class="hljs-keyword">if</span> self.state == <span class="hljs-string">'draft'</span>:
            name += {
                <span class="hljs-string">'out_invoice'</span>: _(<span class="hljs-string">'Draft Invoice'</span>),
                <span class="hljs-string">'out_refund'</span>: _(<span class="hljs-string">'Draft Credit Note'</span>),
                <span class="hljs-string">'in_invoice'</span>: _(<span class="hljs-string">'Draft Bill'</span>),
                <span class="hljs-string">'in_refund'</span>: _(<span class="hljs-string">'Draft Vendor Credit Note'</span>),
                <span class="hljs-string">'out_receipt'</span>: _(<span class="hljs-string">'Draft Sales Receipt'</span>),
                <span class="hljs-string">'in_receipt'</span>: _(<span class="hljs-string">'Draft Purchase Receipt'</span>),
                <span class="hljs-string">'entry'</span>: _(<span class="hljs-string">'Draft Entry'</span>),
            }[self.move_type]
            name += <span class="hljs-string">' '</span>
        <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> self.name <span class="hljs-keyword">or</span> self.name == <span class="hljs-string">'/'</span>:
            name += <span class="hljs-string">'(* %s)'</span> % <span class="hljs-built_in">str</span>(self.<span class="hljs-built_in">id</span>)
        <span class="hljs-keyword">else</span>:
            name += self.name
            <span class="hljs-keyword">if</span> self.env.context.get(<span class="hljs-string">'input_full_display_name'</span>):
                <span class="hljs-keyword">if</span> self.partner_id:
                    name += <span class="hljs-string">f', <span class="hljs-subst">{self.partner_id.name}</span>'</span>
                <span class="hljs-keyword">if</span> self.date:
                    name += <span class="hljs-string">f', <span class="hljs-subst">{format_date(self.env, self.date)}</span>'</span>
        <span class="hljs-keyword">return</span> name + (<span class="hljs-string">f" (<span class="hljs-subst">{shorten(self.ref, width=<span class="hljs-number">50</span>)}</span>)"</span> <span class="hljs-keyword">if</span> show_ref <span class="hljs-keyword">and</span> self.ref <span class="hljs-keyword">else</span> <span class="hljs-string">''</span>)

    <span class="hljs-keyword">def</span> <span class="hljs-title function_">_get_reconciled_amls</span>(<span class="hljs-params">self</span>):
        <span class="hljs-string">"""Helper used to retrieve the reconciled move lines on this journal entry"""</span>
        reconciled_lines = self.line_ids.filtered(<span class="hljs-keyword">lambda</span> line: line.account_id.account_type <span class="hljs-keyword">in</span> (<span class="hljs-string">'asset_receivable'</span>, <span class="hljs-string">'liability_payable'</span>))
        <span class="hljs-keyword">return</span> reconciled_lines.mapped(<span class="hljs-string">'matched_debit_ids.debit_move_id'</span>) + reconciled_lines.mapped(<span class="hljs-string">'matched_credit_ids.credit_move_id'</span>)

    <span class="hljs-keyword">def</span> <span class="hljs-title function_">_get_reconciled_payments</span>(<span class="hljs-params">self</span>):
        <span class="hljs-string">"""Helper used to retrieve the reconciled payments on this journal entry"""</span>
        <span class="hljs-keyword">return</span> self._get_reconciled_amls().move_id.payment_id

    <span class="hljs-keyword">def</span> <span class="hljs-title function_">_get_reconciled_statement_lines</span>(<span class="hljs-params">self</span>):
        <span class="hljs-string">"""Helper used to retrieve the reconciled statement lines on this journal entry"""</span>
        <span class="hljs-keyword">return</span> self._get_reconciled_amls().move_id.statement_line_id

    <span class="hljs-keyword">def</span> <span class="hljs-title function_">_get_reconciled_invoices</span>(<span class="hljs-params">self</span>):
        <span class="hljs-string">"""Helper used to retrieve the reconciled invoices on this journal entry"""</span>
        <span class="hljs-keyword">return</span> self._get_reconciled_amls().move_id.filtered(<span class="hljs-keyword">lambda</span> move: move.is_invoice(include_receipts=<span class="hljs-literal">True</span>))

    <span class="hljs-keyword">def</span> <span class="hljs-title function_">_get_all_reconciled_invoice_partials</span>(<span class="hljs-params">self</span>):
        self.ensure_one()
        reconciled_lines = self.line_ids.filtered(<span class="hljs-keyword">lambda</span> line: line.account_id.account_type <span class="hljs-keyword">in</span> (<span class="hljs-string">'asset_receivable'</span>, <span class="hljs-string">'liability_payable'</span>))
        <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> reconciled_lines:
            <span class="hljs-keyword">return</span> {}

        self.env[<span class="hljs-string">'account.partial.reconcile'</span>].flush_model([
            <span class="hljs-string">'credit_amount_currency'</span>, <span class="hljs-string">'credit_move_id'</span>, <span class="hljs-string">'debit_amount_currency'</span>,
            <span class="hljs-string">'debit_move_id'</span>, <span class="hljs-string">'exchange_move_id'</span>,
        ])
        query = <span class="hljs-string">'''
            SELECT
                part.id,
                part.exchange_move_id,
                part.debit_amount_currency AS amount,
                part.credit_move_id AS counterpart_line_id
            FROM account_partial_reconcile part
            WHERE part.debit_move_id IN %s

            UNION ALL

            SELECT
                part.id,
                part.exchange_move_id,
                part.credit_amount_currency AS amount,
                part.debit_move_id AS counterpart_line_id
            FROM account_partial_reconcile part
            WHERE part.credit_move_id IN %s
        '''</span>
        self._cr.execute(query, [<span class="hljs-built_in">tuple</span>(reconciled_lines.ids)] * <span class="hljs-number">2</span>)

        partial_values_list = []
        counterpart_line_ids = <span class="hljs-built_in">set</span>()
        exchange_move_ids = <span class="hljs-built_in">set</span>()
        <span class="hljs-keyword">for</span> values <span class="hljs-keyword">in</span> self._cr.dictfetchall():
            partial_values_list.append({
                <span class="hljs-string">'aml_id'</span>: values[<span class="hljs-string">'counterpart_line_id'</span>],
                <span class="hljs-string">'partial_id'</span>: values[<span class="hljs-string">'id'</span>],
                <span class="hljs-string">'amount'</span>: values[<span class="hljs-string">'amount'</span>],
                <span class="hljs-string">'currency'</span>: self.currency_id,
            })
            counterpart_line_ids.add(values[<span class="hljs-string">'counterpart_line_id'</span>])
            <span class="hljs-keyword">if</span> values[<span class="hljs-string">'exchange_move_id'</span>]:
                exchange_move_ids.add(values[<span class="hljs-string">'exchange_move_id'</span>])

        <span class="hljs-keyword">if</span> exchange_move_ids:
            self.env[<span class="hljs-string">'account.move.line'</span>].flush_model([<span class="hljs-string">'move_id'</span>])
            query = <span class="hljs-string">'''
                SELECT
                    part.id,
                    part.credit_move_id AS counterpart_line_id
                FROM account_partial_reconcile part
                JOIN account_move_line credit_line ON credit_line.id = part.credit_move_id
                WHERE credit_line.move_id IN %s AND part.debit_move_id IN %s

                UNION ALL

                SELECT
                    part.id,
                    part.debit_move_id AS counterpart_line_id
                FROM account_partial_reconcile part
                JOIN account_move_line debit_line ON debit_line.id = part.debit_move_id
                WHERE debit_line.move_id IN %s AND part.credit_move_id IN %s
            '''</span>
            self._cr.execute(query, [<span class="hljs-built_in">tuple</span>(exchange_move_ids), <span class="hljs-built_in">tuple</span>(counterpart_line_ids)] * <span class="hljs-number">2</span>)

            <span class="hljs-keyword">for</span> values <span class="hljs-keyword">in</span> self._cr.dictfetchall():
                counterpart_line_ids.add(values[<span class="hljs-string">'counterpart_line_id'</span>])
                partial_values_list.append({
                    <span class="hljs-string">'aml_id'</span>: values[<span class="hljs-string">'counterpart_line_id'</span>],
                    <span class="hljs-string">'partial_id'</span>: values[<span class="hljs-string">'id'</span>],
                    <span class="hljs-string">'currency'</span>: self.company_id.currency_id,
                })

        counterpart_lines = {x.<span class="hljs-built_in">id</span>: x <span class="hljs-keyword">for</span> x <span class="hljs-keyword">in</span> self.env[<span class="hljs-string">'account.move.line'</span>].browse(counterpart_line_ids)}
        <span class="hljs-keyword">for</span> partial_values <span class="hljs-keyword">in</span> partial_values_list:
            partial_values[<span class="hljs-string">'aml'</span>] = counterpart_lines[partial_values[<span class="hljs-string">'aml_id'</span>]]
            partial_values[<span class="hljs-string">'is_exchange'</span>] = partial_values[<span class="hljs-string">'aml'</span>].move_id.<span class="hljs-built_in">id</span> <span class="hljs-keyword">in</span> exchange_move_ids
            <span class="hljs-keyword">if</span> partial_values[<span class="hljs-string">'is_exchange'</span>]:
                partial_values[<span class="hljs-string">'amount'</span>] = <span class="hljs-built_in">abs</span>(partial_values[<span class="hljs-string">'aml'</span>].balance)

        <span class="hljs-keyword">return</span> partial_values_list

    <span class="hljs-keyword">def</span> <span class="hljs-title function_">_get_reconciled_invoices_partials</span>(<span class="hljs-params">self</span>):
        <span class="hljs-string">''' Helper to retrieve the details about reconciled invoices.
        :return A list of tuple (partial, amount, invoice_line).
        '''</span>
        self.ensure_one()
        pay_term_lines = self.line_ids\
            .filtered(<span class="hljs-keyword">lambda</span> line: line.account_type <span class="hljs-keyword">in</span> (<span class="hljs-string">'asset_receivable'</span>, <span class="hljs-string">'liability_payable'</span>))
        invoice_partials = []
        exchange_diff_moves = []

        <span class="hljs-keyword">for</span> partial <span class="hljs-keyword">in</span> pay_term_lines.matched_debit_ids:
            invoice_partials.append((partial, partial.credit_amount_currency, partial.debit_move_id))
            <span class="hljs-keyword">if</span> partial.exchange_move_id:
                exchange_diff_moves.append(partial.exchange_move_id.<span class="hljs-built_in">id</span>)
        <span class="hljs-keyword">for</span> partial <span class="hljs-keyword">in</span> pay_term_lines.matched_credit_ids:
            invoice_partials.append((partial, partial.debit_amount_currency, partial.credit_move_id))
            <span class="hljs-keyword">if</span> partial.exchange_move_id:
                exchange_diff_moves.append(partial.exchange_move_id.<span class="hljs-built_in">id</span>)
        <span class="hljs-keyword">return</span> invoice_partials, exchange_diff_moves

    <span class="hljs-keyword">def</span> <span class="hljs-title function_">_reconcile_reversed_moves</span>(<span class="hljs-params">self, reverse_moves, move_reverse_cancel</span>):
        <span class="hljs-string">''' Reconciles moves in self and reverse moves
        :param move_reverse_cancel: parameter used when lines are reconciled
                                    will determine whether the tax cash basis journal entries should be created
        :param reverse_moves:       An account.move recordset, reverse of the current self.
        :return:                    An account.move recordset, reverse of the current self.
        '''</span>
        <span class="hljs-keyword">for</span> move, reverse_move <span class="hljs-keyword">in</span> <span class="hljs-built_in">zip</span>(self, reverse_moves):
            group = (move.line_ids + reverse_move.line_ids) \
                .filtered(<span class="hljs-keyword">lambda</span> l: <span class="hljs-keyword">not</span> l.reconciled) \
                .grouped(<span class="hljs-keyword">lambda</span> l: (l.account_id, l.currency_id))
            <span class="hljs-keyword">for</span> (account, _currency), lines <span class="hljs-keyword">in</span> group.items():
                <span class="hljs-keyword">if</span> account.reconcile <span class="hljs-keyword">or</span> account.account_type <span class="hljs-keyword">in</span> (<span class="hljs-string">'asset_cash'</span>, <span class="hljs-string">'liability_credit_card'</span>):
                    lines.with_context(move_reverse_cancel=move_reverse_cancel).reconcile()
        <span class="hljs-keyword">return</span> reverse_moves


    <span class="hljs-keyword">def</span> <span class="hljs-title function_">_reverse_moves</span>(<span class="hljs-params">self, default_values_list=<span class="hljs-literal">None</span>, cancel=<span class="hljs-literal">False</span></span>):
        <span class="hljs-string">''' Reverse a recordset of account.move.
        If cancel parameter is true, the reconcilable or liquidity lines
        of each original move will be reconciled with its reverse's.
        :param default_values_list: A list of default values to consider per move.
                                    ('type' &amp; 'reversed_entry_id' are computed in the method).
        :return:                    An account.move recordset, reverse of the current self.
        '''</span>
        <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> default_values_list:
            default_values_list = [{} <span class="hljs-keyword">for</span> move <span class="hljs-keyword">in</span> self]

        <span class="hljs-keyword">if</span> cancel:
            lines = self.mapped(<span class="hljs-string">'line_ids'</span>)
            <span class="hljs-comment"># Avoid maximum recursion depth.</span>
            <span class="hljs-keyword">if</span> lines:
                lines.remove_move_reconcile()

        reverse_moves = self.env[<span class="hljs-string">'account.move'</span>]
        <span class="hljs-keyword">for</span> move, default_values <span class="hljs-keyword">in</span> <span class="hljs-built_in">zip</span>(self, default_values_list):
            default_values.update({
                <span class="hljs-string">'move_type'</span>: TYPE_REVERSE_MAP[move.move_type],
                <span class="hljs-string">'reversed_entry_id'</span>: move.<span class="hljs-built_in">id</span>,
                <span class="hljs-string">'partner_id'</span>: move.partner_id.<span class="hljs-built_in">id</span>,
            })
            reverse_moves += move.with_context(
                move_reverse_cancel=cancel,
                include_business_fields=<span class="hljs-literal">True</span>,
                skip_invoice_sync=move.move_type == <span class="hljs-string">'entry'</span>,
            ).copy(default_values)

        reverse_moves.with_context(skip_invoice_sync=cancel).write({<span class="hljs-string">'line_ids'</span>: [
            Command.update(line.<span class="hljs-built_in">id</span>, {
                <span class="hljs-string">'balance'</span>: -line.balance,
                <span class="hljs-string">'amount_currency'</span>: -line.amount_currency,
            })
            <span class="hljs-keyword">for</span> line <span class="hljs-keyword">in</span> reverse_moves.line_ids
            <span class="hljs-keyword">if</span> line.move_id.move_type == <span class="hljs-string">'entry'</span> <span class="hljs-keyword">or</span> line.display_type == <span class="hljs-string">'cogs'</span>
        ]})

        <span class="hljs-comment"># Reconcile moves together to cancel the previous one.</span>
        <span class="hljs-keyword">if</span> cancel:
            reverse_moves.with_context(move_reverse_cancel=cancel)._post(soft=<span class="hljs-literal">False</span>)

        <span class="hljs-keyword">return</span> reverse_moves

    <span class="hljs-keyword">def</span> <span class="hljs-title function_">_unlink_or_reverse</span>(<span class="hljs-params">self</span>):
        <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> self:
            <span class="hljs-keyword">return</span>
        to_reverse = self.env[<span class="hljs-string">'account.move'</span>]
        to_unlink = self.env[<span class="hljs-string">'account.move'</span>]
        lock_date = self.company_id._get_user_fiscal_lock_date()
        <span class="hljs-keyword">for</span> move <span class="hljs-keyword">in</span> self:
            <span class="hljs-keyword">if</span> move.inalterable_hash <span class="hljs-keyword">or</span> move.date &lt;= lock_date:
                to_reverse += move
            <span class="hljs-keyword">else</span>:
                to_unlink += move
        to_reverse._reverse_moves(cancel=<span class="hljs-literal">True</span>)
        to_unlink.filtered(<span class="hljs-keyword">lambda</span> m: m.state <span class="hljs-keyword">in</span> (<span class="hljs-string">'posted'</span>, <span class="hljs-string">'cancel'</span>)).button_draft()
        to_unlink.filtered(<span class="hljs-keyword">lambda</span> m: m.state == <span class="hljs-string">'draft'</span>).unlink()

    <span class="hljs-keyword">def</span> <span class="hljs-title function_">_post</span>(<span class="hljs-params">self, soft=<span class="hljs-literal">True</span></span>):
        <span class="hljs-string">"""Post/Validate the documents.

        Posting the documents will give it a number, and check that the document is
        complete (some fields might not be required if not posted but are required
        otherwise).
        If the journal is locked with a hash table, it will be impossible to change
        some fields afterwards.

        :param soft (bool): if True, future documents are not immediately posted,
            but are set to be auto posted automatically at the set accounting date.
            Nothing will be performed on those documents before the accounting date.
        :return Model&lt;account.move&gt;: the documents that have been posted
        """</span>
        <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> self.env.su <span class="hljs-keyword">and</span> <span class="hljs-keyword">not</span> self.env.user.has_group(<span class="hljs-string">'account.group_account_invoice'</span>):
            <span class="hljs-keyword">raise</span> AccessError(_(<span class="hljs-string">"You don't have the access rights to post an invoice."</span>))

        <span class="hljs-keyword">for</span> invoice <span class="hljs-keyword">in</span> self.filtered(<span class="hljs-keyword">lambda</span> move: move.is_invoice(include_receipts=<span class="hljs-literal">True</span>)):
            <span class="hljs-keyword">if</span> (
                invoice.quick_edit_mode
                <span class="hljs-keyword">and</span> invoice.quick_edit_total_amount
                <span class="hljs-keyword">and</span> invoice.currency_id.compare_amounts(invoice.quick_edit_total_amount, invoice.amount_total) != <span class="hljs-number">0</span>
            ):
                <span class="hljs-keyword">raise</span> UserError(_(
                    <span class="hljs-string">"The current total is %s but the expected total is %s. In order to post the invoice/bill, "</span>
                    <span class="hljs-string">"you can adjust its lines or the expected Total (tax inc.)."</span>,
                    formatLang(self.env, invoice.amount_total, currency_obj=invoice.currency_id),
                    formatLang(self.env, invoice.quick_edit_total_amount, currency_obj=invoice.currency_id),
                ))
            <span class="hljs-keyword">if</span> invoice.partner_bank_id <span class="hljs-keyword">and</span> <span class="hljs-keyword">not</span> invoice.partner_bank_id.active:
                <span class="hljs-keyword">raise</span> UserError(_(
                    <span class="hljs-string">"The recipient bank account linked to this invoice is archived.\n"</span>
                    <span class="hljs-string">"So you cannot confirm the invoice."</span>
                ))
            <span class="hljs-keyword">if</span> float_compare(invoice.amount_total, <span class="hljs-number">0.0</span>, precision_rounding=invoice.currency_id.rounding) &lt; <span class="hljs-number">0</span>:
                <span class="hljs-keyword">raise</span> UserError(_(
                    <span class="hljs-string">"You cannot validate an invoice with a negative total amount. "</span>
                    <span class="hljs-string">"You should create a credit note instead. "</span>
                    <span class="hljs-string">"Use the action menu to transform it into a credit note or refund."</span>
                ))

            <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> invoice.partner_id:
                <span class="hljs-keyword">if</span> invoice.is_sale_document():
                    <span class="hljs-keyword">raise</span> UserError(_(<span class="hljs-string">"The field 'Customer' is required, please complete it to validate the Customer Invoice."</span>))
                <span class="hljs-keyword">elif</span> invoice.is_purchase_document():
                    <span class="hljs-keyword">raise</span> UserError(_(<span class="hljs-string">"The field 'Vendor' is required, please complete it to validate the Vendor Bill."</span>))

            <span class="hljs-comment"># Handle case when the invoice_date is not set. In that case, the invoice_date is set at today and then,</span>
            <span class="hljs-comment"># lines are recomputed accordingly.</span>
            <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> invoice.invoice_date:
                <span class="hljs-keyword">if</span> invoice.is_sale_document(include_receipts=<span class="hljs-literal">True</span>):
                    invoice.invoice_date = fields.Date.context_today(self)
                <span class="hljs-keyword">elif</span> invoice.is_purchase_document(include_receipts=<span class="hljs-literal">True</span>):
                    <span class="hljs-keyword">raise</span> UserError(_(<span class="hljs-string">"The Bill/Refund date is required to validate this document."</span>))

        <span class="hljs-keyword">for</span> move <span class="hljs-keyword">in</span> self:
            <span class="hljs-keyword">if</span> move.state <span class="hljs-keyword">in</span> [<span class="hljs-string">'posted'</span>, <span class="hljs-string">'cancel'</span>]:
                <span class="hljs-keyword">raise</span> UserError(_(<span class="hljs-string">'The entry %s (id %s) must be in draft.'</span>, move.name, move.<span class="hljs-built_in">id</span>))
            <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> move.line_ids.filtered(<span class="hljs-keyword">lambda</span> line: line.display_type <span class="hljs-keyword">not</span> <span class="hljs-keyword">in</span> (<span class="hljs-string">'line_section'</span>, <span class="hljs-string">'line_note'</span>)):
                <span class="hljs-keyword">raise</span> UserError(_(<span class="hljs-string">'You need to add a line before posting.'</span>))
            <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> soft <span class="hljs-keyword">and</span> move.auto_post != <span class="hljs-string">'no'</span> <span class="hljs-keyword">and</span> move.date &gt; fields.Date.context_today(self):
                date_msg = move.date.strftime(get_lang(self.env).date_format)
                <span class="hljs-keyword">raise</span> UserError(_(<span class="hljs-string">"This move is configured to be auto-posted on %s"</span>, date_msg))
            <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> move.journal_id.active:
                <span class="hljs-keyword">raise</span> UserError(_(
                    <span class="hljs-string">"You cannot post an entry in an archived journal (%(journal)s)"</span>,
                    journal=move.journal_id.display_name,
                ))
            <span class="hljs-keyword">if</span> move.display_inactive_currency_warning:
                <span class="hljs-keyword">raise</span> UserError(_(
                    <span class="hljs-string">"You cannot validate a document with an inactive currency: %s"</span>,
                    move.currency_id.name
                ))

            <span class="hljs-keyword">if</span> move.line_ids.account_id.filtered(<span class="hljs-keyword">lambda</span> account: account.deprecated) <span class="hljs-keyword">and</span> <span class="hljs-keyword">not</span> self._context.get(<span class="hljs-string">'skip_account_deprecation_check'</span>):
                <span class="hljs-keyword">raise</span> UserError(_(<span class="hljs-string">"A line of this move is using a deprecated account, you cannot post it."</span>))

        <span class="hljs-keyword">if</span> soft:
            future_moves = self.filtered(<span class="hljs-keyword">lambda</span> move: move.date &gt; fields.Date.context_today(self))
            <span class="hljs-keyword">for</span> move <span class="hljs-keyword">in</span> future_moves:
                <span class="hljs-keyword">if</span> move.auto_post == <span class="hljs-string">'no'</span>:
                    move.auto_post = <span class="hljs-string">'at_date'</span>
                msg = _(<span class="hljs-string">'This move will be posted at the accounting date: %(date)s'</span>, date=format_date(self.env, move.date))
                move.message_post(body=msg)
            to_post = self - future_moves
        <span class="hljs-keyword">else</span>:
            to_post = self

        <span class="hljs-keyword">for</span> move <span class="hljs-keyword">in</span> to_post:
            affects_tax_report = move._affect_tax_report()
            lock_dates = move._get_violated_lock_dates(move.date, affects_tax_report)
            <span class="hljs-keyword">if</span> lock_dates:
                move.date = move._get_accounting_date(move.invoice_date <span class="hljs-keyword">or</span> move.date, affects_tax_report)

        <span class="hljs-comment"># Create the analytic lines in batch is faster as it leads to less cache invalidation.</span>
        to_post.line_ids._create_analytic_lines()

        <span class="hljs-comment"># Trigger copying for recurring invoices</span>
        to_post.filtered(<span class="hljs-keyword">lambda</span> m: m.auto_post <span class="hljs-keyword">not</span> <span class="hljs-keyword">in</span> (<span class="hljs-string">'no'</span>, <span class="hljs-string">'at_date'</span>))._copy_recurring_entries()

        <span class="hljs-keyword">for</span> invoice <span class="hljs-keyword">in</span> to_post:
            <span class="hljs-comment"># Fix inconsistencies that may occure if the OCR has been editing the invoice at the same time of a user. We force the</span>
            <span class="hljs-comment"># partner on the lines to be the same as the one on the move, because that's the only one the user can see/edit.</span>
            wrong_lines = invoice.is_invoice() <span class="hljs-keyword">and</span> invoice.line_ids.filtered(<span class="hljs-keyword">lambda</span> aml:
                aml.partner_id != invoice.commercial_partner_id
                <span class="hljs-keyword">and</span> aml.display_type <span class="hljs-keyword">not</span> <span class="hljs-keyword">in</span> (<span class="hljs-string">'line_note'</span>, <span class="hljs-string">'line_section'</span>)
            )
            <span class="hljs-keyword">if</span> wrong_lines:
                wrong_lines.write({<span class="hljs-string">'partner_id'</span>: invoice.commercial_partner_id.<span class="hljs-built_in">id</span>})

        <span class="hljs-comment"># reconcile if state is in draft and move has reversal_entry_id set</span>
        draft_reverse_moves = to_post.filtered(<span class="hljs-keyword">lambda</span> move: move.reversed_entry_id <span class="hljs-keyword">and</span> move.reversed_entry_id.state == <span class="hljs-string">'posted'</span>)

        to_post.write({
            <span class="hljs-string">'state'</span>: <span class="hljs-string">'posted'</span>,
            <span class="hljs-string">'posted_before'</span>: <span class="hljs-literal">True</span>,
        })

        draft_reverse_moves.reversed_entry_id._reconcile_reversed_moves(draft_reverse_moves, self._context.get(<span class="hljs-string">'move_reverse_cancel'</span>, <span class="hljs-literal">False</span>))
        to_post.line_ids._reconcile_marked()

        <span class="hljs-keyword">for</span> invoice <span class="hljs-keyword">in</span> to_post:
            invoice.message_subscribe([
                p.<span class="hljs-built_in">id</span>
                <span class="hljs-keyword">for</span> p <span class="hljs-keyword">in</span> [invoice.partner_id]
                <span class="hljs-keyword">if</span> p <span class="hljs-keyword">not</span> <span class="hljs-keyword">in</span> invoice.sudo().message_partner_ids
            ])

            <span class="hljs-keyword">if</span> (
                invoice.is_sale_document()
                <span class="hljs-keyword">and</span> invoice.journal_id.sale_activity_type_id
                <span class="hljs-keyword">and</span> (invoice.journal_id.sale_activity_user_id <span class="hljs-keyword">or</span> invoice.invoice_user_id).<span class="hljs-built_in">id</span> <span class="hljs-keyword">not</span> <span class="hljs-keyword">in</span> (self.env.ref(<span class="hljs-string">'base.user_root'</span>).<span class="hljs-built_in">id</span>, <span class="hljs-literal">False</span>)
            ):
                invoice.activity_schedule(
                    date_deadline=<span class="hljs-built_in">min</span>((date <span class="hljs-keyword">for</span> date <span class="hljs-keyword">in</span> invoice.line_ids.mapped(<span class="hljs-string">'date_maturity'</span>) <span class="hljs-keyword">if</span> date), default=invoice.date),
                    activity_type_id=invoice.journal_id.sale_activity_type_id.<span class="hljs-built_in">id</span>,
                    summary=invoice.journal_id.sale_activity_note,
                    user_id=invoice.journal_id.sale_activity_user_id.<span class="hljs-built_in">id</span> <span class="hljs-keyword">or</span> invoice.invoice_user_id.<span class="hljs-built_in">id</span>,
                )

        customer_count, supplier_count = defaultdict(<span class="hljs-built_in">int</span>), defaultdict(<span class="hljs-built_in">int</span>)
        <span class="hljs-keyword">for</span> invoice <span class="hljs-keyword">in</span> to_post:
            <span class="hljs-keyword">if</span> invoice.is_sale_document():
                customer_count[invoice.partner_id] += <span class="hljs-number">1</span>
            <span class="hljs-keyword">elif</span> invoice.is_purchase_document():
                supplier_count[invoice.partner_id] += <span class="hljs-number">1</span>
            <span class="hljs-keyword">elif</span> invoice.move_type == <span class="hljs-string">'entry'</span>:
                sale_amls = invoice.line_ids.filtered(<span class="hljs-keyword">lambda</span> line: line.partner_id <span class="hljs-keyword">and</span> line.account_id.account_type == <span class="hljs-string">'asset_receivable'</span>)
                <span class="hljs-keyword">for</span> partner <span class="hljs-keyword">in</span> sale_amls.mapped(<span class="hljs-string">'partner_id'</span>):
                    customer_count[partner] += <span class="hljs-number">1</span>
                purchase_amls = invoice.line_ids.filtered(<span class="hljs-keyword">lambda</span> line: line.partner_id <span class="hljs-keyword">and</span> line.account_id.account_type == <span class="hljs-string">'liability_payable'</span>)
                <span class="hljs-keyword">for</span> partner <span class="hljs-keyword">in</span> purchase_amls.mapped(<span class="hljs-string">'partner_id'</span>):
                    supplier_count[partner] += <span class="hljs-number">1</span>
        <span class="hljs-keyword">for</span> partner, count <span class="hljs-keyword">in</span> customer_count.items():
            (partner | partner.commercial_partner_id)._increase_rank(<span class="hljs-string">'customer_rank'</span>, count)
        <span class="hljs-keyword">for</span> partner, count <span class="hljs-keyword">in</span> supplier_count.items():
            (partner | partner.commercial_partner_id)._increase_rank(<span class="hljs-string">'supplier_rank'</span>, count)

        <span class="hljs-comment"># Trigger action for paid invoices if amount is zero</span>
        to_post.filtered(
            <span class="hljs-keyword">lambda</span> m: m.is_invoice(include_receipts=<span class="hljs-literal">True</span>) <span class="hljs-keyword">and</span> m.currency_id.is_zero(m.amount_total)
        )._invoice_paid_hook()

        <span class="hljs-keyword">return</span> to_post

    <span class="hljs-keyword">def</span> <span class="hljs-title function_">_find_and_set_purchase_orders</span>(<span class="hljs-params">self, po_references, partner_id, amount_total, from_ocr=<span class="hljs-literal">False</span>, timeout=<span class="hljs-number">10</span></span>):
        <span class="hljs-comment"># hook to be used with purchase, so that vendor bills are sync/autocompleted with purchase orders</span>
        self.ensure_one()

    <span class="hljs-keyword">def</span> <span class="hljs-title function_">_link_bill_origin_to_purchase_orders</span>(<span class="hljs-params">self, timeout=<span class="hljs-number">10</span></span>):
        <span class="hljs-keyword">for</span> move <span class="hljs-keyword">in</span> self.filtered(<span class="hljs-keyword">lambda</span> m: m.move_type <span class="hljs-keyword">in</span> self.get_purchase_types()):
            references = [move.invoice_origin] <span class="hljs-keyword">if</span> move.invoice_origin <span class="hljs-keyword">else</span> []
            move._find_and_set_purchase_orders(references, move.partner_id.<span class="hljs-built_in">id</span>, move.amount_total, timeout)
        <span class="hljs-keyword">return</span> self

    <span class="hljs-comment"># -------------------------------------------------------------------------</span>
    <span class="hljs-comment"># PUBLIC ACTIONS</span>
    <span class="hljs-comment"># -------------------------------------------------------------------------</span>

    <span class="hljs-keyword">def</span> <span class="hljs-title function_">open_reconcile_view</span>(<span class="hljs-params">self</span>):
        <span class="hljs-keyword">return</span> self.line_ids.open_reconcile_view()

    <span class="hljs-keyword">def</span> <span class="hljs-title function_">action_open_business_doc</span>(<span class="hljs-params">self</span>):
        self.ensure_one()
        <span class="hljs-keyword">if</span> self.payment_id:
            name = _(<span class="hljs-string">"Payment"</span>)
            res_model = <span class="hljs-string">'account.payment'</span>
            res_id = self.payment_id.<span class="hljs-built_in">id</span>
        <span class="hljs-keyword">elif</span> self.statement_line_id:
            name = _(<span class="hljs-string">"Bank Transaction"</span>)
            res_model = <span class="hljs-string">'account.bank.statement.line'</span>
            res_id = self.statement_line_id.<span class="hljs-built_in">id</span>
        <span class="hljs-keyword">else</span>:
            name = _(<span class="hljs-string">"Journal Entry"</span>)
            res_model = <span class="hljs-string">'account.move'</span>
            res_id = self.<span class="hljs-built_in">id</span>

        <span class="hljs-keyword">return</span> {
            <span class="hljs-string">'name'</span>: name,
            <span class="hljs-string">'type'</span>: <span class="hljs-string">'ir.actions.act_window'</span>,
            <span class="hljs-string">'view_mode'</span>: <span class="hljs-string">'form'</span>,
            <span class="hljs-string">'views'</span>: [(<span class="hljs-literal">False</span>, <span class="hljs-string">'form'</span>)],
            <span class="hljs-string">'res_model'</span>: res_model,
            <span class="hljs-string">'res_id'</span>: res_id,
            <span class="hljs-string">'target'</span>: <span class="hljs-string">'current'</span>,
        }

    <span class="hljs-keyword">def</span> <span class="hljs-title function_">open_created_caba_entries</span>(<span class="hljs-params">self</span>):
        self.ensure_one()
        <span class="hljs-keyword">return</span> {
            <span class="hljs-string">'type'</span>: <span class="hljs-string">'ir.actions.act_window'</span>,
            <span class="hljs-string">'name'</span>: _(<span class="hljs-string">"Cash Basis Entries"</span>),
            <span class="hljs-string">'res_model'</span>: <span class="hljs-string">'account.move'</span>,
            <span class="hljs-string">'view_mode'</span>: <span class="hljs-string">'form'</span>,
            <span class="hljs-string">'domain'</span>: [(<span class="hljs-string">'id'</span>, <span class="hljs-string">'in'</span>, self.tax_cash_basis_created_move_ids.ids)],
            <span class="hljs-string">'views'</span>: [(self.env.ref(<span class="hljs-string">'account.view_move_tree'</span>).<span class="hljs-built_in">id</span>, <span class="hljs-string">'tree'</span>), (<span class="hljs-literal">False</span>, <span class="hljs-string">'form'</span>)],
        }

    <span class="hljs-keyword">def</span> <span class="hljs-title function_">open_duplicated_ref_bill_view</span>(<span class="hljs-params">self</span>):
        moves = self + self.duplicated_ref_ids
        action = self.env[<span class="hljs-string">"ir.actions.actions"</span>]._for_xml_id(<span class="hljs-string">"account.action_move_line_form"</span>)
        action[<span class="hljs-string">'domain'</span>] = [(<span class="hljs-string">'id'</span>, <span class="hljs-string">'in'</span>, moves.ids)]
        <span class="hljs-keyword">return</span> action

    <span class="hljs-keyword">def</span> <span class="hljs-title function_">action_switch_move_type</span>(<span class="hljs-params">self</span>):
        <span class="hljs-keyword">if</span> <span class="hljs-built_in">any</span>(move.posted_before <span class="hljs-keyword">for</span> move <span class="hljs-keyword">in</span> self):
            <span class="hljs-keyword">raise</span> ValidationError(_(<span class="hljs-string">"You cannot switch the type of a posted document."</span>))
        <span class="hljs-keyword">if</span> <span class="hljs-built_in">any</span>(move.move_type == <span class="hljs-string">"entry"</span> <span class="hljs-keyword">for</span> move <span class="hljs-keyword">in</span> self):
            <span class="hljs-keyword">raise</span> ValidationError(_(<span class="hljs-string">"This action isn't available for this document."</span>))

        <span class="hljs-keyword">for</span> move <span class="hljs-keyword">in</span> self:
            in_out, old_move_type = move.move_type.split(<span class="hljs-string">'_'</span>)
            new_move_type = <span class="hljs-string">f"<span class="hljs-subst">{in_out}</span>_<span class="hljs-subst">{<span class="hljs-string">'invoice'</span> <span class="hljs-keyword">if</span> old_move_type == <span class="hljs-string">'refund'</span> <span class="hljs-keyword">else</span> <span class="hljs-string">'refund'</span>}</span>"</span>
            move.name = <span class="hljs-literal">False</span>
            move.write({
                <span class="hljs-string">'move_type'</span>: new_move_type,
                <span class="hljs-string">'partner_bank_id'</span>: <span class="hljs-literal">False</span>,
                <span class="hljs-string">'currency_id'</span>: move.currency_id.<span class="hljs-built_in">id</span>,
            })
            <span class="hljs-keyword">if</span> move.amount_total &lt; <span class="hljs-number">0</span>:
                move.write({
                    <span class="hljs-string">'line_ids'</span>: [
                        Command.update(line.<span class="hljs-built_in">id</span>, {<span class="hljs-string">'quantity'</span>: -line.quantity})
                        <span class="hljs-keyword">for</span> line <span class="hljs-keyword">in</span> move.line_ids
                        <span class="hljs-keyword">if</span> line.display_type == <span class="hljs-string">'product'</span>
                    ]
                })

    <span class="hljs-keyword">def</span> <span class="hljs-title function_">action_register_payment</span>(<span class="hljs-params">self</span>):
        <span class="hljs-keyword">return</span> self.line_ids.action_register_payment()

    <span class="hljs-keyword">def</span> <span class="hljs-title function_">action_duplicate</span>(<span class="hljs-params">self</span>):
        <span class="hljs-comment"># offer the possibility to duplicate thanks to a button instead of a hidden menu, which is more visible</span>
        self.ensure_one()
        action = self.env[<span class="hljs-string">"ir.actions.actions"</span>]._for_xml_id(<span class="hljs-string">"account.action_move_journal_line"</span>)
        action[<span class="hljs-string">'context'</span>] = <span class="hljs-built_in">dict</span>(self.env.context)
        action[<span class="hljs-string">'context'</span>][<span class="hljs-string">'view_no_maturity'</span>] = <span class="hljs-literal">False</span>
        action[<span class="hljs-string">'views'</span>] = [(self.env.ref(<span class="hljs-string">'account.view_move_form'</span>).<span class="hljs-built_in">id</span>, <span class="hljs-string">'form'</span>)]
        action[<span class="hljs-string">'res_id'</span>] = self.copy().<span class="hljs-built_in">id</span>
        <span class="hljs-keyword">return</span> action

    <span class="hljs-keyword">def</span> <span class="hljs-title function_">action_send_and_print</span>(<span class="hljs-params">self</span>):
        template = self.env.ref(self._get_mail_template(), raise_if_not_found=<span class="hljs-literal">False</span>)

        <span class="hljs-keyword">if</span> <span class="hljs-built_in">any</span>(<span class="hljs-keyword">not</span> x.is_sale_document(include_receipts=<span class="hljs-literal">True</span>) <span class="hljs-keyword">for</span> x <span class="hljs-keyword">in</span> self):
            <span class="hljs-keyword">raise</span> UserError(_(<span class="hljs-string">"You can only send sales documents"</span>))

        <span class="hljs-keyword">return</span> {
            <span class="hljs-string">'name'</span>: _(<span class="hljs-string">"Send"</span>),
            <span class="hljs-string">'type'</span>: <span class="hljs-string">'ir.actions.act_window'</span>,
            <span class="hljs-string">'view_type'</span>: <span class="hljs-string">'form'</span>,
            <span class="hljs-string">'view_mode'</span>: <span class="hljs-string">'form'</span>,
            <span class="hljs-string">'res_model'</span>: <span class="hljs-string">'account.move.send'</span>,
            <span class="hljs-string">'target'</span>: <span class="hljs-string">'new'</span>,
            <span class="hljs-string">'context'</span>: {
                <span class="hljs-string">'active_ids'</span>: self.ids,
                <span class="hljs-string">'default_mail_template_id'</span>: template <span class="hljs-keyword">and</span> template.<span class="hljs-built_in">id</span> <span class="hljs-keyword">or</span> <span class="hljs-literal">False</span>,
            },
        }

    <span class="hljs-keyword">def</span> <span class="hljs-title function_">action_invoice_sent</span>(<span class="hljs-params">self</span>):
        <span class="hljs-string">""" Open a window to compose an email, with the edi invoice template
            message loaded by default
        """</span>
        self.ensure_one()

        report_action = self.action_send_and_print()
        <span class="hljs-keyword">if</span> self.env.is_admin() <span class="hljs-keyword">and</span> <span class="hljs-keyword">not</span> self.env.company.external_report_layout_id <span class="hljs-keyword">and</span> <span class="hljs-keyword">not</span> self.env.context.get(<span class="hljs-string">'discard_logo_check'</span>):
            <span class="hljs-keyword">return</span> self.env[<span class="hljs-string">'ir.actions.report'</span>]._action_configure_external_report_layout(report_action)

        <span class="hljs-keyword">return</span> report_action

    <span class="hljs-keyword">def</span> <span class="hljs-title function_">preview_invoice</span>(<span class="hljs-params">self</span>):
        self.ensure_one()
        <span class="hljs-keyword">return</span> {
            <span class="hljs-string">'type'</span>: <span class="hljs-string">'ir.actions.act_url'</span>,
            <span class="hljs-string">'target'</span>: <span class="hljs-string">'self'</span>,
            <span class="hljs-string">'url'</span>: self.get_portal_url(),
        }

    <span class="hljs-keyword">def</span> <span class="hljs-title function_">action_reverse</span>(<span class="hljs-params">self</span>):
        action = self.env[<span class="hljs-string">"ir.actions.actions"</span>]._for_xml_id(<span class="hljs-string">"account.action_view_account_move_reversal"</span>)

        <span class="hljs-keyword">if</span> self.is_invoice():
            action[<span class="hljs-string">'name'</span>] = _(<span class="hljs-string">'Credit Note'</span>)

        <span class="hljs-keyword">return</span> action

    <span class="hljs-keyword">def</span> <span class="hljs-title function_">action_post</span>(<span class="hljs-params">self</span>):
        moves_with_payments = self.filtered(<span class="hljs-string">'payment_id'</span>)
        other_moves = self - moves_with_payments
        <span class="hljs-keyword">if</span> moves_with_payments:
            moves_with_payments.payment_id.action_post()
        <span class="hljs-keyword">if</span> other_moves:
            other_moves._post(soft=<span class="hljs-literal">False</span>)
        <span class="hljs-keyword">return</span> <span class="hljs-literal">False</span>

    <span class="hljs-keyword">def</span> <span class="hljs-title function_">js_assign_outstanding_line</span>(<span class="hljs-params">self, line_id</span>):
        <span class="hljs-string">''' Called by the 'payment' widget to reconcile a suggested journal item to the present
        invoice.

        :param line_id: The id of the line to reconcile with the current invoice.
        '''</span>
        self.ensure_one()
        lines = self.env[<span class="hljs-string">'account.move.line'</span>].browse(line_id)
        lines += self.line_ids.filtered(<span class="hljs-keyword">lambda</span> line: line.account_id == lines[<span class="hljs-number">0</span>].account_id <span class="hljs-keyword">and</span> <span class="hljs-keyword">not</span> line.reconciled)
        <span class="hljs-keyword">return</span> lines.reconcile()

    <span class="hljs-keyword">def</span> <span class="hljs-title function_">js_remove_outstanding_partial</span>(<span class="hljs-params">self, partial_id</span>):
        <span class="hljs-string">''' Called by the 'payment' widget to remove a reconciled entry to the present invoice.

        :param partial_id: The id of an existing partial reconciled with the current invoice.
        '''</span>
        self.ensure_one()
        partial = self.env[<span class="hljs-string">'account.partial.reconcile'</span>].browse(partial_id)
        <span class="hljs-keyword">return</span> partial.unlink()

    <span class="hljs-keyword">def</span> <span class="hljs-title function_">button_set_checked</span>(<span class="hljs-params">self</span>):
        <span class="hljs-keyword">for</span> move <span class="hljs-keyword">in</span> self:
            move.to_check = <span class="hljs-literal">False</span>

    <span class="hljs-keyword">def</span> <span class="hljs-title function_">button_draft</span>(<span class="hljs-params">self</span>):
        <span class="hljs-keyword">if</span> <span class="hljs-built_in">any</span>(move.state <span class="hljs-keyword">not</span> <span class="hljs-keyword">in</span> (<span class="hljs-string">'cancel'</span>, <span class="hljs-string">'posted'</span>) <span class="hljs-keyword">for</span> move <span class="hljs-keyword">in</span> self):
            <span class="hljs-keyword">raise</span> UserError(_(<span class="hljs-string">"Only posted/cancelled journal entries can be reset to draft."</span>))

        exchange_move_ids = <span class="hljs-built_in">set</span>()
        <span class="hljs-keyword">if</span> self:
            self.env[<span class="hljs-string">'account.full.reconcile'</span>].flush_model([<span class="hljs-string">'exchange_move_id'</span>])
            self.env[<span class="hljs-string">'account.partial.reconcile'</span>].flush_model([<span class="hljs-string">'exchange_move_id'</span>])
            self._cr.execute(
                <span class="hljs-string">"""
                    SELECT DISTINCT sub.exchange_move_id
                    FROM (
                        SELECT exchange_move_id
                        FROM account_full_reconcile
                        WHERE exchange_move_id IN %s

                        UNION ALL

                        SELECT exchange_move_id
                        FROM account_partial_reconcile
                        WHERE exchange_move_id IN %s
                    ) AS sub
                """</span>,
                [<span class="hljs-built_in">tuple</span>(self.ids), <span class="hljs-built_in">tuple</span>(self.ids)],
            )
            exchange_move_ids = <span class="hljs-built_in">set</span>([row[<span class="hljs-number">0</span>] <span class="hljs-keyword">for</span> row <span class="hljs-keyword">in</span> self._cr.fetchall()])

        <span class="hljs-keyword">for</span> move <span class="hljs-keyword">in</span> self:
            <span class="hljs-keyword">if</span> move.<span class="hljs-built_in">id</span> <span class="hljs-keyword">in</span> exchange_move_ids:
                <span class="hljs-keyword">raise</span> UserError(_(<span class="hljs-string">'You cannot reset to draft an exchange difference journal entry.'</span>))
            <span class="hljs-keyword">if</span> move.tax_cash_basis_rec_id <span class="hljs-keyword">or</span> move.tax_cash_basis_origin_move_id:
                <span class="hljs-comment"># If the reconciliation was undone, move.tax_cash_basis_rec_id will be empty;</span>
                <span class="hljs-comment"># but we still don't want to allow setting the caba entry to draft</span>
                <span class="hljs-comment"># (it'll have been reversed automatically, so no manual intervention is required),</span>
                <span class="hljs-comment"># so we also check tax_cash_basis_origin_move_id, which stays unchanged</span>
                <span class="hljs-comment"># (we need both, as tax_cash_basis_origin_move_id did not exist in older versions).</span>
                <span class="hljs-keyword">raise</span> UserError(_(<span class="hljs-string">'You cannot reset to draft a tax cash basis journal entry.'</span>))
            <span class="hljs-keyword">if</span> move.restrict_mode_hash_table <span class="hljs-keyword">and</span> move.state == <span class="hljs-string">'posted'</span>:
                <span class="hljs-keyword">raise</span> UserError(_(<span class="hljs-string">'You cannot modify a posted entry of this journal because it is in strict mode.'</span>))
            <span class="hljs-comment"># We remove all the analytics entries for this journal</span>
            move.mapped(<span class="hljs-string">'line_ids.analytic_line_ids'</span>).unlink()

        self.mapped(<span class="hljs-string">'line_ids'</span>).remove_move_reconcile()
        self.write({<span class="hljs-string">'state'</span>: <span class="hljs-string">'draft'</span>, <span class="hljs-string">'is_move_sent'</span>: <span class="hljs-literal">False</span>})

    <span class="hljs-keyword">def</span> <span class="hljs-title function_">button_request_cancel</span>(<span class="hljs-params">self</span>):
        <span class="hljs-string">""" Hook allowing the localizations to request a cancellation from the government before cancelling the invoice. """</span>
        self.ensure_one()
        <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> self.need_cancel_request:
            <span class="hljs-keyword">raise</span> UserError(_(<span class="hljs-string">"You can only request a cancellation for invoice sent to the government."</span>))

    <span class="hljs-keyword">def</span> <span class="hljs-title function_">button_cancel</span>(<span class="hljs-params">self</span>):
        <span class="hljs-comment"># Shortcut to move from posted to cancelled directly. This is useful for E-invoices that must not be changed</span>
        <span class="hljs-comment"># when sent to the government.</span>
        moves_to_reset_draft = self.filtered(<span class="hljs-keyword">lambda</span> x: x.state == <span class="hljs-string">'posted'</span>)
        <span class="hljs-keyword">if</span> moves_to_reset_draft:
            moves_to_reset_draft.button_draft()

        <span class="hljs-keyword">if</span> <span class="hljs-built_in">any</span>(move.state != <span class="hljs-string">'draft'</span> <span class="hljs-keyword">for</span> move <span class="hljs-keyword">in</span> self):
            <span class="hljs-keyword">raise</span> UserError(_(<span class="hljs-string">"Only draft journal entries can be cancelled."</span>))

        self.write({<span class="hljs-string">'auto_post'</span>: <span class="hljs-string">'no'</span>, <span class="hljs-string">'state'</span>: <span class="hljs-string">'cancel'</span>})

    <span class="hljs-keyword">def</span> <span class="hljs-title function_">action_activate_currency</span>(<span class="hljs-params">self</span>):
        self.currency_id.filtered(<span class="hljs-keyword">lambda</span> currency: <span class="hljs-keyword">not</span> currency.active).write({<span class="hljs-string">'active'</span>: <span class="hljs-literal">True</span>})

    <span class="hljs-keyword">def</span> <span class="hljs-title function_">_get_mail_template</span>(<span class="hljs-params">self</span>):
        <span class="hljs-string">"""
        :return: the correct mail template based on the current move type
        """</span>
        <span class="hljs-keyword">return</span> (
            <span class="hljs-string">'account.email_template_edi_credit_note'</span>
            <span class="hljs-keyword">if</span> <span class="hljs-built_in">all</span>(move.move_type == <span class="hljs-string">'out_refund'</span> <span class="hljs-keyword">for</span> move <span class="hljs-keyword">in</span> self)
            <span class="hljs-keyword">else</span> <span class="hljs-string">'account.email_template_edi_invoice'</span>
        )

    <span class="hljs-keyword">def</span> <span class="hljs-title function_">_notify_get_recipients_groups</span>(<span class="hljs-params">self, message, model_description, msg_vals=<span class="hljs-literal">None</span></span>):
        groups = <span class="hljs-built_in">super</span>()._notify_get_recipients_groups(message, model_description, msg_vals=msg_vals)
        self.ensure_one()

        <span class="hljs-keyword">if</span> self.move_type != <span class="hljs-string">'entry'</span>:
            local_msg_vals = <span class="hljs-built_in">dict</span>(msg_vals <span class="hljs-keyword">or</span> {})
            self._portal_ensure_token()
            access_link = self._notify_get_action_link(<span class="hljs-string">'view'</span>, **local_msg_vals, access_token=self.access_token)

            <span class="hljs-comment"># Create a new group for partners that have been manually added as recipients.</span>
            <span class="hljs-comment"># Those partners should have access to the invoice.</span>
            button_access = {<span class="hljs-string">'url'</span>: access_link} <span class="hljs-keyword">if</span> access_link <span class="hljs-keyword">else</span> {}
            recipient_group = (
                <span class="hljs-string">'additional_intended_recipient'</span>,
                <span class="hljs-keyword">lambda</span> pdata: pdata[<span class="hljs-string">'id'</span>] <span class="hljs-keyword">in</span> local_msg_vals.get(<span class="hljs-string">'partner_ids'</span>, []) <span class="hljs-keyword">and</span> pdata[<span class="hljs-string">'id'</span>] != self.partner_id.<span class="hljs-built_in">id</span>,
                {
                    <span class="hljs-string">'has_button_access'</span>: <span class="hljs-literal">True</span>,
                    <span class="hljs-string">'button_access'</span>: button_access,
                }
            )
            groups.insert(<span class="hljs-number">0</span>, recipient_group)

        <span class="hljs-keyword">return</span> groups

    <span class="hljs-keyword">def</span> <span class="hljs-title function_">_get_report_base_filename</span>(<span class="hljs-params">self</span>):
        <span class="hljs-keyword">return</span> self._get_move_display_name()

    <span class="hljs-comment"># -------------------------------------------------------------------------</span>
    <span class="hljs-comment"># CRON</span>
    <span class="hljs-comment"># -------------------------------------------------------------------------</span>

    <span class="hljs-keyword">def</span> <span class="hljs-title function_">_autopost_draft_entries</span>(<span class="hljs-params">self</span>):
        <span class="hljs-string">''' This method is called from a cron job.
        It is used to post entries such as those created by the module
        account_asset and recurring entries created in _post().
        '''</span>
        moves = self.search([
            (<span class="hljs-string">'state'</span>, <span class="hljs-string">'='</span>, <span class="hljs-string">'draft'</span>),
            (<span class="hljs-string">'date'</span>, <span class="hljs-string">'&lt;='</span>, fields.Date.context_today(self)),
            (<span class="hljs-string">'auto_post'</span>, <span class="hljs-string">'!='</span>, <span class="hljs-string">'no'</span>),
            (<span class="hljs-string">'to_check'</span>, <span class="hljs-string">'='</span>, <span class="hljs-literal">False</span>),
        ], limit=<span class="hljs-number">100</span>)

        <span class="hljs-keyword">try</span>:  <span class="hljs-comment"># try posting in batch</span>
            <span class="hljs-keyword">with</span> self.env.cr.savepoint():
                moves._post()
        <span class="hljs-keyword">except</span> UserError:  <span class="hljs-comment"># if at least one move cannot be posted, handle moves one by one</span>
            <span class="hljs-keyword">for</span> move <span class="hljs-keyword">in</span> moves:
                <span class="hljs-keyword">try</span>:
                    <span class="hljs-keyword">with</span> self.env.cr.savepoint():
                        move._post()
                <span class="hljs-keyword">except</span> UserError <span class="hljs-keyword">as</span> e:
                    move.to_check = <span class="hljs-literal">True</span>
                    msg = _(<span class="hljs-string">'The move could not be posted for the following reason: %(error_message)s'</span>, error_message=e)
                    move.message_post(body=msg, message_type=<span class="hljs-string">'comment'</span>)

        <span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(moves) == <span class="hljs-number">100</span>:  <span class="hljs-comment"># assumes there are more whenever search hits limit</span>
            self.env.ref(<span class="hljs-string">'account.ir_cron_auto_post_draft_entry'</span>)._trigger()

<span class="hljs-meta">    @api.model</span>
    <span class="hljs-keyword">def</span> <span class="hljs-title function_">_cron_account_move_send</span>(<span class="hljs-params">self, job_count=<span class="hljs-number">10</span></span>):
        <span class="hljs-string">""" Handle Send &amp; Print async processing.
        :param job_count: maximum number of jobs to process if specified.
        """</span>
        <span class="hljs-keyword">def</span> <span class="hljs-title function_">get_account_notification</span>(<span class="hljs-params">partner, moves, is_success</span>):
            <span class="hljs-keyword">return</span> [
                partner,
                <span class="hljs-string">'account_notification'</span>,
                {
                    <span class="hljs-string">'type'</span>: <span class="hljs-string">'success'</span> <span class="hljs-keyword">if</span> is_success <span class="hljs-keyword">else</span> <span class="hljs-string">'warning'</span>,
                    <span class="hljs-string">'title'</span>: _(<span class="hljs-string">'Invoices sent'</span>) <span class="hljs-keyword">if</span> is_success <span class="hljs-keyword">else</span> _(<span class="hljs-string">'Invoices in error'</span>),
                    <span class="hljs-string">'message'</span>: _(<span class="hljs-string">'Invoices sent successfully.'</span>) <span class="hljs-keyword">if</span> is_success <span class="hljs-keyword">else</span> _(
                        <span class="hljs-string">"One or more invoices couldn't be processed."</span>),
                    <span class="hljs-string">'action_button'</span>: {
                        <span class="hljs-string">'name'</span>: _(<span class="hljs-string">'Open'</span>),
                        <span class="hljs-string">'action_name'</span>: _(<span class="hljs-string">'Sent invoices'</span>) <span class="hljs-keyword">if</span> is_success <span class="hljs-keyword">else</span> _(<span class="hljs-string">'Invoices in error'</span>),
                        <span class="hljs-string">'model'</span>: <span class="hljs-string">'account.move'</span>,
                        <span class="hljs-string">'res_ids'</span>: moves.ids,
                    },
                },
            ]

        limit = job_count + <span class="hljs-number">1</span>
        to_process = self.env[<span class="hljs-string">'account.move'</span>]._read_group(
            [(<span class="hljs-string">'send_and_print_values'</span>, <span class="hljs-string">'!='</span>, <span class="hljs-literal">False</span>)],
            groupby=[<span class="hljs-string">'company_id'</span>],
            aggregates=[<span class="hljs-string">'id:recordset'</span>],
            limit=limit,
        )
        need_retrigger = <span class="hljs-built_in">len</span>(to_process) &gt; job_count
        <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> to_process:
            <span class="hljs-keyword">return</span>

        <span class="hljs-keyword">for</span> _company, moves <span class="hljs-keyword">in</span> to_process[:job_count]:
            <span class="hljs-keyword">try</span>:
                <span class="hljs-comment"># Lock moves</span>
                <span class="hljs-keyword">with</span> self.env.cr.savepoint(flush=<span class="hljs-literal">False</span>):
                    self._cr.execute(<span class="hljs-string">'SELECT * FROM account_move WHERE id IN %s FOR UPDATE NOWAIT'</span>, [<span class="hljs-built_in">tuple</span>(moves.ids)])

            <span class="hljs-keyword">except</span> OperationalError <span class="hljs-keyword">as</span> e:
                <span class="hljs-keyword">if</span> e.pgcode == <span class="hljs-string">'55P03'</span>:
                    _logger.debug(<span class="hljs-string">'Another transaction already locked documents rows. Cannot process documents.'</span>)
                <span class="hljs-keyword">else</span>:
                    <span class="hljs-keyword">raise</span>

            <span class="hljs-comment"># Retrieve res.partner that executed the Send &amp; Print wizard</span>
            sp_partner_ids = <span class="hljs-built_in">set</span>(moves.mapped(<span class="hljs-keyword">lambda</span> move: move.send_and_print_values.get(<span class="hljs-string">'sp_partner_id'</span>)))
            sp_partners = self.env[<span class="hljs-string">'res.partner'</span>].browse(sp_partner_ids)
            moves_map = {
                partner: moves.filtered(<span class="hljs-keyword">lambda</span> m: m.send_and_print_values[<span class="hljs-string">'sp_partner_id'</span>] == partner.<span class="hljs-built_in">id</span>)
                <span class="hljs-keyword">for</span> partner <span class="hljs-keyword">in</span> sp_partners
            }

            self.env[<span class="hljs-string">'account.move.send'</span>]._process_send_and_print(moves)

            notifications = []
            <span class="hljs-keyword">for</span> partner, partner_moves <span class="hljs-keyword">in</span> moves_map.items():
                partner_moves_error = partner_moves.filtered(<span class="hljs-keyword">lambda</span> m: m.send_and_print_values <span class="hljs-keyword">and</span> m.send_and_print_values.get(<span class="hljs-string">'error'</span>))
                <span class="hljs-keyword">if</span> partner_moves_error:
                    notifications.append(get_account_notification(partner, partner_moves_error, <span class="hljs-literal">False</span>))
                partner_moves_success = partner_moves - partner_moves_error
                <span class="hljs-keyword">if</span> partner_moves_success:
                    notifications.append(get_account_notification(partner, partner_moves_success, <span class="hljs-literal">True</span>))
                partner_moves_error.send_and_print_values = <span class="hljs-literal">False</span>

            self.env[<span class="hljs-string">'bus.bus'</span>]._sendmany(notifications)

        <span class="hljs-keyword">if</span> need_retrigger:
            self.env.ref(<span class="hljs-string">'account.ir_cron_account_move_send'</span>)._trigger()

    <span class="hljs-comment"># -------------------------------------------------------------------------</span>
    <span class="hljs-comment"># HELPER METHODS</span>
    <span class="hljs-comment"># -------------------------------------------------------------------------</span>

<span class="hljs-meta">    @api.model</span>
    <span class="hljs-keyword">def</span> <span class="hljs-title function_">get_invoice_types</span>(<span class="hljs-params">self, include_receipts=<span class="hljs-literal">False</span></span>):
        <span class="hljs-keyword">return</span> self.get_sale_types(include_receipts) + self.get_purchase_types(include_receipts)

    <span class="hljs-keyword">def</span> <span class="hljs-title function_">is_invoice</span>(<span class="hljs-params">self, include_receipts=<span class="hljs-literal">False</span></span>):
        <span class="hljs-keyword">return</span> self.is_sale_document(include_receipts) <span class="hljs-keyword">or</span> self.is_purchase_document(include_receipts)

    <span class="hljs-keyword">def</span> <span class="hljs-title function_">is_entry</span>(<span class="hljs-params">self</span>):
        <span class="hljs-keyword">return</span> self.move_type == <span class="hljs-string">'entry'</span>

<span class="hljs-meta">    @api.model</span>
    <span class="hljs-keyword">def</span> <span class="hljs-title function_">get_sale_types</span>(<span class="hljs-params">self, include_receipts=<span class="hljs-literal">False</span></span>):
        <span class="hljs-keyword">return</span> [<span class="hljs-string">'out_invoice'</span>, <span class="hljs-string">'out_refund'</span>] + (include_receipts <span class="hljs-keyword">and</span> [<span class="hljs-string">'out_receipt'</span>] <span class="hljs-keyword">or</span> [])

    <span class="hljs-keyword">def</span> <span class="hljs-title function_">is_sale_document</span>(<span class="hljs-params">self, include_receipts=<span class="hljs-literal">False</span></span>):
        <span class="hljs-keyword">return</span> self.move_type <span class="hljs-keyword">in</span> self.get_sale_types(include_receipts)

<span class="hljs-meta">    @api.model</span>
    <span class="hljs-keyword">def</span> <span class="hljs-title function_">get_purchase_types</span>(<span class="hljs-params">self, include_receipts=<span class="hljs-literal">False</span></span>):
        <span class="hljs-keyword">return</span> [<span class="hljs-string">'in_invoice'</span>, <span class="hljs-string">'in_refund'</span>] + (include_receipts <span class="hljs-keyword">and</span> [<span class="hljs-string">'in_receipt'</span>] <span class="hljs-keyword">or</span> [])

    <span class="hljs-keyword">def</span> <span class="hljs-title function_">is_purchase_document</span>(<span class="hljs-params">self, include_receipts=<span class="hljs-literal">False</span></span>):
        <span class="hljs-keyword">return</span> self.move_type <span class="hljs-keyword">in</span> self.get_purchase_types(include_receipts)

<span class="hljs-meta">    @api.model</span>
    <span class="hljs-keyword">def</span> <span class="hljs-title function_">get_inbound_types</span>(<span class="hljs-params">self, include_receipts=<span class="hljs-literal">True</span></span>):
        <span class="hljs-keyword">return</span> [<span class="hljs-string">'out_invoice'</span>, <span class="hljs-string">'in_refund'</span>] + (include_receipts <span class="hljs-keyword">and</span> [<span class="hljs-string">'out_receipt'</span>] <span class="hljs-keyword">or</span> [])

    <span class="hljs-keyword">def</span> <span class="hljs-title function_">is_inbound</span>(<span class="hljs-params">self, include_receipts=<span class="hljs-literal">True</span></span>):
        <span class="hljs-keyword">return</span> self.move_type <span class="hljs-keyword">in</span> self.get_inbound_types(include_receipts)

<span class="hljs-meta">    @api.model</span>
    <span class="hljs-keyword">def</span> <span class="hljs-title function_">get_outbound_types</span>(<span class="hljs-params">self, include_receipts=<span class="hljs-literal">True</span></span>):
        <span class="hljs-keyword">return</span> [<span class="hljs-string">'in_invoice'</span>, <span class="hljs-string">'out_refund'</span>] + (include_receipts <span class="hljs-keyword">and</span> [<span class="hljs-string">'in_receipt'</span>] <span class="hljs-keyword">or</span> [])

    <span class="hljs-keyword">def</span> <span class="hljs-title function_">is_outbound</span>(<span class="hljs-params">self, include_receipts=<span class="hljs-literal">True</span></span>):
        <span class="hljs-keyword">return</span> self.move_type <span class="hljs-keyword">in</span> self.get_outbound_types(include_receipts)

    <span class="hljs-keyword">def</span> <span class="hljs-title function_">_get_accounting_date</span>(<span class="hljs-params">self, invoice_date, has_tax</span>):
        <span class="hljs-string">"""Get correct accounting date for previous periods, taking tax lock date into account.
        When registering an invoice in the past, we still want the sequence to be increasing.
        We then take the last day of the period, depending on the sequence format.

        If there is a tax lock date and there are taxes involved, we register the invoice at the
        last date of the first open period.
        :param invoice_date (datetime.date): The invoice date
        :param has_tax (bool): Iff any taxes are involved in the lines of the invoice
        :return (datetime.date):
        """</span>
        lock_dates = self._get_violated_lock_dates(invoice_date, has_tax)
        today = fields.Date.context_today(self)
        highest_name = self.highest_name <span class="hljs-keyword">or</span> self._get_last_sequence(relaxed=<span class="hljs-literal">True</span>)
        number_reset = self._deduce_sequence_number_reset(highest_name)
        <span class="hljs-keyword">if</span> lock_dates:
            invoice_date = lock_dates[-<span class="hljs-number">1</span>][<span class="hljs-number">0</span>] + timedelta(days=<span class="hljs-number">1</span>)
        <span class="hljs-keyword">if</span> self.is_sale_document(include_receipts=<span class="hljs-literal">True</span>):
            <span class="hljs-keyword">if</span> lock_dates:
                <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> highest_name <span class="hljs-keyword">or</span> number_reset == <span class="hljs-string">'month'</span>:
                    <span class="hljs-keyword">return</span> <span class="hljs-built_in">min</span>(today, date_utils.get_month(invoice_date)[<span class="hljs-number">1</span>])
                <span class="hljs-keyword">elif</span> number_reset == <span class="hljs-string">'year'</span>:
                    <span class="hljs-keyword">return</span> <span class="hljs-built_in">min</span>(today, date_utils.end_of(invoice_date, <span class="hljs-string">'year'</span>))
        <span class="hljs-keyword">else</span>:
            <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> highest_name <span class="hljs-keyword">or</span> number_reset == <span class="hljs-string">'month'</span>:
                <span class="hljs-keyword">if</span> (today.year, today.month) &gt; (invoice_date.year, invoice_date.month):
                    <span class="hljs-keyword">return</span> date_utils.get_month(invoice_date)[<span class="hljs-number">1</span>]
                <span class="hljs-keyword">else</span>:
                    <span class="hljs-keyword">return</span> <span class="hljs-built_in">max</span>(invoice_date, today)
            <span class="hljs-keyword">elif</span> number_reset == <span class="hljs-string">'year'</span>:
                <span class="hljs-keyword">if</span> today.year &gt; invoice_date.year:
                    <span class="hljs-keyword">return</span> date(invoice_date.year, <span class="hljs-number">12</span>, <span class="hljs-number">31</span>)
                <span class="hljs-keyword">else</span>:
                    <span class="hljs-keyword">return</span> <span class="hljs-built_in">max</span>(invoice_date, today)
        <span class="hljs-keyword">return</span> invoice_date

    <span class="hljs-keyword">def</span> <span class="hljs-title function_">_get_violated_lock_dates</span>(<span class="hljs-params">self, invoice_date, has_tax</span>):
        <span class="hljs-string">"""Get all the lock dates affecting the current invoice_date.
        :param invoice_date: The invoice date
        :param has_tax: If any taxes are involved in the lines of the invoice
        :return: a list of tuples containing the lock dates affecting this move, ordered chronologically.
        """</span>
        <span class="hljs-keyword">return</span> self.company_id._get_violated_lock_dates(invoice_date, has_tax)

    <span class="hljs-keyword">def</span> <span class="hljs-title function_">_get_lock_date_message</span>(<span class="hljs-params">self, invoice_date, has_tax</span>):
        <span class="hljs-string">"""Get a message describing the latest lock date affecting the specified date.
        :param invoice_date: The date to be checked
        :param has_tax: If any taxes are involved in the lines of the invoice
        :return: a message describing the latest lock date affecting this move and the date it will be
                 accounted on if posted, or False if no lock dates affect this move.
        """</span>
        lock_dates = self._get_violated_lock_dates(invoice_date, has_tax)
        <span class="hljs-keyword">if</span> lock_dates:
            invoice_date = self._get_accounting_date(invoice_date, has_tax)
            lock_date, lock_type = lock_dates[-<span class="hljs-number">1</span>]
            tax_lock_date_message = _(
                <span class="hljs-string">"The date is being set prior to the %(lock_type)s lock date %(lock_date)s. "</span>
                <span class="hljs-string">"The Journal Entry will be accounted on %(invoice_date)s upon posting."</span>,
                lock_type=lock_type,
                lock_date=format_date(self.env, lock_date),
                invoice_date=format_date(self.env, invoice_date))
            <span class="hljs-keyword">return</span> tax_lock_date_message
        <span class="hljs-keyword">return</span> <span class="hljs-literal">False</span>

<span class="hljs-meta">    @api.model</span>
    <span class="hljs-keyword">def</span> <span class="hljs-title function_">_move_dict_to_preview_vals</span>(<span class="hljs-params">self, move_vals, currency_id=<span class="hljs-literal">None</span></span>):
        preview_vals = {
            <span class="hljs-string">'group_name'</span>: <span class="hljs-string">"%s, %s"</span> % (format_date(self.env, move_vals[<span class="hljs-string">'date'</span>]) <span class="hljs-keyword">or</span> _(<span class="hljs-string">'[Not set]'</span>), move_vals[<span class="hljs-string">'ref'</span>]),
            <span class="hljs-string">'items_vals'</span>: move_vals[<span class="hljs-string">'line_ids'</span>],
        }
        <span class="hljs-keyword">for</span> line <span class="hljs-keyword">in</span> preview_vals[<span class="hljs-string">'items_vals'</span>]:
            <span class="hljs-keyword">if</span> <span class="hljs-string">'partner_id'</span> <span class="hljs-keyword">in</span> line[<span class="hljs-number">2</span>]:
                <span class="hljs-comment"># sudo is needed to compute display_name in a multi companies environment</span>
                line[<span class="hljs-number">2</span>][<span class="hljs-string">'partner_id'</span>] = self.env[<span class="hljs-string">'res.partner'</span>].browse(line[<span class="hljs-number">2</span>][<span class="hljs-string">'partner_id'</span>]).sudo().display_name
            line[<span class="hljs-number">2</span>][<span class="hljs-string">'account_id'</span>] = self.env[<span class="hljs-string">'account.account'</span>].browse(line[<span class="hljs-number">2</span>][<span class="hljs-string">'account_id'</span>]).display_name <span class="hljs-keyword">or</span> _(<span class="hljs-string">'Destination Account'</span>)
            line[<span class="hljs-number">2</span>][<span class="hljs-string">'debit'</span>] = currency_id <span class="hljs-keyword">and</span> formatLang(self.env, line[<span class="hljs-number">2</span>][<span class="hljs-string">'debit'</span>], currency_obj=currency_id) <span class="hljs-keyword">or</span> line[<span class="hljs-number">2</span>][<span class="hljs-string">'debit'</span>]
            line[<span class="hljs-number">2</span>][<span class="hljs-string">'credit'</span>] = currency_id <span class="hljs-keyword">and</span> formatLang(self.env, line[<span class="hljs-number">2</span>][<span class="hljs-string">'credit'</span>], currency_obj=currency_id) <span class="hljs-keyword">or</span> line[<span class="hljs-number">2</span>][<span class="hljs-string">'debit'</span>]
        <span class="hljs-keyword">return</span> preview_vals

    <span class="hljs-keyword">def</span> <span class="hljs-title function_">_generate_qr_code</span>(<span class="hljs-params">self, silent_errors=<span class="hljs-literal">False</span></span>):
        <span class="hljs-string">""" Generates and returns a QR-code generation URL for this invoice,
        raising an error message if something is misconfigured.

        The chosen QR generation method is the one set in qr_method field if there is one,
        or the first eligible one found. If this search had to be performed and
        and eligible method was found, qr_method field is set to this method before
        returning the URL. If no eligible QR method could be found, we return None.
        """</span>
        self.ensure_one()

        <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> self.display_qr_code:
            <span class="hljs-keyword">return</span> <span class="hljs-literal">None</span>

        qr_code_method = self.qr_code_method
        <span class="hljs-keyword">if</span> qr_code_method:
            <span class="hljs-comment"># If the user set a qr code generator manually, we check that we can use it</span>
            error_msg = self.partner_bank_id._get_error_messages_for_qr(self.qr_code_method, self.partner_id, self.currency_id)
            <span class="hljs-keyword">if</span> error_msg:
                <span class="hljs-keyword">raise</span> UserError(error_msg)
        <span class="hljs-keyword">else</span>:
            <span class="hljs-comment"># Else we find one that's eligible and assign it to the invoice</span>
            <span class="hljs-keyword">for</span> candidate_method, _candidate_name <span class="hljs-keyword">in</span> self.env[<span class="hljs-string">'res.partner.bank'</span>].get_available_qr_methods_in_sequence():
                error_msg = self.partner_bank_id._get_error_messages_for_qr(candidate_method, self.partner_id, self.currency_id)
                <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> error_msg:
                    qr_code_method = candidate_method
                    <span class="hljs-keyword">break</span>

        <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> qr_code_method:
            <span class="hljs-comment"># No eligible method could be found; we can't generate the QR-code</span>
            <span class="hljs-keyword">return</span> <span class="hljs-literal">None</span>

        unstruct_ref = self.ref <span class="hljs-keyword">if</span> self.ref <span class="hljs-keyword">else</span> self.name
        rslt = self.partner_bank_id.build_qr_code_base64(self.amount_residual, unstruct_ref, self.payment_reference, self.currency_id, self.partner_id, qr_code_method, silent_errors=silent_errors)

        <span class="hljs-comment"># We only set qr_code_method after generating the url; otherwise, it</span>
        <span class="hljs-comment"># could be set even in case of a failure in the QR code generation</span>
        <span class="hljs-comment"># (which would change the field, but not refresh UI, making the displayed data inconsistent with db)</span>
        self.qr_code_method = qr_code_method

        <span class="hljs-keyword">return</span> rslt

    <span class="hljs-keyword">def</span> <span class="hljs-title function_">_get_pdf_and_send_invoice_vals</span>(<span class="hljs-params">self, template, **kwargs</span>):
        <span class="hljs-keyword">return</span> {
            <span class="hljs-string">'mail_template_id'</span>: template.<span class="hljs-built_in">id</span>,
            <span class="hljs-string">'move_ids'</span>: self.ids,
            <span class="hljs-string">'checkbox_send_mail'</span>: <span class="hljs-literal">True</span>,
            <span class="hljs-string">'checkbox_download'</span>: <span class="hljs-literal">False</span>,
            **kwargs,
        }

    <span class="hljs-keyword">def</span> <span class="hljs-title function_">_generate_pdf_and_send_invoice</span>(<span class="hljs-params">self, template, force_synchronous=<span class="hljs-literal">True</span>, allow_fallback_pdf=<span class="hljs-literal">True</span>, bypass_download=<span class="hljs-literal">False</span>, **kwargs</span>):
        <span class="hljs-string">""" Generate the pdf for the current invoices and send them by mail using the send &amp; print wizard.
        :param force_synchronous:   Flag indicating if the method should be done synchronously.
        :param allow_fallback_pdf:  In case of error when generating the documents for invoices, generate a
                                    proforma PDF report instead.
        :param bypass_download: Don't trigger the action from action_send_and_print and get generated attachments_ids instead.
        """</span>
        composer_vals = self._get_pdf_and_send_invoice_vals(template, **kwargs)
        composer = self.env[<span class="hljs-string">'account.move.send'</span>].create(composer_vals)
        <span class="hljs-keyword">return</span> composer.action_send_and_print(force_synchronous=force_synchronous, allow_fallback_pdf=allow_fallback_pdf, bypass_download=bypass_download)

    <span class="hljs-keyword">def</span> <span class="hljs-title function_">get_invoice_pdf_report_attachment</span>(<span class="hljs-params">self</span>):
        <span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(self) &lt; <span class="hljs-number">2</span> <span class="hljs-keyword">and</span> self.invoice_pdf_report_id:
            <span class="hljs-comment"># if the Send &amp; Print succeeded</span>
            <span class="hljs-keyword">return</span> self.invoice_pdf_report_id.raw, self.invoice_pdf_report_id.name
        <span class="hljs-keyword">elif</span> <span class="hljs-built_in">len</span>(self) &lt; <span class="hljs-number">2</span> <span class="hljs-keyword">and</span> self.message_main_attachment_id:
            <span class="hljs-comment"># if the Send &amp; Print failed with fallback=True -&gt; proforma PDF</span>
            <span class="hljs-keyword">return</span> self.message_main_attachment_id.raw, self.message_main_attachment_id.name
        <span class="hljs-comment"># all other cases</span>
        pdf_content = self.env[<span class="hljs-string">'ir.actions.report'</span>]._render(<span class="hljs-string">'account.account_invoices'</span>, self.ids)[<span class="hljs-number">0</span>]
        pdf_name = self._get_invoice_report_filename() <span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(self) == <span class="hljs-number">1</span> <span class="hljs-keyword">else</span> <span class="hljs-string">"Invoices.pdf"</span>
        <span class="hljs-keyword">return</span> pdf_content, pdf_name

    <span class="hljs-keyword">def</span> <span class="hljs-title function_">_get_invoice_report_filename</span>(<span class="hljs-params">self, extension=<span class="hljs-string">'pdf'</span></span>):
        <span class="hljs-string">""" Get the filename of the generated invoice report with extension file. """</span>
        self.ensure_one()
        <span class="hljs-keyword">return</span> <span class="hljs-string">f"<span class="hljs-subst">{self.name.replace(<span class="hljs-string">'/'</span>, <span class="hljs-string">'_'</span>)}</span>.<span class="hljs-subst">{extension}</span>"</span>

    <span class="hljs-keyword">def</span> <span class="hljs-title function_">_get_invoice_proforma_pdf_report_filename</span>(<span class="hljs-params">self</span>):
        <span class="hljs-string">""" Get the filename of the generated proforma PDF invoice report. """</span>
        self.ensure_one()
        <span class="hljs-keyword">return</span> <span class="hljs-string">f"<span class="hljs-subst">{self.name.replace(<span class="hljs-string">'/'</span>, <span class="hljs-string">'_'</span>)}</span>_proforma.pdf"</span>

    <span class="hljs-keyword">def</span> <span class="hljs-title function_">_prepare_edi_vals_to_export</span>(<span class="hljs-params">self</span>):
        <span class="hljs-string">''' The purpose of this helper is to prepare values in order to export an invoice through the EDI system.
        This includes the computation of the tax details for each invoice line that could be very difficult to
        handle regarding the computation of the base amount.

        :return: A python dict containing default pre-processed values.
        '''</span>
        self.ensure_one()

        res = {
            <span class="hljs-string">'record'</span>: self,
            <span class="hljs-string">'balance_multiplicator'</span>: -<span class="hljs-number">1</span> <span class="hljs-keyword">if</span> self.is_inbound() <span class="hljs-keyword">else</span> <span class="hljs-number">1</span>,
            <span class="hljs-string">'invoice_line_vals_list'</span>: [],
        }

        <span class="hljs-comment"># Invoice lines details.</span>
        <span class="hljs-keyword">for</span> index, line <span class="hljs-keyword">in</span> <span class="hljs-built_in">enumerate</span>(self.invoice_line_ids.filtered(<span class="hljs-keyword">lambda</span> line: line.display_type == <span class="hljs-string">'product'</span>), start=<span class="hljs-number">1</span>):
            line_vals = line._prepare_edi_vals_to_export()
            line_vals[<span class="hljs-string">'index'</span>] = index
            res[<span class="hljs-string">'invoice_line_vals_list'</span>].append(line_vals)

        <span class="hljs-comment"># Totals.</span>
        res.update({
            <span class="hljs-string">'total_price_subtotal_before_discount'</span>: <span class="hljs-built_in">sum</span>(x[<span class="hljs-string">'price_subtotal_before_discount'</span>] <span class="hljs-keyword">for</span> x <span class="hljs-keyword">in</span> res[<span class="hljs-string">'invoice_line_vals_list'</span>]),
            <span class="hljs-string">'total_price_discount'</span>: <span class="hljs-built_in">sum</span>(x[<span class="hljs-string">'price_discount'</span>] <span class="hljs-keyword">for</span> x <span class="hljs-keyword">in</span> res[<span class="hljs-string">'invoice_line_vals_list'</span>]),
        })

        <span class="hljs-keyword">return</span> res

    <span class="hljs-keyword">def</span> <span class="hljs-title function_">_get_discount_allocation_account</span>(<span class="hljs-params">self</span>):
        <span class="hljs-keyword">if</span> self.is_sale_document(include_receipts=<span class="hljs-literal">True</span>) <span class="hljs-keyword">and</span> self.company_id.account_discount_expense_allocation_id:
            <span class="hljs-keyword">return</span> self.company_id.account_discount_expense_allocation_id
        <span class="hljs-keyword">if</span> self.is_purchase_document(include_receipts=<span class="hljs-literal">True</span>) <span class="hljs-keyword">and</span> self.company_id.account_discount_income_allocation_id:
            <span class="hljs-keyword">return</span> self.company_id.account_discount_income_allocation_id
        <span class="hljs-keyword">return</span> <span class="hljs-literal">None</span>

    <span class="hljs-comment"># -------------------------------------------------------------------------</span>
    <span class="hljs-comment"># TOOLING</span>
    <span class="hljs-comment"># -------------------------------------------------------------------------</span>

<span class="hljs-meta">    @api.model</span>
    <span class="hljs-keyword">def</span> <span class="hljs-title function_">_field_will_change</span>(<span class="hljs-params">self, record, vals, field_name</span>):
        <span class="hljs-keyword">if</span> field_name <span class="hljs-keyword">not</span> <span class="hljs-keyword">in</span> vals:
            <span class="hljs-keyword">return</span> <span class="hljs-literal">False</span>
        field = record._fields[field_name]
        <span class="hljs-keyword">if</span> field.<span class="hljs-built_in">type</span> == <span class="hljs-string">'many2one'</span>:
            <span class="hljs-keyword">return</span> record[field_name].<span class="hljs-built_in">id</span> != vals[field_name]
        <span class="hljs-keyword">if</span> field.<span class="hljs-built_in">type</span> == <span class="hljs-string">'many2many'</span>:
            current_ids = <span class="hljs-built_in">set</span>(record[field_name].ids)
            after_write_ids = <span class="hljs-built_in">set</span>(record.new({field_name: vals[field_name]})[field_name].ids)
            <span class="hljs-keyword">return</span> current_ids != after_write_ids
        <span class="hljs-keyword">if</span> field.<span class="hljs-built_in">type</span> == <span class="hljs-string">'one2many'</span>:
            <span class="hljs-keyword">return</span> <span class="hljs-literal">True</span>
        <span class="hljs-keyword">if</span> field.<span class="hljs-built_in">type</span> == <span class="hljs-string">'monetary'</span> <span class="hljs-keyword">and</span> record[field.get_currency_field(record)]:
            <span class="hljs-keyword">return</span> <span class="hljs-keyword">not</span> record[field.get_currency_field(record)].is_zero(record[field_name] - vals[field_name])
        <span class="hljs-keyword">if</span> field.<span class="hljs-built_in">type</span> == <span class="hljs-string">'float'</span>:
            record_value = field.convert_to_cache(record[field_name], record)
            to_write_value = field.convert_to_cache(vals[field_name], record)
            <span class="hljs-keyword">return</span> record_value != to_write_value
        <span class="hljs-keyword">return</span> record[field_name] != vals[field_name]

<span class="hljs-meta">    @api.model</span>
    <span class="hljs-keyword">def</span> <span class="hljs-title function_">_cleanup_write_orm_values</span>(<span class="hljs-params">self, record, vals</span>):
        cleaned_vals = <span class="hljs-built_in">dict</span>(vals)
        <span class="hljs-keyword">for</span> field_name <span class="hljs-keyword">in</span> vals.keys():
            <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> self._field_will_change(record, vals, field_name):
                <span class="hljs-keyword">del</span> cleaned_vals[field_name]
        <span class="hljs-keyword">return</span> cleaned_vals

<span class="hljs-meta">    @contextmanager</span>
    <span class="hljs-keyword">def</span> <span class="hljs-title function_">_disable_recursion</span>(<span class="hljs-params">self, container, key, default=<span class="hljs-literal">None</span>, target=<span class="hljs-literal">True</span></span>):
        <span class="hljs-string">"""Apply the context key to all environments inside this context manager.

        If this context key is already set on the recordsets, yield `True`.
        The recordsets modified are the one in the container, as well as all the
        `self` recordsets of the calling stack.
        This more or less gives the wanted context to all records inside of the
        context manager.

        :param container: A mutable dict that needs to at least contain the key
                          `records`. Can contain other items if changing the env
                          is needed.
        :param key: The context key to apply to the recordsets.
        :param default: the default value of the context key, if it isn't defined
                        yet in the context
        :param target: the value of the context key meaning that we shouldn't
                       recurse
        :return: True iff we should just exit the context manager
        """</span>

        disabled = container[<span class="hljs-string">'records'</span>].env.context.get(key, default) == target
        previous_values = {}
        previous_envs = <span class="hljs-built_in">set</span>(self.env.transaction.envs)
        <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> disabled:  <span class="hljs-comment"># it wasn't disabled yet, disable it now</span>
            <span class="hljs-keyword">for</span> env <span class="hljs-keyword">in</span> self.env.transaction.envs:
                previous_values[env] = env.context.get(key, EMPTY)
                env.context = frozendict({**env.context, key: target})
        <span class="hljs-keyword">try</span>:
            <span class="hljs-keyword">yield</span> disabled
        <span class="hljs-keyword">finally</span>:
            <span class="hljs-keyword">for</span> env, val <span class="hljs-keyword">in</span> previous_values.items():
                <span class="hljs-keyword">if</span> val != EMPTY:
                    env.context = frozendict({**env.context, key: val})
                <span class="hljs-keyword">else</span>:
                    env.context = frozendict({k: v <span class="hljs-keyword">for</span> k, v <span class="hljs-keyword">in</span> env.context.items() <span class="hljs-keyword">if</span> k != key})
            <span class="hljs-keyword">for</span> env <span class="hljs-keyword">in</span> (self.env.transaction.envs - previous_envs):
                <span class="hljs-keyword">if</span> key <span class="hljs-keyword">in</span> env.context:
                    env.context = frozendict({k: v <span class="hljs-keyword">for</span> k, v <span class="hljs-keyword">in</span> env.context.items() <span class="hljs-keyword">if</span> k != key})

    <span class="hljs-comment"># ------------------------------------------------------------</span>
    <span class="hljs-comment"># MAIL.THREAD</span>
    <span class="hljs-comment"># ------------------------------------------------------------</span>

<span class="hljs-meta">    @api.model</span>
    <span class="hljs-keyword">def</span> <span class="hljs-title function_">message_new</span>(<span class="hljs-params">self, msg_dict, custom_values=<span class="hljs-literal">None</span></span>):
        <span class="hljs-comment"># EXTENDS mail mail.thread</span>
        <span class="hljs-comment"># Add custom behavior when receiving a new invoice through the mail's gateway.</span>
        <span class="hljs-keyword">if</span> (custom_values <span class="hljs-keyword">or</span> {}).get(<span class="hljs-string">'move_type'</span>, <span class="hljs-string">'entry'</span>) <span class="hljs-keyword">not</span> <span class="hljs-keyword">in</span> (<span class="hljs-string">'out_invoice'</span>, <span class="hljs-string">'in_invoice'</span>):
            <span class="hljs-keyword">return</span> <span class="hljs-built_in">super</span>().message_new(msg_dict, custom_values=custom_values)

        company = self.env[<span class="hljs-string">'res.company'</span>].browse(custom_values[<span class="hljs-string">'company_id'</span>]) <span class="hljs-keyword">if</span> custom_values.get(<span class="hljs-string">'company_id'</span>) <span class="hljs-keyword">else</span> self.env.company

        <span class="hljs-keyword">def</span> <span class="hljs-title function_">is_internal_partner</span>(<span class="hljs-params">partner</span>):
            <span class="hljs-comment"># Helper to know if the partner is an internal one.</span>
            <span class="hljs-keyword">return</span> partner == company.partner_id <span class="hljs-keyword">or</span> (partner.user_ids <span class="hljs-keyword">and</span> <span class="hljs-built_in">all</span>(user._is_internal() <span class="hljs-keyword">for</span> user <span class="hljs-keyword">in</span> partner.user_ids))

        extra_domain = <span class="hljs-literal">False</span>
        <span class="hljs-keyword">if</span> custom_values.get(<span class="hljs-string">'company_id'</span>):
            extra_domain = [<span class="hljs-string">'|'</span>, (<span class="hljs-string">'company_id'</span>, <span class="hljs-string">'='</span>, custom_values[<span class="hljs-string">'company_id'</span>]), (<span class="hljs-string">'company_id'</span>, <span class="hljs-string">'='</span>, <span class="hljs-literal">False</span>)]

        <span class="hljs-comment"># Search for partners in copy.</span>
        cc_mail_addresses = email_split(msg_dict.get(<span class="hljs-string">'cc'</span>, <span class="hljs-string">''</span>))
        followers = [partner <span class="hljs-keyword">for</span> partner <span class="hljs-keyword">in</span> self._mail_find_partner_from_emails(cc_mail_addresses, extra_domain) <span class="hljs-keyword">if</span> partner]

        <span class="hljs-comment"># Search for partner that sent the mail.</span>
        from_mail_addresses = email_split(msg_dict.get(<span class="hljs-string">'from'</span>, <span class="hljs-string">''</span>))
        senders = partners = [partner <span class="hljs-keyword">for</span> partner <span class="hljs-keyword">in</span> self._mail_find_partner_from_emails(from_mail_addresses, extra_domain) <span class="hljs-keyword">if</span> partner]

        <span class="hljs-comment"># Search for partners using the user.</span>
        <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> senders:
            senders = partners = <span class="hljs-built_in">list</span>(self._mail_search_on_user(from_mail_addresses))

        <span class="hljs-keyword">if</span> partners:
            <span class="hljs-comment"># Check we are not in the case when an internal user forwarded the mail manually.</span>
            <span class="hljs-keyword">if</span> is_internal_partner(partners[<span class="hljs-number">0</span>]):
                <span class="hljs-comment"># Search for partners in the mail's body.</span>
                body_mail_addresses = <span class="hljs-built_in">set</span>(email_re.findall(msg_dict.get(<span class="hljs-string">'body'</span>)))
                partners = [
                    partner
                    <span class="hljs-keyword">for</span> partner <span class="hljs-keyword">in</span> self._mail_find_partner_from_emails(body_mail_addresses, extra_domain)
                    <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> is_internal_partner(partner) <span class="hljs-keyword">and</span> partner.company_id.<span class="hljs-built_in">id</span> <span class="hljs-keyword">in</span> (<span class="hljs-literal">False</span>, company.<span class="hljs-built_in">id</span>)
                ]
        <span class="hljs-comment"># Little hack: Inject the mail's subject in the body.</span>
        <span class="hljs-keyword">if</span> msg_dict.get(<span class="hljs-string">'subject'</span>) <span class="hljs-keyword">and</span> msg_dict.get(<span class="hljs-string">'body'</span>):
            msg_dict[<span class="hljs-string">'body'</span>] = Markup(<span class="hljs-string">'&lt;div&gt;&lt;div&gt;&lt;h3&gt;%s&lt;/h3&gt;&lt;/div&gt;%s&lt;/div&gt;'</span>) % (msg_dict[<span class="hljs-string">'subject'</span>], msg_dict[<span class="hljs-string">'body'</span>])

        <span class="hljs-comment"># Create the invoice.</span>
        values = {
            <span class="hljs-string">'name'</span>: <span class="hljs-string">'/'</span>,  <span class="hljs-comment"># we have to give the name otherwise it will be set to the mail's subject</span>
            <span class="hljs-string">'invoice_source_email'</span>: from_mail_addresses[<span class="hljs-number">0</span>],
            <span class="hljs-string">'partner_id'</span>: partners <span class="hljs-keyword">and</span> partners[<span class="hljs-number">0</span>].<span class="hljs-built_in">id</span> <span class="hljs-keyword">or</span> <span class="hljs-literal">False</span>,
        }
        move_ctx = self.with_context(default_move_type=custom_values[<span class="hljs-string">'move_type'</span>], default_journal_id=custom_values[<span class="hljs-string">'journal_id'</span>])
        move = <span class="hljs-built_in">super</span>(AccountMove, move_ctx).message_new(msg_dict, custom_values=values)
        move._compute_name()  <span class="hljs-comment"># because the name is given, we need to recompute in case it is the first invoice of the journal</span>

        <span class="hljs-comment"># Assign followers.</span>
        all_followers_ids = <span class="hljs-built_in">set</span>(partner.<span class="hljs-built_in">id</span> <span class="hljs-keyword">for</span> partner <span class="hljs-keyword">in</span> followers + senders + partners <span class="hljs-keyword">if</span> is_internal_partner(partner))
        move.message_subscribe(<span class="hljs-built_in">list</span>(all_followers_ids))
        <span class="hljs-keyword">return</span> move

    <span class="hljs-keyword">def</span> <span class="hljs-title function_">_message_post_after_hook</span>(<span class="hljs-params">self, new_message, message_values</span>):
        <span class="hljs-comment"># EXTENDS mail mail.thread</span>
        <span class="hljs-comment"># When posting a message, check the attachment to see if it's an invoice and update with the imported data.</span>
        res = <span class="hljs-built_in">super</span>()._message_post_after_hook(new_message, message_values)

        attachments = new_message.attachment_ids
        <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> attachments <span class="hljs-keyword">or</span> self.env.context.get(<span class="hljs-string">'no_new_invoice'</span>) <span class="hljs-keyword">or</span> <span class="hljs-keyword">not</span> self.is_invoice(include_receipts=<span class="hljs-literal">True</span>):
            <span class="hljs-keyword">return</span> res

        odoobot = self.env.ref(<span class="hljs-string">'base.partner_root'</span>)
        <span class="hljs-keyword">if</span> attachments <span class="hljs-keyword">and</span> self.state != <span class="hljs-string">'draft'</span>:
            self.message_post(body=_(<span class="hljs-string">'The invoice is not a draft, it was not updated from the attachment.'</span>),
                              message_type=<span class="hljs-string">'comment'</span>,
                              subtype_xmlid=<span class="hljs-string">'mail.mt_note'</span>,
                              author_id=odoobot.<span class="hljs-built_in">id</span>)
            <span class="hljs-keyword">return</span> res
        <span class="hljs-keyword">if</span> attachments <span class="hljs-keyword">and</span> self.invoice_line_ids:
            self.message_post(body=_(<span class="hljs-string">'The invoice already contains lines, it was not updated from the attachment.'</span>),
                              message_type=<span class="hljs-string">'comment'</span>,
                              subtype_xmlid=<span class="hljs-string">'mail.mt_note'</span>,
                              author_id=odoobot.<span class="hljs-built_in">id</span>)
            <span class="hljs-keyword">return</span> res

        <span class="hljs-comment"># As we are coming from the mail, we assume that ONE of the attachments</span>
        <span class="hljs-comment"># will enhance the invoice thanks to EDI / OCR / .. capabilities</span>
        results = self._extend_with_attachments(attachments, new=<span class="hljs-built_in">bool</span>(self._context.get(<span class="hljs-string">'from_alias'</span>)))
        attachments_per_invoice = defaultdict(self.env[<span class="hljs-string">'ir.attachment'</span>].browse)
        <span class="hljs-keyword">for</span> attachment, invoices <span class="hljs-keyword">in</span> results.items():
            invoices = invoices <span class="hljs-keyword">or</span> self
            <span class="hljs-keyword">for</span> invoice <span class="hljs-keyword">in</span> invoices:
                attachments_per_invoice[invoice] |= attachment

        <span class="hljs-keyword">for</span> invoice, attachments <span class="hljs-keyword">in</span> attachments_per_invoice.items():
            <span class="hljs-keyword">if</span> invoice == self:
                invoice.attachment_ids = attachments.ids
                new_message.attachment_ids = attachments.ids
                message_values.update({<span class="hljs-string">'res_id'</span>: self.<span class="hljs-built_in">id</span>, <span class="hljs-string">'attachment_ids'</span>: [Command.link(attachment.<span class="hljs-built_in">id</span>) <span class="hljs-keyword">for</span> attachment <span class="hljs-keyword">in</span> attachments]})
                <span class="hljs-built_in">super</span>(AccountMove, invoice)._message_post_after_hook(new_message, message_values)
            <span class="hljs-keyword">else</span>:
                sub_new_message = new_message.copy({<span class="hljs-string">'attachment_ids'</span>: attachments.ids})
                sub_message_values = {
                    **message_values,
                    <span class="hljs-string">'res_id'</span>: invoice.<span class="hljs-built_in">id</span>,
                    <span class="hljs-string">'attachment_ids'</span>: [Command.link(attachment.<span class="hljs-built_in">id</span>) <span class="hljs-keyword">for</span> attachment <span class="hljs-keyword">in</span> attachments],
                }
                invoice.attachment_ids = attachments.ids
                invoice.message_ids = [Command.<span class="hljs-built_in">set</span>(sub_new_message.<span class="hljs-built_in">id</span>)]
                <span class="hljs-built_in">super</span>(AccountMove, invoice)._message_post_after_hook(sub_new_message, sub_message_values)

        <span class="hljs-keyword">return</span> res

    <span class="hljs-keyword">def</span> <span class="hljs-title function_">_creation_subtype</span>(<span class="hljs-params">self</span>):
        <span class="hljs-comment"># EXTENDS mail mail.thread</span>
        <span class="hljs-keyword">if</span> self.move_type <span class="hljs-keyword">in</span> (<span class="hljs-string">'out_invoice'</span>, <span class="hljs-string">'out_receipt'</span>):
            <span class="hljs-keyword">return</span> self.env.ref(<span class="hljs-string">'account.mt_invoice_created'</span>)
        <span class="hljs-keyword">else</span>:
            <span class="hljs-keyword">return</span> <span class="hljs-built_in">super</span>()._creation_subtype()

    <span class="hljs-keyword">def</span> <span class="hljs-title function_">_track_subtype</span>(<span class="hljs-params">self, init_values</span>):
        <span class="hljs-comment"># EXTENDS mail mail.thread</span>
        <span class="hljs-comment"># add custom subtype depending of the state.</span>
        self.ensure_one()

        <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> self.is_invoice(include_receipts=<span class="hljs-literal">True</span>):
            <span class="hljs-keyword">if</span> self.payment_id <span class="hljs-keyword">and</span> <span class="hljs-string">'state'</span> <span class="hljs-keyword">in</span> init_values:
                self.payment_id._message_track([<span class="hljs-string">'state'</span>], {self.payment_id.<span class="hljs-built_in">id</span>: init_values})
            <span class="hljs-keyword">return</span> <span class="hljs-built_in">super</span>()._track_subtype(init_values)

        <span class="hljs-keyword">if</span> <span class="hljs-string">'payment_state'</span> <span class="hljs-keyword">in</span> init_values <span class="hljs-keyword">and</span> self.payment_state == <span class="hljs-string">'paid'</span>:
            <span class="hljs-keyword">return</span> self.env.ref(<span class="hljs-string">'account.mt_invoice_paid'</span>)
        <span class="hljs-keyword">elif</span> <span class="hljs-string">'state'</span> <span class="hljs-keyword">in</span> init_values <span class="hljs-keyword">and</span> self.state == <span class="hljs-string">'posted'</span> <span class="hljs-keyword">and</span> self.is_sale_document(include_receipts=<span class="hljs-literal">True</span>):
            <span class="hljs-keyword">return</span> self.env.ref(<span class="hljs-string">'account.mt_invoice_validated'</span>)
        <span class="hljs-keyword">return</span> <span class="hljs-built_in">super</span>()._track_subtype(init_values)

    <span class="hljs-keyword">def</span> <span class="hljs-title function_">_creation_message</span>(<span class="hljs-params">self</span>):
        <span class="hljs-comment"># EXTENDS mail mail.thread</span>
        <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> self.is_invoice(include_receipts=<span class="hljs-literal">True</span>):
            <span class="hljs-keyword">return</span> <span class="hljs-built_in">super</span>()._creation_message()
        <span class="hljs-keyword">return</span> {
            <span class="hljs-string">'out_invoice'</span>: _(<span class="hljs-string">'Invoice Created'</span>),
            <span class="hljs-string">'out_refund'</span>: _(<span class="hljs-string">'Credit Note Created'</span>),
            <span class="hljs-string">'in_invoice'</span>: _(<span class="hljs-string">'Vendor Bill Created'</span>),
            <span class="hljs-string">'in_refund'</span>: _(<span class="hljs-string">'Refund Created'</span>),
            <span class="hljs-string">'out_receipt'</span>: _(<span class="hljs-string">'Sales Receipt Created'</span>),
            <span class="hljs-string">'in_receipt'</span>: _(<span class="hljs-string">'Purchase Receipt Created'</span>),
        }[self.move_type]

    <span class="hljs-keyword">def</span> <span class="hljs-title function_">_notify_by_email_prepare_rendering_context</span>(<span class="hljs-params">self, message, msg_vals, model_description=<span class="hljs-literal">False</span>,
                                                   force_email_company=<span class="hljs-literal">False</span>, force_email_lang=<span class="hljs-literal">False</span></span>):
        <span class="hljs-comment"># EXTENDS mail mail.thread</span>
        render_context = <span class="hljs-built_in">super</span>()._notify_by_email_prepare_rendering_context(
            message, msg_vals, model_description=model_description,
            force_email_company=force_email_company, force_email_lang=force_email_lang
        )
        subtitles = [render_context[<span class="hljs-string">'record'</span>].name]
        <span class="hljs-keyword">if</span> self.invoice_date_due <span class="hljs-keyword">and</span> self.payment_state <span class="hljs-keyword">not</span> <span class="hljs-keyword">in</span> (<span class="hljs-string">'in_payment'</span>, <span class="hljs-string">'paid'</span>):
            subtitles.append(_(<span class="hljs-string">'%(amount)s due\N{NO-BREAK SPACE}%(date)s'</span>,
                           amount=format_amount(self.env, self.amount_total, self.currency_id, lang_code=render_context.get(<span class="hljs-string">'lang'</span>)),
                           date=format_date(self.env, self.invoice_date_due, date_format=<span class="hljs-string">'short'</span>, lang_code=render_context.get(<span class="hljs-string">'lang'</span>))
                          ))
        <span class="hljs-keyword">else</span>:
            subtitles.append(format_amount(self.env, self.amount_total, self.currency_id, lang_code=render_context.get(<span class="hljs-string">'lang'</span>)))
        render_context[<span class="hljs-string">'subtitles'</span>] = subtitles
        <span class="hljs-keyword">return</span> render_context

    <span class="hljs-keyword">def</span> <span class="hljs-title function_">_get_mail_thread_data_attachments</span>(<span class="hljs-params">self</span>):
        res = <span class="hljs-built_in">super</span>()._get_mail_thread_data_attachments()
        <span class="hljs-comment"># else, attachments with 'res_field' get excluded</span>
        <span class="hljs-keyword">return</span> res | self.env[<span class="hljs-string">'account.move.send'</span>]._get_invoice_extra_attachments(self)

    <span class="hljs-comment"># -------------------------------------------------------------------------</span>
    <span class="hljs-comment"># TOOLING</span>
    <span class="hljs-comment"># -------------------------------------------------------------------------</span>

    <span class="hljs-keyword">def</span> <span class="hljs-title function_">_conditional_add_to_compute</span>(<span class="hljs-params">self, fname, condition</span>):
        field = self._fields[fname]
        to_reset = self.filtered(<span class="hljs-keyword">lambda</span> move:
            condition(move)
            <span class="hljs-keyword">and</span> <span class="hljs-keyword">not</span> self.env.is_protected(field, move._origin)
            <span class="hljs-keyword">and</span> (move._origin <span class="hljs-keyword">or</span> <span class="hljs-keyword">not</span> move[fname])
        )
        to_reset.invalidate_recordset([fname])
        self.env.add_to_compute(field, to_reset)

    <span class="hljs-comment"># -------------------------------------------------------------------------</span>
    <span class="hljs-comment"># HOOKS</span>
    <span class="hljs-comment"># -------------------------------------------------------------------------</span>

    <span class="hljs-keyword">def</span> <span class="hljs-title function_">_action_invoice_ready_to_be_sent</span>(<span class="hljs-params">self</span>):
        <span class="hljs-string">""" Hook allowing custom code when an invoice becomes ready to be sent by mail to the customer.
        For example, when an EDI document must be sent to the government and be signed by it.
        """</span>

    <span class="hljs-keyword">def</span> <span class="hljs-title function_">_is_ready_to_be_sent</span>(<span class="hljs-params">self</span>):
        <span class="hljs-string">""" Helper telling if a journal entry is ready to be sent by mail to the customer.

        :return: True if the invoice is ready, False otherwise.
        """</span>
        self.ensure_one()
        <span class="hljs-keyword">return</span> <span class="hljs-literal">True</span>

<span class="hljs-meta">    @contextmanager</span>
    <span class="hljs-keyword">def</span> <span class="hljs-title function_">_send_only_when_ready</span>(<span class="hljs-params">self</span>):
        moves_not_ready = self.filtered(<span class="hljs-keyword">lambda</span> x: <span class="hljs-keyword">not</span> x._is_ready_to_be_sent())

        <span class="hljs-keyword">try</span>:
            <span class="hljs-keyword">yield</span>
        <span class="hljs-keyword">finally</span>:
            moves_now_ready = moves_not_ready.filtered(<span class="hljs-keyword">lambda</span> x: x._is_ready_to_be_sent())
            <span class="hljs-keyword">if</span> moves_now_ready:
                moves_now_ready._action_invoice_ready_to_be_sent()

    <span class="hljs-keyword">def</span> <span class="hljs-title function_">_invoice_paid_hook</span>(<span class="hljs-params">self</span>):
        <span class="hljs-string">''' Hook to be overrided called when the invoice moves to the paid state. '''</span>

    <span class="hljs-keyword">def</span> <span class="hljs-title function_">_get_lines_onchange_currency</span>(<span class="hljs-params">self</span>):
        <span class="hljs-comment"># Override needed for COGS</span>
        <span class="hljs-keyword">return</span> self.line_ids

<span class="hljs-meta">    @api.model</span>
    <span class="hljs-keyword">def</span> <span class="hljs-title function_">_get_invoice_in_payment_state</span>(<span class="hljs-params">self</span>):
        <span class="hljs-string">''' Hook to give the state when the invoice becomes fully paid. This is necessary because the users working
        with only invoicing don't want to see the 'in_payment' state. Then, this method will be overridden in the
        accountant module to enable the 'in_payment' state. '''</span>
        <span class="hljs-keyword">return</span> <span class="hljs-string">'paid'</span>

    <span class="hljs-keyword">def</span> <span class="hljs-title function_">_get_name_invoice_report</span>(<span class="hljs-params">self</span>):
        <span class="hljs-string">""" This method need to be inherit by the localizations if they want to print a custom invoice report instead of
        the default one. For example please review the l10n_ar module """</span>
        self.ensure_one()
        <span class="hljs-keyword">return</span> <span class="hljs-string">'account.report_invoice_document'</span>

    <span class="hljs-keyword">def</span> <span class="hljs-title function_">_is_downpayment</span>(<span class="hljs-params">self</span>):
        <span class="hljs-string">''' Return true if the invoice is a downpayment.
        Down-payments can be created from a sale order. This method is overridden in the sale order module.
        '''</span>
        <span class="hljs-keyword">return</span> <span class="hljs-literal">False</span>

<span class="hljs-meta">    @api.model</span>
    <span class="hljs-keyword">def</span> <span class="hljs-title function_">get_invoice_localisation_fields_required_to_invoice</span>(<span class="hljs-params">self, country_id</span>):
        <span class="hljs-string">""" Returns the list of fields that needs to be filled when creating an invoice for the selected country.
        This is required for some flows that would allow a user to request an invoice from the portal.
        Using these, we can get their information and dynamically create form inputs based for the fields required legally for the company country_id.
        The returned fields must be of type ir.model.fields in order to handle translations

        :param country_id: The country for which we want the fields.
        :return: an array of ir.model.fields for which the user should provide values.
        """</span>
        <span class="hljs-keyword">return</span> []</code>
</pre>
